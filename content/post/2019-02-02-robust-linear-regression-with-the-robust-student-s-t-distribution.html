---
title: Robust Linear Regression with Student’s $t$-Distribution
author: A. Solomon Kurz
date: '2019-02-02'
slug: robust-linear-regression-with-the-robust-student-s-t-distribution
categories: []
tags:
  - R
  - Bayesian
  - brms
  - outlier
  - robust
  - tutorial
header:
  caption: ''
  image: ''
---



<p>[edited Feb 3, 2019]</p>
<p>The purpose of this post is to demonstrate the advantages of the Student’s <span class="math inline">\(t\)</span>-distribution for regression with outliers, particularly within a <a href="https://www.youtube.com/channel/UCNJK6_DZvcMqNSzQdEkzvzA/playlists">Bayesian framework</a>.</p>
<div id="i-make-assumptions" class="section level2">
<h2>I make assumptions</h2>
<p>I’m presuming you are familiar with linear regression, familiar with the basic differences between frequentist and Bayesian approaches to fitting regression models, and have a sense that the issue of outlier values is a pickle worth contending with. All code in is <a href="https://www.r-bloggers.com/why-use-r-five-reasons/">R</a>, with a heavy use of the <a href="http://style.tidyverse.org">tidyverse</a>–which you might learn a lot about <a href="http://r4ds.had.co.nzhttp://r4ds.had.co.nz">here, especially chapter 5</a>– and <a href="https://twitter.com/paulbuerkner">Paul Bürkner</a>’s <a href="https://github.com/paul-buerkner/brms">brms</a> package.</p>
</div>
<div id="the-problem" class="section level2">
<h2>The problem</h2>
<p>Simple regression models typically use the Gaussian likelihood. Say you have some criterion variable <span class="math inline">\(y\)</span>, which you can reasonably describe with a mean <span class="math inline">\(\mu\)</span> and standard deviation <span class="math inline">\(\sigma\)</span>. Further, you’d like to describe <span class="math inline">\(y\)</span> with a predictor <span class="math inline">\(x\)</span>. Using the Gaussian likelihood, we can describe the model as</p>
<p><span class="math display">\[
\begin{eqnarray}
y_i &amp; \sim &amp; \text{Normal}(\mu_i, \sigma) \\
\mu_i &amp; = &amp; \beta_0 + \beta_1 x_i
\end{eqnarray}
\]</span></p>
<p>With this formulation, we use <span class="math inline">\(x\)</span> to model the mean of <span class="math inline">\(y\)</span>. The <span class="math inline">\(\beta_0\)</span> parameter is the intercept of the regression model and <span class="math inline">\(\beta_1\)</span> is its slope with respect to <span class="math inline">\(x\)</span>. After accounting for <span class="math inline">\(y\)</span>’s relation with <span class="math inline">\(x\)</span>, the leftover variability in <span class="math inline">\(y\)</span> is described by <span class="math inline">\(\sigma\)</span>, often called error or residual variance. The reason we describe the model in terms of <span class="math inline">\(\mu\)</span> and <span class="math inline">\(\sigma\)</span> is because those are the two parameters by which we define the Normal distribution, the Gaussian likelihood.</p>
<p>The Gaussian is a sensible default choice for many data types. You might say it works unreasonably well. Unfortunately, the normal (i.e., Gaussian) distribution is sensitive to outliers.</p>
<p>The normal distribution is a special case of Student’s <span class="math inline">\(t\)</span>-distribution with the <span class="math inline">\(\nu\)</span> parameter (i.e., the degree of freedom) set to infinity. However, when <span class="math inline">\(\nu\)</span> is small, Student’s <span class="math inline">\(t\)</span>-distribution is more robust to multivariate outliers. See <a href="http://www.stat.columbia.edu/~gelman/arm/">Gelman &amp; Hill (2007, chapter 6)</a> or <a href="https://sites.google.com/site/doingbayesiandataanalysis/">Kruschke (2014, chapter 16)</a> for textbook treatments on the topic.</p>
<p>In this post, we demonstrate how vulnerable the Gaussian likelihood is to outliers and then compare it to different ways of using Student’s <span class="math inline">\(t\)</span>-likelihood for the same data.</p>
<p>First, we’ll get a sense of the distributions with a plot.</p>
<pre class="r"><code>library(tidyverse)

tibble(x = seq(from = -6, to = 6, by = .01)) %&gt;% 
  expand(x, nu = c(1, 2.5, 5, 10, Inf)) %&gt;% 
  mutate(density = dt(x = x, df = nu),
         nu      = factor(nu, levels = c(&quot;Inf&quot;, &quot;10&quot;, &quot;5&quot;, &quot;2.5&quot;, &quot;1&quot;))) %&gt;% 
  
  ggplot(aes(x = x, y = density, group = nu, color = nu)) +
  geom_line() +
  scale_color_viridis_d(expression(nu),
                        direction = 1, option = &quot;C&quot;, end = .85) +
  scale_y_continuous(NULL, breaks = NULL) +
  coord_cartesian(xlim = -5:5) +
  xlab(NULL) +
  theme(panel.grid = element_blank())</code></pre>
<p><img src="/post/2019-02-02-robust-linear-regression-with-the-robust-student-s-t-distribution_files/figure-html/unnamed-chunk-1-1.png" width="528" /></p>
<p>So the difference is that a Student’s <span class="math inline">\(t\)</span>-distribution with a low <span class="math inline">\(\nu\)</span> will have notably heavier tails than the conventional Gaussian distribution. It’s easiest to see the difference when <span class="math inline">\(\nu\)</span> approaches 1. Even then, the difference can be subtle when looking at a plot. Another way is to compare how probable relatively extreme values are in a Student’s <span class="math inline">\(t\)</span>-distribution relative to the Gaussian. For the sake of demonstration, here we’ll compare Gauss with Student’s <span class="math inline">\(t\)</span> with a <span class="math inline">\(\nu\)</span> of 5. In the plot above, they are clearly different, but not shockingly so. However, that difference is very notable in the tails.</p>
<p>Let’s look more closely with a table. Below, we compare the probability of a given z-score or lower within the Gaussian and a <span class="math inline">\(\nu = 5\)</span> Student’s <span class="math inline">\(t\)</span>. In the rightmost column, we compare the probabilities in a ratio.</p>
<pre class="r"><code># Here we pic our nu
nu &lt;- 5

tibble(z_score               = 0:-5,
       p_Gauss               = pnorm(z_score, mean = 0, sd = 1),
       p_Student_t           = pt(z_score, df = nu),
       `Student/Gauss ratio` = p_Student_t/p_Gauss) %&gt;%
  mutate_if(is.double, round, digits = 5) %&gt;% 
  knitr::kable()</code></pre>
<table>
<thead>
<tr class="header">
<th align="right">z_score</th>
<th align="right">p_Gauss</th>
<th align="right">p_Student_t</th>
<th align="right">Student/Gauss ratio</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">0</td>
<td align="right">0.50000</td>
<td align="right">0.50000</td>
<td align="right">1.00000</td>
</tr>
<tr class="even">
<td align="right">-1</td>
<td align="right">0.15866</td>
<td align="right">0.18161</td>
<td align="right">1.14468</td>
</tr>
<tr class="odd">
<td align="right">-2</td>
<td align="right">0.02275</td>
<td align="right">0.05097</td>
<td align="right">2.24042</td>
</tr>
<tr class="even">
<td align="right">-3</td>
<td align="right">0.00135</td>
<td align="right">0.01505</td>
<td align="right">11.14871</td>
</tr>
<tr class="odd">
<td align="right">-4</td>
<td align="right">0.00003</td>
<td align="right">0.00516</td>
<td align="right">162.97775</td>
</tr>
<tr class="even">
<td align="right">-5</td>
<td align="right">0.00000</td>
<td align="right">0.00205</td>
<td align="right">7159.76534</td>
</tr>
</tbody>
</table>
<p>Note how low z-scores are more probable in this Student’s <span class="math inline">\(t\)</span> than in the Gaussian. This is most apparent in the <code>Student/Gauss ratio</code> column on the right. A consequence of this is that extreme scores are less influential to your solutions when you use a small-<span class="math inline">\(\nu\)</span> Student’s <span class="math inline">\(t\)</span>-distribution in place of the Gaussian. That is, the small-<span class="math inline">\(\nu\)</span> Student’s <span class="math inline">\(t\)</span> is more robust than the Gaussian to unusual and otherwise influential observations.</p>
<p>In order to demonstrate, let’s simulate our own. We’ll start by creating multivariate normal data.</p>
</div>
<div id="lets-create-our-initial-tibble-of-well-behaved-data-d" class="section level2">
<h2>Let’s create our initial <a href="https://cran.r-project.org/web/packages/tibble/vignettes/tibble.html">tibble</a> of well-behaved data, <code>d</code></h2>
<p>First, we’ll need to define our variance/covariance matrix.</p>
<pre class="r"><code>s &lt;- matrix(c(1, .6, 
              .6, 1), 
             nrow = 2, ncol = 2)</code></pre>
<p>By the two <code>.6</code>s on the off-diagonal positions, we indicated we’d like our two variables to have a correlation of .6.</p>
<p>Second, our variables also need means, which we’ll define with a mean vector.</p>
<pre class="r"><code>m &lt;- c(0, 0)</code></pre>
<p>With means of <code>0</code> and variances of <code>1</code>, our data are in a standardized metric.</p>
<p>Third, we’ll use the <code>mvrnorm()</code> function from the <a href="https://cran.r-project.org/web/packages/MASS/index.html">MASS package</a> to simulate our data.</p>
<pre class="r"><code>set.seed(3)

d &lt;- MASS::mvrnorm(n = 100, mu = m, Sigma = s) %&gt;%
  as_tibble() %&gt;%
  rename(y = V1, x = V2)</code></pre>
<p>The first few rows look like so:</p>
<pre class="r"><code>head(d)</code></pre>
<pre><code>## # A tibble: 6 x 2
##         y      x
##     &lt;dbl&gt;  &lt;dbl&gt;
## 1 -1.14   -0.584
## 2 -0.0805 -0.443
## 3 -0.239   0.702
## 4 -1.30   -0.761
## 5 -0.280   0.630
## 6 -0.245   0.299</code></pre>
<p>As an aside, check out <a href="https://www.r-bloggers.com/creating-sample-datasets-exercises/">this nice r-bloggers post</a> for more information on simulating data with this method.</p>
<p>Anyway, this line reorders our data by <code>x</code>, placing the smallest values on top.</p>
<pre class="r"><code>d &lt;-
  d %&gt;%
  arrange(x)

head(d)</code></pre>
<pre><code>## # A tibble: 6 x 2
##        y     x
##    &lt;dbl&gt; &lt;dbl&gt;
## 1 -2.21  -1.84
## 2 -1.27  -1.71
## 3 -0.168 -1.60
## 4 -0.292 -1.46
## 5 -0.785 -1.40
## 6 -0.157 -1.37</code></pre>
</div>
<div id="lets-create-our-outlier-tibble-o" class="section level2">
<h2>Let’s create our outlier tibble, <code>o</code></h2>
<p>Here we’ll make two outlying and unduly influential values.</p>
<pre class="r"><code>o &lt;- d
o[c(1:2), 1] &lt;- c(5, 4)

head(o)</code></pre>
<pre><code>## # A tibble: 6 x 2
##        y     x
##    &lt;dbl&gt; &lt;dbl&gt;
## 1  5     -1.84
## 2  4     -1.71
## 3 -0.168 -1.60
## 4 -0.292 -1.46
## 5 -0.785 -1.40
## 6 -0.157 -1.37</code></pre>
<p>With the code, above, we replaced the first two values of our first variable, <code>y</code>. They both started out quite negative. Now they are positive values of a large magnitude within the standardized metric.</p>
</div>
<div id="frequentist-ols-models" class="section level2">
<h2>Frequentist <a href="https://en.wikipedia.org/wiki/Ordinary_least_squares">OLS</a> models</h2>
<p>To get a quick sense of what we’ve done, we’ll first fit two models with OLS regression via the <code>lm()</code> function. The first model, <code>ols0</code>, is of the multivariate normal data, <code>d</code>. The second model, <code>ols1</code>, is on the otherwise identical data with the two odd and influential values, <code>o</code>. Here is our model code.</p>
<pre class="r"><code>ols0 &lt;- lm(data = d, y ~ 1 + x)
ols1 &lt;- lm(data = o, y ~ 1 + x)</code></pre>
<p>We’ll use the <a href="https://cran.r-project.org/web/packages/broom/index.html">broom package</a> to assist with model summaries and other things.</p>
<p>Here are the parameter estimates for the first model.</p>
<pre class="r"><code>library(broom)

tidy(ols0) %&gt;% mutate_if(is.double, round, digits = 2)</code></pre>
<pre><code>## # A tibble: 2 x 5
##   term        estimate std.error statistic p.value
##   &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt;
## 1 (Intercept)    -0.01      0.09     -0.08    0.94
## 2 x               0.45      0.1       4.55    0</code></pre>
<p>And now the parameters for the second model, the one based on the <code>o</code> outlier data.</p>
<pre class="r"><code>tidy(ols1) %&gt;% mutate_if(is.double, round, digits = 2)</code></pre>
<pre><code>## # A tibble: 2 x 5
##   term        estimate std.error statistic p.value
##   &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt;
## 1 (Intercept)     0.12      0.11      1.12    0.26
## 2 x               0.15      0.13      1.21    0.23</code></pre>
<p>Just two odd and influential values dramatically changed the model parameters, particularly the slope. Let’s plot the data and the models to get a visual sense of what happened.</p>
<pre class="r"><code># The well-behaived data
p1 &lt;-
  ggplot(data = d, aes(x = x, y = y)) +
  stat_smooth(method = &quot;lm&quot;, color = &quot;grey92&quot;, fill = &quot;grey67&quot;, alpha = 1, fullrange = T) +
  geom_point(size = 1, alpha = 3/4) +
  scale_x_continuous(limits = c(-4, 4)) +
  coord_cartesian(xlim = -3:3, 
                  ylim = -3:5) +
  labs(title = &quot;No Outliers&quot;) +
  theme(panel.grid = element_blank())

# The data with two outliers
p2 &lt;-
  ggplot(data = o, aes(x = x, y = y, color = y &gt; 3)) +
  stat_smooth(method = &quot;lm&quot;, color = &quot;grey92&quot;, fill = &quot;grey67&quot;, alpha = 1, fullrange = T) +
  geom_point(size = 1, alpha = 3/4) +
  scale_color_viridis_d(option = &quot;A&quot;, end = 4/7) +
  scale_x_continuous(limits = c(-4, 4)) +
  coord_cartesian(xlim = -3:3, 
                  ylim = -3:5) +
  labs(title = &quot;Two Outliers&quot;) +
  theme(panel.grid = element_blank(),
        legend.position = &quot;none&quot;)

library(gridExtra)

grid.arrange(p1, p2, ncol = 2)</code></pre>
<p><img src="/post/2019-02-02-robust-linear-regression-with-the-robust-student-s-t-distribution_files/figure-html/unnamed-chunk-12-1.png" width="648" /></p>
<p>The two outliers were quite influential on the slope. It went from a nice clear diagonal to almost horizontal. You’ll also note how the 95% intervals (i.e., the bowtie shapes) were a bit wider when based on the <code>o</code> data.</p>
<p>One of the popular ways to quantify outlier status is with Mahalanobis’ distance. However, the Mahalanobis distance is primarilly valid for multivariate normal data. Though the data in this example are indeed multivariate normal–or at least they were before we injected two outlying values into them–I am going to resist relying on Mahalanobis’ distance. There are other more general approaches that will be of greater use when you need to explore other variants of the generalized linear model. The <code>broom::augment()</code> function will give us access to one.</p>
<pre class="r"><code>aug0 &lt;- augment(ols0)
aug1 &lt;- augment(ols1)

glimpse(aug1)</code></pre>
<pre><code>## Observations: 100
## Variables: 9
## $ y          &lt;dbl&gt; 5.00000000, 4.00000000, -0.16783167, -0.29164105, -0.…
## $ x          &lt;dbl&gt; -1.8439208, -1.7071418, -1.5996509, -1.4601550, -1.39…
## $ .fitted    &lt;dbl&gt; -0.155937416, -0.135213012, -0.118926273, -0.09779020…
## $ .se.fit    &lt;dbl&gt; 0.2581834, 0.2427649, 0.2308204, 0.2155907, 0.2086463…
## $ .resid     &lt;dbl&gt; 5.15593742, 4.13521301, -0.04890540, -0.19385084, -0.…
## $ .hat       &lt;dbl&gt; 0.05521164, 0.04881414, 0.04412882, 0.03849763, 0.036…
## $ .sigma     &lt;dbl&gt; 0.964211, 1.017075, 1.104423, 1.104253, 1.102081, 1.1…
## $ .cooksd    &lt;dbl&gt; 6.809587e-01, 3.820802e-01, 4.783890e-05, 6.480561e-0…
## $ .std.resid &lt;dbl&gt; 4.82755612, 3.85879897, -0.04552439, -0.17992001, -0.…</code></pre>
<p>Here we can compare the observations with Cook’s distance, <span class="math inline">\(D_i\)</span> (i.e., <code>.cooksd</code>). Cook’s <span class="math inline">\(D_i\)</span> is a measure of the influence of a given observation on the model. To compute <span class="math inline">\(D_i\)</span>, the model is fit once for each <span class="math inline">\(n\)</span> case, after first dropping that case. Then the difference in the model with all observations and the model with all observations but the <span class="math inline">\(i\)</span>th observation, as defined by the Euclidian distance between the estimators. <a href="http://www.springer.com/us/book/9783642343322#aboutBook">Fahrmeir et al (2013, p. 166)</a> suggest that within the OLS framework “as a rule of thumb, observations with <span class="math inline">\(D_i\)</span> &gt; 0.5 are worthy of attention, and observations with <span class="math inline">\(D_i\)</span> &gt; 1 should always be examined.” Here we plot <span class="math inline">\(D_i\)</span> against our observation index, <span class="math inline">\(i\)</span>, for both models.</p>
<pre class="r"><code>aug0 %&gt;%  # The well-behaived data
  mutate(i = 1:n()) %&gt;%
  bind_rows(  # The data with two outliers
    aug1 %&gt;%
      mutate(i = 1:n())
    ) %&gt;%
  mutate(fit = rep(c(&quot;fit b0&quot;, &quot;fit b1&quot;), each = n()/2)) %&gt;%
  ggplot(aes(x = i, y = .cooksd)) +
  geom_hline(yintercept = .5, color = &quot;white&quot;) +
  geom_point(alpha = .5) +
  geom_text(data = tibble(i = 46, 
                          .cooksd = .53,
                          fit = &quot;fit b0&quot;),
            label = &quot;Fahrmeir et al said we might worry around here&quot;,
            color = &quot;grey50&quot;) +
  coord_cartesian(ylim = c(0, .7)) +
  theme(panel.grid = element_blank(),
        axis.title.x = element_text(face = &quot;italic&quot;, family = &quot;Times&quot;)) +
    facet_wrap(~fit)</code></pre>
<p><img src="/post/2019-02-02-robust-linear-regression-with-the-robust-student-s-t-distribution_files/figure-html/unnamed-chunk-14-1.png" width="768" /></p>
<p>For the model of the well-behaved data, <code>ols0</code>, we have <span class="math inline">\(D_i\)</span> values all hovering near zero. However, the plot for <code>ols1</code> shows one <span class="math inline">\(D_i\)</span> value well above the 0.5 level and another not quite that high but deviant relative to the rest. Our two outlier values look quite influential for the results of <code>ols1</code>.</p>
</div>
<div id="switch-to-a-bayesian-framework" class="section level2">
<h2>Switch to a Bayesian framework</h2>
<p>In this project, we’ll use the <a href="https://cran.r-project.org/web/packages/brms/index.html">brms package</a> to fit our Bayesian regression models. You can learn a lot about brms <a href="https://cran.r-project.org/web/packages/brms/vignettes/brms_overview.pdf">here</a> and <a href="https://github.com/paul-buerkner/brms">here</a>. Bayesian models, of course, require us to use priors. To keep things simple, we’ll use <a href="https://github.com/stan-dev/stan/wiki/Prior-Choice-Recommendations">weakly-regularizing priors</a>.</p>
<pre class="r"><code>library(brms)</code></pre>
<div id="stick-with-gauss." class="section level3">
<h3>Stick with Gauss.</h3>
<p>For our first two Bayesian models, <code>b0</code> and <code>b1</code>, we’ll use the conventional Gaussian likelihood (i.e., <code>family = gaussian</code> in the <code>brm()</code> function). Like with <code>ols0</code>, above, the first model is based on the nice <code>d</code> data. The second, <code>b1</code>, is based on the more-difficult <code>o</code> data.</p>
<pre class="r"><code>b0 &lt;- 
  brm(data = d, family = gaussian,
      y ~ 1 + x,
      prior = c(prior(normal(0, 10), class = Intercept),
                prior(normal(0, 10), class = b),
                prior(cauchy(0, 1),  class = sigma)),
      seed = 1)
b1 &lt;- 
  update(b0, 
         newdata = o)</code></pre>
<p>Here are the model summaries.</p>
<pre class="r"><code>tidy(b0) %&gt;% slice(1:3) %&gt;% mutate_if(is.double, round, digits = 2)</code></pre>
<pre><code>##          term estimate std.error lower upper
## 1 b_Intercept    -0.01      0.09 -0.15  0.13
## 2         b_x     0.44      0.10  0.29  0.61
## 3       sigma     0.87      0.07  0.77  0.98</code></pre>
<pre class="r"><code>tidy(b1) %&gt;% slice(1:3) %&gt;% mutate_if(is.double, round, digits = 2)</code></pre>
<pre><code>##          term estimate std.error lower upper
## 1 b_Intercept     0.12      0.11 -0.05  0.30
## 2         b_x     0.15      0.13 -0.05  0.36
## 3       sigma     1.10      0.08  0.99  1.24</code></pre>
<p>These should look familiar. They’re very much like the results from the OLS models. Hopefully this isn’t surprising. Our priors were quite weak, so there’s no reason to suspect the results would differ much.</p>
<div id="the-loo-and-other-goodies-help-with-diagnostics." class="section level4">
<h4>The LOO and other goodies help with diagnostics.</h4>
<p>With the <code>loo()</code> function, we’ll extract loo objects, which contain some handy output.</p>
<pre class="r"><code>loo_b0 &lt;- loo(b0)
loo_b1 &lt;- loo(b1)</code></pre>
<pre><code>## Warning: Found 1 observations with a pareto_k &gt; 0.7 in model &#39;b1&#39;. It is
## recommended to set &#39;reloo = TRUE&#39; in order to calculate the ELPD without
## the assumption that these observations are negligible. This will refit
## the model 1 times to compute the ELPDs for the problematic observations
## directly.</code></pre>
<p>We’ll use <code>str()</code> to get a sense of what’s all in there, using <code>loo_b1</code> as an example.</p>
<pre class="r"><code>str(loo_b1)</code></pre>
<pre><code>## List of 11
##  $ estimates  : num [1:3, 1:2] -155.63 6.64 311.26 15.54 3.91 ...
##   ..- attr(*, &quot;dimnames&quot;)=List of 2
##   .. ..$ : chr [1:3] &quot;elpd_loo&quot; &quot;p_loo&quot; &quot;looic&quot;
##   .. ..$ : chr [1:2] &quot;Estimate&quot; &quot;SE&quot;
##  $ pointwise  : num [1:100, 1:4] -14.29 -9.09 -1.04 -1.05 -1.24 ...
##   ..- attr(*, &quot;dimnames&quot;)=List of 2
##   .. ..$ : NULL
##   .. ..$ : chr [1:4] &quot;elpd_loo&quot; &quot;mcse_elpd_loo&quot; &quot;p_loo&quot; &quot;looic&quot;
##  $ diagnostics:List of 2
##   ..$ pareto_k: num [1:100] 0.8286 0.5899 -0.0669 -0.1036 -0.1012 ...
##   ..$ n_eff   : num [1:100] 40.5 348 3976.3 3973.3 3927.6 ...
##  $ psis_object: NULL
##  $ elpd_loo   : num -156
##  $ p_loo      : num 6.64
##  $ looic      : num 311
##  $ se_elpd_loo: num 15.5
##  $ se_p_loo   : num 3.91
##  $ se_looic   : num 31.1
##  $ model_name : chr &quot;b1&quot;
##  - attr(*, &quot;dims&quot;)= int [1:2] 4000 100
##  - attr(*, &quot;class&quot;)= chr [1:3] &quot;ic&quot; &quot;psis_loo&quot; &quot;loo&quot;
##  - attr(*, &quot;yhash&quot;)= chr &quot;5cdc17bb2cb41f3e3f0a617f418fff3fbb8e1ebf&quot;</code></pre>
<p>For a detailed explanation of all those elements, see the <a href="https://cran.r-project.org/web/packages/loo/loo.pdf">reference manual</a>. For our purposes, we’ll focus on the <code>pareto_k</code>. Here’s a glimpse of what it contains for the <code>b1</code> model.</p>
<pre class="r"><code>loo_b1$diagnostics$pareto_k %&gt;% as_tibble()</code></pre>
<pre><code>## Warning: Calling `as_tibble()` on a vector is discouraged, because the behavior is likely to change in the future. Use `enframe(name = NULL)` instead.
## This warning is displayed once per session.</code></pre>
<pre><code>## # A tibble: 100 x 1
##      value
##      &lt;dbl&gt;
##  1  0.829 
##  2  0.590 
##  3 -0.0669
##  4 -0.104 
##  5 -0.101 
##  6 -0.0321
##  7  0.0498
##  8 -0.114 
##  9  0.179 
## 10 -0.0736
## # … with 90 more rows</code></pre>
<p>We’ve got us a numeric vector of as many values as our data had observations–100 in this case. The <code>pareto_k</code> values can be used to examine overly-influential cases. See, for example <a href="https://stackoverflow.com/questions/39578834/linear-model-diagnostics-for-bayesian-models-using-rstan/39595436">this discussion on stackoverflow.com</a> in which several members of the <a href="http://mc-stan.org">Stan team</a> weighed in. The issue is also discussed in <a href="https://arxiv.org/abs/1507.04544">this paper</a>, in the <a href="https://cran.r-project.org/web/packages/loo/loo.pdf">loo reference manual</a>, and in <a href="https://www.youtube.com/watch?v=FUROJM3u5HQ&amp;feature=youtu.be&amp;a=">this presentation by Aki Vehtari</a>. If we explicitly open the <a href="https://cran.r-project.org/web/packages/loo/index.html">loo package</a>, we can use a few convenience functions to leverage <code>pareto_k</code> for diagnostic purposes. The <code>pareto_k_table()</code> function will categorize the <code>pareto_k</code> values and give us a sense of how many values are in problematic ranges.</p>
<pre class="r"><code>library(loo)

pareto_k_table(loo_b1)</code></pre>
<pre><code>## Pareto k diagnostic values:
##                          Count Pct.    Min. n_eff
## (-Inf, 0.5]   (good)     98    98.0%   3563      
##  (0.5, 0.7]   (ok)        1     1.0%   348       
##    (0.7, 1]   (bad)       1     1.0%   41        
##    (1, Inf)   (very bad)  0     0.0%   &lt;NA&gt;</code></pre>
<p>Happily, most of our cases were in the “good” range. One pesky case was in the “bad” range [can you guess which one?] and another case was only “ok” [and can you guess that one, too?]. The <code>pareto_k_ids()</code> function will tell exactly us which cases we’ll want to look at.</p>
<pre class="r"><code>pareto_k_ids(loo_b1)</code></pre>
<pre><code>## [1] 1 2</code></pre>
<p>Those numbers correspond to the row numbers in the data, <code>o</code>. These are exactly the cases that plagued our second OLS model, <code>fit1</code>, and are also the ones we hand coded to be outliers.</p>
<p>With the simple <code>plot()</code> function, we can get a diagnostic plot for the <code>pareto_k</code> values.</p>
<pre class="r"><code>plot(loo_b1)</code></pre>
<p><img src="/post/2019-02-02-robust-linear-regression-with-the-robust-student-s-t-distribution_files/figure-html/unnamed-chunk-21-1.png" width="480" /></p>
<p>There they are, cases 1 and 2, lurking in the “bad” and “[just] ok” ranges. We can also make a similar plot with ggplot2. Though it takes a little more work, ggplot2 makes it easy to compare <code>pareto_k</code> plots across models with a little faceting.</p>
<pre class="r"><code>loo_b0$diagnostics$pareto_k %&gt;%  # The well-behaived data
  as_tibble() %&gt;%
  mutate(i = 1:n()) %&gt;%
  bind_rows(  # The data with two outliers
    loo_b1$diagnostics$pareto_k %&gt;% 
      as_tibble() %&gt;%
      mutate(i = 1:n()) 
  ) %&gt;%
  rename(pareto_k = value) %&gt;%
  mutate(fit = rep(c(&quot;fit b0&quot;, &quot;fit b1&quot;), each = n()/2)) %&gt;%
  ggplot(aes(x = i, y = pareto_k)) +
  geom_hline(yintercept = c(.5, .7, 1), color = &quot;white&quot;) +
  geom_point(alpha = .5) +
  geom_text(data = tibble(i = c(3, 6, 2), 
                          pareto_k = c(.45, .65, .95),
                          label = c(&quot;good&quot;, &quot;[just] ok&quot;, &quot;bad&quot;),
                          fit = &quot;fit b0&quot;),
            aes(label = label),
            color = &quot;grey50&quot;) +
  theme(panel.grid = element_blank(),
        axis.title.x = element_text(face = &quot;italic&quot;, family = &quot;Times&quot;)) +
  facet_wrap(~fit)</code></pre>
<p><img src="/post/2019-02-02-robust-linear-regression-with-the-robust-student-s-t-distribution_files/figure-html/unnamed-chunk-22-1.png" width="768" /></p>
<p>So with <code>b0</code>–the model based on the well-behaved multivariate normal data, <code>d</code>–, all the <code>pareto_k</code> values hovered around zero in the “good” range. Things got concerning with model <code>b1</code>. But we know all that. Let’s move forward.</p>
</div>
<div id="what-do-we-do-with-those-overly-influential-outlying-values" class="section level4">
<h4>What do we do with those overly-influential outlying values?</h4>
<p>A typical way to handle outlying values is to delete them based on some criterion, such as the Mahalanobis distance, Cook’s <span class="math inline">\(D_i\)</span>, or our new friend the <code>pareto_k</code>. In our next two models, we’ll do that. In our <code>data</code> arguments, we can use the <code>slice()</code> function to omit cases. In model <code>b1.1</code>, we simply omit the first and most influential case. In model <code>b1.2</code>, we omitted both unduly-influential cases, the values from rows 1 and 2.</p>
<pre class="r"><code>b1.1 &lt;- 
  update(b1, 
         newdata = o %&gt;% slice(2:100))
b1.2 &lt;- 
  update(b1, 
         newdata = o %&gt;% slice(3:100))</code></pre>
<p>Here are the summaries for our models based on the <code>slice[d]</code> data.</p>
<pre class="r"><code>tidy(b1.1) %&gt;% slice(1:3) %&gt;% mutate_if(is.double, round, digits = 2)</code></pre>
<pre><code>##          term estimate std.error lower upper
## 1 b_Intercept     0.07      0.10 -0.09  0.23
## 2         b_x     0.28      0.12  0.09  0.47
## 3       sigma     0.97      0.07  0.87  1.09</code></pre>
<pre class="r"><code>tidy(b1.2) %&gt;% slice(1:3) %&gt;% mutate_if(is.double, round, digits = 2)</code></pre>
<pre><code>##          term estimate std.error lower upper
## 1 b_Intercept     0.02      0.09 -0.12  0.16
## 2         b_x     0.40      0.10  0.23  0.56
## 3       sigma     0.86      0.06  0.76  0.97</code></pre>
<p>They are closer to the true data generating model (i.e., the code we used to make <code>d</code>), especially <code>b1.2</code>. However, there are other ways to handle the influential cases without dropping them. Finally, we’re ready to switch to Student’s <span class="math inline">\(t\)</span>!</p>
</div>
</div>
<div id="time-to-leave-gauss-for-the-more-general-students-t" class="section level3">
<h3>Time to leave Gauss for the more general Student’s <span class="math inline">\(t\)</span></h3>
<p>Recall that the normal distribution is equivalent to a Student’s <span class="math inline">\(t\)</span> with the degrees of freedom parameter, <span class="math inline">\(\nu\)</span>, set to infinity. That is, <span class="math inline">\(\nu\)</span> is fixed. Here we’ll relax that assumption and estimate <span class="math inline">\(\nu\)</span> from the data just like we estimate <span class="math inline">\(\mu\)</span> with the linear model and <span class="math inline">\(\sigma\)</span> as the residual spread. Since <span class="math inline">\(\nu\)</span>’s now a parameter, we’ll have to give it a prior. For our first Student’s <span class="math inline">\(t\)</span> model, we’ll estimate <span class="math inline">\(\nu\)</span> with the brms default gamma(2, 0.1) prior.</p>
<pre class="r"><code>b2 &lt;- 
  brm(data = o, family = student,
      y ~ 1 + x,
      prior = c(prior(normal(0, 10), class = Intercept),
                prior(normal(0, 10), class = b),
                prior(gamma(2, 0.1), class = nu),
                prior(cauchy(0, 1),  class = sigma)),
      seed = 1)</code></pre>
<p>For the next model, we’ll switch out that weak gamma(2, 0.1) for a stronger gamma(4, 1). In some disciplines, the gamma distribution is something of an exotic bird. So before fitting the model, it might be useful to take a peek at what these gamma priors looks like. In the plot, below, the orange density in the background is the default gamma(2, 0.1) and the purple density in the foreground is the stronger gamma(4, 1).</p>
<pre class="r"><code># data
tibble(x = seq(from = 0, to = 60, by = .1)) %&gt;% 
  expand(x, nesting(alpha = c(2, 4), 
                    beta  = c(0.1, 1))) %&gt;% 
  mutate(density = dgamma(x, alpha, beta),
         group   = rep(letters[1:2], times = n() / 2)) %&gt;% 
  
  # plot
  ggplot(aes(x = x, ymin = 0, ymax = density, 
             group = group, fill = group)) +
  geom_ribbon(size = 0, alpha = 3/4) +
  scale_fill_viridis_d(option = &quot;B&quot;, direction = -1, 
                       begin = 1/3, end = 2/3) +
  scale_y_continuous(NULL, breaks = NULL) +
  coord_cartesian(xlim = 0:50) +
  theme(panel.grid      = element_blank(),
        legend.position = &quot;none&quot;)</code></pre>
<p><img src="/post/2019-02-02-robust-linear-regression-with-the-robust-student-s-t-distribution_files/figure-html/unnamed-chunk-24-1.png" width="768" /></p>
<p>So the default prior is centered around values in the 2 to 30 range, but has a long gentle-sloping tail, allowing the model to yield much larger values for <span class="math inline">\(\nu\)</span>, as needed. The prior we use below is almost entirely concentrated in the single-digit range. In this case, that will preference Student’s <span class="math inline">\(t\)</span> likelihoods with very small <span class="math inline">\(\nu\)</span> parameters and correspondingly thick tails–easily allowing for extreme values.</p>
<pre class="r"><code>b3 &lt;- 
  update(b2,
         prior = c(prior(normal(0, 10), class = Intercept),
                   prior(normal(0, 10), class = b),
                   prior(gamma(4, 1),   class = nu),
                   prior(cauchy(0, 1),  class = sigma)),
         seed = 1)</code></pre>
<p>For our final model, we’ll fix the <span class="math inline">\(\nu\)</span> parameter in a <code>bf()</code> statement.</p>
<pre class="r"><code>b4 &lt;-
  brm(data = o, family = student,
      bf(y ~ 1 + x, nu = 4),
      prior = c(prior(normal(0, 100), class = Intercept),
                prior(normal(0, 10),  class = b),
                prior(cauchy(0, 1),   class = sigma)),
         seed = 1)</code></pre>
<p>Now we’ve got all those models, we can gather their results into a sole tibble.</p>
<pre class="r"><code>b_estimates &lt;-
  tibble(model = c(&quot;b0&quot;, &quot;b1&quot;, &quot;b1.1&quot;, &quot;b1.2&quot;, &quot;b2&quot;, &quot;b3&quot;, &quot;b4&quot;)) %&gt;% 
  mutate(fit   = map(model, get)) %&gt;% 
  mutate(tidy  = map(fit, tidy)) %&gt;% 
  unnest(tidy) %&gt;% 
  filter(term %in% c(&quot;b_Intercept&quot;, &quot;b_x&quot;)) %&gt;%
  arrange(term)</code></pre>
<p>To get a sense of what we’ve done, let’s take a peek at our models tibble.</p>
<pre class="r"><code>b_estimates %&gt;%
  mutate_if(is.double, round, digits = 2)  # This is just to round the numbers</code></pre>
<pre><code>## # A tibble: 14 x 6
##    model term        estimate std.error  lower upper
##    &lt;chr&gt; &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;
##  1 b0    b_Intercept    -0.01      0.09 -0.15   0.13
##  2 b1    b_Intercept     0.12      0.11 -0.05   0.3 
##  3 b1.1  b_Intercept     0.07      0.1  -0.09   0.23
##  4 b1.2  b_Intercept     0.02      0.09 -0.12   0.16
##  5 b2    b_Intercept     0.04      0.09 -0.11   0.2 
##  6 b3    b_Intercept     0.04      0.09 -0.11   0.19
##  7 b4    b_Intercept     0.04      0.09 -0.11   0.19
##  8 b0    b_x             0.44      0.1   0.290  0.61
##  9 b1    b_x             0.15      0.13 -0.05   0.36
## 10 b1.1  b_x             0.28      0.12  0.09   0.47
## 11 b1.2  b_x             0.4       0.1   0.23   0.56
## 12 b2    b_x             0.35      0.11  0.17   0.53
## 13 b3    b_x             0.36      0.1   0.19   0.53
## 14 b4    b_x             0.37      0.1   0.2    0.54</code></pre>
<p>The models differ by their intercepts, slopes, sigmas, and <span class="math inline">\(\nu\)</span>s. For the sake of this post, we’ll focus on the slopes. Here we compare the different Bayesian models’ slopes by their posterior means and 95% intervals in a coefficient plot.</p>
<pre class="r"><code>b_estimates %&gt;%
  filter(term == &quot;b_x&quot;) %&gt;% # b_Intercept b_x
  
  ggplot(aes(x = model)) +
  geom_pointrange(aes(y    = estimate,
                      ymin = lower,
                      ymax = upper),
                  shape = 20) +
  coord_flip(ylim = c(-.2, 1)) +
  labs(title    = &quot;The x slope, varying by model&quot;,
       subtitle = &quot;The dots are the posterior means and the lines the percentile-based 95% intervals.&quot;,
       x        = NULL,
       y        = NULL) +
  theme(panel.grid   = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.y  = element_text(hjust = 0))</code></pre>
<p><img src="/post/2019-02-02-robust-linear-regression-with-the-robust-student-s-t-distribution_files/figure-html/unnamed-chunk-27-1.png" width="576" /></p>
<p>You might think of the <code>b0</code> slope as the “true” slope. That’s the one estimated from the well-behaved multivariate normal data, <code>d</code>. That estimate’s just where we’d want it to be. The <code>b1</code> slope is a disaster–way lower than the others. The slopes for <code>b1.1</code> and <code>b1.2</code> get better, but at the expense of deleting data. All three of our Student’s <span class="math inline">\(t\)</span> models produced slopes that were pretty close to the <code>b0</code> slope. They weren’t perfect, but, all in all, Student’s <span class="math inline">\(t\)</span>-distribution did pretty okay.</p>
</div>
<div id="we-need-more-loo-and-more-pareto_k." class="section level3">
<h3>We need more LOO and more <code>pareto_k</code>.</h3>
<p>We already have loo objects for our first two models, <code>b0</code> and <code>b1</code>. Let’s get some for models <code>b2</code> through <code>b4</code>.</p>
<pre class="r"><code>loo_b2 &lt;- loo(b2)
loo_b3 &lt;- loo(b3)
loo_b4 &lt;- loo(b4)</code></pre>
<p>With a little data wrangling, we can compare our models by how they look in our custom <code>pareto_k</code> diagnostic plots.</p>
<pre class="r"><code># make a custom function to work with the loo objects in bulk
get_pareto_k &lt;- function(l) {
  l$diagnostics$pareto_k %&gt;% 
    as_tibble() %&gt;%
    mutate(i = 1:n()) %&gt;% 
    rename(pareto_k = value)
}

# wrangle
tibble(name = str_c(&quot;loo_b&quot;, 1:4)) %&gt;% 
  mutate(loo_object = map(name, get)) %&gt;% 
  mutate(pareto_k = map(loo_object, get_pareto_k)) %&gt;% 
  unnest(pareto_k) %&gt;% 
  mutate(fit = rep(c(&quot;fit b1&quot;, &quot;fit b2&quot;, &quot;fit b3&quot;, &quot;fit b4&quot;), each = n() / 4)) %&gt;%
  
  # plot
  ggplot(aes(x = i, y = pareto_k)) +
  geom_hline(yintercept = c(.5, .7),
             color = &quot;white&quot;) +
  geom_point(alpha = .5) +
  scale_y_continuous(breaks = c(0, .5, .7)) +
  theme(panel.grid   = element_blank(),
        axis.title.x = element_text(face = &quot;italic&quot;, family = &quot;Times&quot;)) +
    facet_wrap(~fit)</code></pre>
<p><img src="/post/2019-02-02-robust-linear-regression-with-the-robust-student-s-t-distribution_files/figure-html/unnamed-chunk-28-1.png" width="768" /></p>
<p>Oh man, those Student’s <span class="math inline">\(t\)</span> models worked sweet! In a succession from <code>b2</code> through <code>b4</code>, each model looked better by <code>pareto_k</code>. All were way better than the typical Gaussian model, <code>b1</code>. While we’re at it, we might compare those by their LOO values.</p>
<pre class="r"><code>compare_ic(loo_b1, loo_b2, loo_b3, loo_b4)</code></pre>
<pre><code>##          LOOIC    SE
## b1      311.26 31.09
## b2      289.97 23.07
## b3      287.64 20.83
## b4      285.95 20.19
## b1 - b2  21.29 11.68
## b1 - b3  23.62 14.58
## b1 - b4  25.31 15.46
## b2 - b3   2.33  3.03
## b2 - b4   4.02  3.95
## b3 - b4   1.69  0.92</code></pre>
<p>In terms of the LOO, <code>b2</code> through <code>b4</code> were about the same, but all looked better than <code>b1</code>. In fairness, though, the standard errors for the difference scores were a bit on the wide side. If you’re new to using information criteria to compare models, you might sit down and soak in <a href="https://www.youtube.com/watch?v=t0pRuy1_190&amp;list=PLDcUM9US4XdM9_N6XUUFrhghGJ4K25bFc&amp;index=8">this lecture on the topic</a> and <a href="https://cran.r-project.org/web/packages/loo/vignettes/loo-example.html">this vignette</a> on the LOO in particular. For a more technical introduction, you might check out the references in the loo package’s <a href="https://cran.r-project.org/web/packages/loo/loo.pdf">reference manual</a>.</p>
<p>For one final LOO-related comparison, we can use the <code>brms::model_weights()</code> function to see how much relative weight we might put on each of those four models if we were to use a model averaging approach. Here we use the default method, which is model averaging via posterior predictive stacking.</p>
<pre class="r"><code>model_weights(b1, b2, b3, b4)</code></pre>
<pre><code>##           b1           b2           b3           b4 
## 6.956356e-07 4.480928e-09 4.036950e-06 9.999953e-01</code></pre>
<p>If you’re not a fan of scientific notation, just tack on <code>round(digits = 2)</code>. The stacking method suggests that we should place virtually all the weight on <code>b4</code>, the model in which we fixed our Student-<span class="math inline">\(t\)</span> <span class="math inline">\(\nu\)</span> parameter at 4. To learn more about model stacking, check out Yao, Vehtari, Simpson, and Gelman’s (2018) paper, <a href="https://projecteuclid.org/euclid.ba/1516093227"><em>Using stacking to average Bayesian predictive distributions</em></a>.</p>
</div>
<div id="lets-compare-a-few-bayesian-models." class="section level3">
<h3>Let’s compare a few Bayesian models.</h3>
<p>That’s enough with coefficients, <code>pareto_k</code>, and the LOO. Let’s get a sense of the implications of the models by comparing a few in plots. Here we use convenience functions from <a href="https://twitter.com/mjskay">Matthew Kay</a>’s <a href="https://github.com/mjskay/tidybayes">tidybayes</a> package to streamline the data wrangling and plotting. [The method came from a <a href="https://twitter.com/mjskay/status/1091926564101599232">kind twitter suggesion from Kay</a>.]</p>
<pre class="r"><code>library(tidybayes)

# These are the values of x we&#39;d like model-implied summaries for
nd &lt;- tibble(x = seq(from = -4, to = 4, length.out = 50))

# here&#39;s another way to arrange the models
list(b0 = b0, b1 = b1, b3 = b3) %&gt;% 
  # with help from 1tidybayes::add_fitted_draws()`, here we use `fitted()` in bulk
  map_dfr(add_fitted_draws, newdata = nd, .id = &quot;model&quot;) %&gt;% 
  
  # plot
  ggplot(aes(x = x)) +
  stat_lineribbon(aes(y = .value),
                  .width = .95,
                  color = &quot;grey92&quot;, fill = &quot;grey67&quot;) +
  geom_point(data = d %&gt;%
               bind_rows(o, o) %&gt;%
               mutate(model = rep(c(&quot;b0&quot;, &quot;b1&quot;, &quot;b3&quot;), each = 100)), 
             aes(y = y, color = y &gt; 3),
             size = 1, alpha = 3/4) +
  scale_color_viridis_d(option = &quot;A&quot;, end = 4/7) +
  coord_cartesian(xlim = -3:3, 
                  ylim = -3:5) +
  ylab(NULL) +
  theme(panel.grid      = element_blank(),
        legend.position = &quot;none&quot;) +
  facet_wrap(~model)</code></pre>
<p><img src="/post/2019-02-02-robust-linear-regression-with-the-robust-student-s-t-distribution_files/figure-html/unnamed-chunk-31-1.png" width="768" /></p>
<p>For each subplot, the gray band is the 95% interval band and the overlapping light gray line is the posterior mean. Model <code>b0</code>, recall, is our baseline comparison model. This is of the well-behaved no-outlier data, <code>d</code>, using the good old Gaussian likelihood. Model <code>b1</code> is of the outlier data, <code>o</code>, but still using the non-robust Gaussian likelihood. Model <code>b3</code> uses a robust Student’s <span class="math inline">\(t\)</span> likelihood with <span class="math inline">\(\nu\)</span> estimated with the fairly narrow gamma(4, 1) prior. For my money, <code>b3</code> did a pretty good job.</p>
<pre class="r"><code>sessionInfo()</code></pre>
<pre><code>## R version 3.5.1 (2018-07-02)
## Platform: x86_64-apple-darwin15.6.0 (64-bit)
## Running under: macOS High Sierra 10.13.6
## 
## Matrix products: default
## BLAS: /Library/Frameworks/R.framework/Versions/3.5/Resources/lib/libRblas.0.dylib
## LAPACK: /Library/Frameworks/R.framework/Versions/3.5/Resources/lib/libRlapack.dylib
## 
## locale:
## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
##  [1] tidybayes_1.0.3 loo_2.0.0       brms_2.7.0      Rcpp_1.0.0     
##  [5] gridExtra_2.3   broom_0.5.1     bindrcpp_0.2.2  forcats_0.3.0  
##  [9] stringr_1.3.1   dplyr_0.7.6     purrr_0.2.5     readr_1.1.1    
## [13] tidyr_0.8.1     tibble_2.0.1    ggplot2_3.1.0   tidyverse_1.2.1
## 
## loaded via a namespace (and not attached):
##   [1] colorspace_1.3-2          ggridges_0.5.0           
##   [3] rsconnect_0.8.8           rprojroot_1.3-2          
##   [5] ggstance_0.3              markdown_0.8             
##   [7] base64enc_0.1-3           rstudioapi_0.7           
##   [9] rstan_2.18.2              svUnit_0.7-12            
##  [11] DT_0.4                    fansi_0.4.0              
##  [13] mvtnorm_1.0-8             lubridate_1.7.4          
##  [15] xml2_1.2.0                bridgesampling_0.4-0     
##  [17] knitr_1.20                shinythemes_1.1.1        
##  [19] bayesplot_1.6.0           jsonlite_1.5             
##  [21] shiny_1.1.0               compiler_3.5.1           
##  [23] httr_1.3.1                backports_1.1.2          
##  [25] assertthat_0.2.0          Matrix_1.2-14            
##  [27] lazyeval_0.2.1            cli_1.0.1                
##  [29] later_0.7.3               htmltools_0.3.6          
##  [31] prettyunits_1.0.2         tools_3.5.1              
##  [33] igraph_1.2.1              coda_0.19-2              
##  [35] gtable_0.2.0              glue_1.3.0               
##  [37] reshape2_1.4.3            cellranger_1.1.0         
##  [39] nlme_3.1-137              blogdown_0.8             
##  [41] crosstalk_1.0.0           xfun_0.3                 
##  [43] ps_1.2.1                  rvest_0.3.2              
##  [45] mime_0.5                  miniUI_0.1.1.1           
##  [47] gtools_3.8.1              MASS_7.3-50              
##  [49] zoo_1.8-2                 scales_1.0.0             
##  [51] colourpicker_1.0          hms_0.4.2                
##  [53] promises_1.0.1            Brobdingnag_1.2-5        
##  [55] parallel_3.5.1            inline_0.3.15            
##  [57] shinystan_2.5.0           yaml_2.1.19              
##  [59] StanHeaders_2.18.0-1      stringi_1.2.3            
##  [61] highr_0.7                 dygraphs_1.1.1.5         
##  [63] pkgbuild_1.0.2            rlang_0.3.1              
##  [65] pkgconfig_2.0.2           matrixStats_0.54.0       
##  [67] evaluate_0.10.1           lattice_0.20-35          
##  [69] bindr_0.1.1               rstantools_1.5.0         
##  [71] htmlwidgets_1.2           labeling_0.3             
##  [73] tidyselect_0.2.4          processx_3.2.1           
##  [75] plyr_1.8.4                magrittr_1.5             
##  [77] bookdown_0.7              R6_2.3.0                 
##  [79] generics_0.0.2            pillar_1.3.1             
##  [81] haven_1.1.2               withr_2.1.2              
##  [83] xts_0.10-2                abind_1.4-5              
##  [85] modelr_0.1.2              crayon_1.3.4             
##  [87] arrayhelpers_1.0-20160527 utf8_1.1.4               
##  [89] rmarkdown_1.10            grid_3.5.1               
##  [91] readxl_1.1.0              callr_3.1.0              
##  [93] threejs_0.3.1             digest_0.6.18            
##  [95] xtable_1.8-2              httpuv_1.4.4.2           
##  [97] stats4_3.5.1              munsell_0.5.0            
##  [99] viridisLite_0.3.0         shinyjs_1.0</code></pre>
</div>
</div>
