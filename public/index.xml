<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>A. Solomon Kurz on A. Solomon Kurz</title>
    <link>/</link>
    <description>Recent content in A. Solomon Kurz on A. Solomon Kurz</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2018</copyright>
    <lastBuildDate>Sat, 29 Sep 2018 00:00:00 -0500</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Individuals are not small groups, I: Simpson&#39;s paradox</title>
      <link>/post/individuals-are-not-small-groups-i-simpson-s-paradox/</link>
      <pubDate>Wed, 09 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/individuals-are-not-small-groups-i-simpson-s-paradox/</guid>
      <description>&lt;div id=&#34;tldr&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;tl;dr&lt;/h2&gt;
&lt;p&gt;If you are under the impression group-level data and group-based data analysis will inform you about within-person processes, you would be wrong. Stick around to learn why.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;this-is-gonna-be-a-long-car-ride.&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;This is gonna be a long car ride.&lt;/h2&gt;
&lt;p&gt;Earlier this year I published &lt;a href=&#34;https://www.sciencedirect.com/science/article/pii/S2212144718301807?via%3Dihub&#34;&gt;a tutorial&lt;/a&gt; &lt;a href=&#34;#fn1&#34; class=&#34;footnote-ref&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; on a statistical technique that will allow you to analyze the multivariate time series data of a single individual. It’s called the dynamic p-technique. The method has been around since at least the 80s (&lt;a href=&#34;https://link.springer.com/article/10.1007/BF02294246&#34;&gt;Molenaar, 1985&lt;/a&gt;) and its precursors date back to at least the 40s (&lt;a href=&#34;https://link.springer.com/article/10.1007/BF02288941&#34;&gt;Cattell, Cattell, &amp;amp; Rhymer, 1947&lt;/a&gt;). In the age where it’s increasingly cheap and easy to collect data from large groups, on both one measurement occasion or over many, you might wonder why you should learn about a single-case statistical technique. Isn’t such a thing unneeded?&lt;/p&gt;
&lt;p&gt;No. It is indeed needed. Unfortunately for me, the reasons we need it aren’t intuitive or well understood. Luckily for us all, I’m a patient man. We’ll be covering the reasons step by step. Once we’re done covering reasons, we’ll switch into full-blown tutorial mode. In this first blog on the topic, we’ll cover reason #1: Simpson’s paradox is a thing and it’ll bite you hard it you’re not looking for it.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;simpsons-paradox&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Simpson’s paradox&lt;/h2&gt;
&lt;p&gt;Simpson’s paradox officially made its way into the literature in &lt;a href=&#34;http://math.bme.hu/~marib/bsmeur/simpson.pdf&#34;&gt;this 1951 paper&lt;/a&gt; by Simpson. Rather than define the paradox outright, I’m going to demonstrate it with a classic example. The data come from the 1973 University of California, Berkeley, graduate admissions. Based on a simple breakdown of the admission rates, 44% of the men who applied were admitted. In contrast, only 35% of the women who applied were admitted. The university was accused of sexism and the issue made its way into the courts.&lt;/p&gt;
&lt;p&gt;However, when statisticians looked more closely at the data, it became apparent those data were not the compelling evidence of sexism they were initially made out to be. To see why, we’ll want to get into the data, ourselves. The admissions rates for the six largest departments have made their way into the peer-reviewed literature (&lt;a href=&#34;http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.394.9241&amp;amp;rep=rep1&amp;amp;type=pdf&#34;&gt;Bickel, Hammel, &amp;amp; O’Connell, 1975&lt;/a&gt;), into many textbooks (e.g., Danielle Navarro’s &lt;a href=&#34;https://learningstatisticswithr.com/lsr-0.6.pdf&#34;&gt;&lt;em&gt;Learning statistics with R&lt;/em&gt;&lt;/a&gt;), and are available in &lt;strong&gt;R&lt;/strong&gt; as the built-in data set &lt;code&gt;UCBAdmissions&lt;/code&gt;. Here we’ll call them, convert the data into a tidy format &lt;a href=&#34;#fn2&#34; class=&#34;footnote-ref&#34; id=&#34;fnref2&#34;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;, and add a variable.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidyverse)

d &amp;lt;-
  UCBAdmissions %&amp;gt;% 
  as_tibble() %&amp;gt;% 
  pivot_wider(id_cols = c(Dept, Gender),
              names_from = Admit, 
              values_from = n) %&amp;gt;% 
  mutate(total = Admitted + Rejected)

head(d)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 5
##   Dept  Gender Admitted Rejected total
##   &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
## 1 A     Male        512      313   825
## 2 A     Female       89       19   108
## 3 B     Male        353      207   560
## 4 B     Female       17        8    25
## 5 C     Male        120      205   325
## 6 C     Female      202      391   593&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The identities of the departments have been anonymized, so we’re stuck with referring to them as A through F. Much like with the overall rates for graduate admissions, it appears that the admission rates for the six anonymized departments in the &lt;code&gt;UCBAdmissions&lt;/code&gt; data show higher a admission rate for men.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;d %&amp;gt;% 
  group_by(Gender) %&amp;gt;% 
  summarise(percent_admitted = (100 * sum(Admitted) / sum(total)) %&amp;gt;% round(digits = 1))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 2 x 2
##   Gender percent_admitted
##   &amp;lt;chr&amp;gt;             &amp;lt;dbl&amp;gt;
## 1 Female             30.4
## 2 Male               44.5&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A 14% difference seems large enough to justify a stink. However, the plot thickens when we break the data down by department. For that, we’ll make a visual.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;d %&amp;gt;%  
  mutate(dept = str_c(&amp;quot;department &amp;quot;, Dept)) %&amp;gt;% 
  pivot_longer(cols = Admitted:Rejected,
               names_to = &amp;quot;admit&amp;quot;,
               values_to = &amp;quot;n&amp;quot;) %&amp;gt;% 
  
  ggplot(aes(x = Gender, y = n, fill = admit)) +
  geom_col(position = &amp;quot;dodge&amp;quot;) +
  scale_fill_viridis_d(NULL, option = &amp;quot;A&amp;quot;, end = .6) +
  xlab(NULL) +
  theme(panel.grid = element_blank()) +
  facet_wrap(~dept)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-10-09-individuals-are-not-small-groups-i-simpson-s-paradox_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The problem with our initial analysis is it didn’t take into account how different departments might admit men/women at different rates. We also failed to consider whether men and women applied to those different departments at different rates. Take departments A and B. Both admitted the majority of applicants, regardless of gender. Now look at departments E and F. The supermajorities of applicants were rejected, both for men and women Also notice that whereas the departments where the supermajority of applicants were men (i.e., departments A and B) had generous admission rates, the departments with the largest proportion of women applicants (i.e., departments C and E) had rather high rejection rates.&lt;/p&gt;
&lt;p&gt;It can be hard to juggle all this in your head at once, even with the aid of our figure. Let’s look at the data in a different way. This time we’ll summarize the admission rates in a probability metric where the probability of admission is &lt;code&gt;n / total&lt;/code&gt; (i.e., the number of successes divided by the total number of trials). We’ll compute those probabilities while grouping by &lt;code&gt;Gender&lt;/code&gt; and &lt;code&gt;Dept&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;d %&amp;gt;%
  mutate(p = Admitted / total) %&amp;gt;% 
  
  ggplot(aes(x = Dept, y = p)) +
  geom_hline(yintercept = .5, color = &amp;quot;white&amp;quot;) +
  geom_point(aes(color = Gender, size = total),
             position = position_dodge(width = 0.3)) +
  scale_color_manual(NULL, values = c(&amp;quot;red3&amp;quot;, &amp;quot;blue3&amp;quot;)) +
  scale_y_continuous(&amp;quot;admission probability&amp;quot;, limits = 0:1) +
  xlab(&amp;quot;department&amp;quot;) +
  theme(panel.grid = element_blank())&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-10-09-individuals-are-not-small-groups-i-simpson-s-paradox_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;576&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Several things pop out. For &lt;span class=&#34;math inline&#34;&gt;\(5/6\)&lt;/span&gt; of the departments (i.e., all but A), the admission probabilities were very similar for men and women–sometimes slightly higher for women, sometimes slightly higher for men. We also see a broad range overall admission rates across departments. Note how the dots are sized based on the &lt;code&gt;total&lt;/code&gt; number of applications, by &lt;code&gt;Gender&lt;/code&gt; and &lt;code&gt;Dept&lt;/code&gt;. Hopefully those sizes help show how women disproportionately applied to departments with low overall admission probabilities. Interestingly, the department with the largest gender bias was A, which showed a bias towards admitting women at &lt;em&gt;higher&lt;/em&gt; rates than men.&lt;/p&gt;
&lt;p&gt;Let’s get formal. The paradox Simpson wrote about is that the simple association between two variables can disappear or even change sign when it is conditioned on a relevant third variable. The relevant third variable is typically a grouping variable. In the Berkeley admissions example, the seemingly alarming association between graduate admissions and gender disappeared when conditioned on department. If you’re still jarred by this, Navarro covered this in the opening chapter of her text. Richard McElreath covered it more extensively in chapters 10 and 13 of his (2015) text, &lt;a href=&#34;https://xcelab.net/rm/statistical-rethinking/&#34;&gt;&lt;em&gt;Statistical Rethinking&lt;/em&gt;&lt;/a&gt;. I’ve also worked through a similar example of Simpson’s paradox from the more recent literature, &lt;a href=&#34;https://bookdown.org/content/1850/adventures-in-covariance.html#summary-bonus-another-berkley-admissions-data-like-example&#34;&gt;here&lt;/a&gt;. Kievit, Frankenhuis, Waldorp, and Borsboom (2013) wrote a &lt;a href=&#34;https://www.frontiersin.org/articles/10.3389/fpsyg.2013.00513/full&#34;&gt;fine primer on the topic&lt;/a&gt;, too.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;wait.-what&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Wait. What?&lt;/h2&gt;
&lt;p&gt;At this point you might be wondering what this has to do with the difference between groups and individuals. We’re slowly building a case step by step, remember? For this first installment, just notice how a simple bivariate analysis fell apart once we took an important third variable into account. In this case and in many others, it so happened that third variable was a grouping variable.&lt;/p&gt;
&lt;p&gt;Stay tuned for the next post where well build on this with a related phenomenon: the ecological fallacy.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;session-info&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Session info&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sessionInfo()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## R version 3.6.0 (2019-04-26)
## Platform: x86_64-apple-darwin15.6.0 (64-bit)
## Running under: macOS High Sierra 10.13.6
## 
## Matrix products: default
## BLAS:   /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRblas.0.dylib
## LAPACK: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRlapack.dylib
## 
## locale:
## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
## [1] forcats_0.4.0   stringr_1.4.0   dplyr_0.8.3     purrr_0.3.2    
## [5] readr_1.3.1     tidyr_1.0.0     tibble_2.1.3    ggplot2_3.2.1  
## [9] tidyverse_1.2.1
## 
## loaded via a namespace (and not attached):
##  [1] tidyselect_0.2.5  xfun_0.10         haven_2.1.0      
##  [4] lattice_0.20-38   colorspace_1.4-1  vctrs_0.2.0      
##  [7] generics_0.0.2    viridisLite_0.3.0 htmltools_0.4.0  
## [10] yaml_2.2.0        utf8_1.1.4        rlang_0.4.0      
## [13] pillar_1.4.2      glue_1.3.1        withr_2.1.2      
## [16] modelr_0.1.4      readxl_1.3.1      lifecycle_0.1.0  
## [19] munsell_0.5.0     blogdown_0.14     gtable_0.3.0     
## [22] cellranger_1.1.0  rvest_0.3.4       evaluate_0.14    
## [25] labeling_0.3      knitr_1.23        fansi_0.4.0      
## [28] broom_0.5.2       Rcpp_1.0.2        scales_1.0.0     
## [31] backports_1.1.5   jsonlite_1.6      hms_0.4.2        
## [34] digest_0.6.21     stringi_1.4.3     bookdown_0.12    
## [37] grid_3.6.0        cli_1.1.0         tools_3.6.0      
## [40] magrittr_1.5      lazyeval_0.2.2    crayon_1.3.4     
## [43] pkgconfig_2.0.3   zeallot_0.1.0     xml2_1.2.0       
## [46] lubridate_1.7.4   assertthat_0.2.1  rmarkdown_1.13   
## [49] httr_1.4.0        rstudioapi_0.10   R6_2.4.0         
## [52] nlme_3.1-139      compiler_3.6.0&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;footnotes&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Footnotes&lt;/h2&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;You can find the preprint and supporting documents, including the data and code, &lt;a href=&#34;https://osf.io/cbyj3/&#34;&gt;here&lt;/a&gt;.&lt;a href=&#34;#fnref1&#34; class=&#34;footnote-back&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn2&#34;&gt;&lt;p&gt;Walking out the definition of &lt;em&gt;tidy data&lt;/em&gt; is beyond the scope of this post. It’s connected to the work of data scientist &lt;a href=&#34;http://hadley.nz&#34;&gt;Hadley Wickham&lt;/a&gt;, in particular, and the ethos behind the collection of &lt;strong&gt;R&lt;/strong&gt; packages called the &lt;a href=&#34;https://www.tidyverse.org&#34;&gt;&lt;strong&gt;tidyverse&lt;/strong&gt;&lt;/a&gt;, more generally. My &lt;strong&gt;R&lt;/strong&gt; code tends to follow the &lt;a href=&#34;https://style.tidyverse.org&#34;&gt;tidyverse style&lt;/a&gt;. If you’re new these ideas, it’ll help if you familiarize yourself with them a bit. For an introduction to the notion of tidy data, Wickham’s recent talk, &lt;a href=&#34;https://www.youtube.com/watch?v=9YTNYT1maa4&#34;&gt;&lt;em&gt;Data visualization and data science&lt;/em&gt;&lt;/a&gt;, is a fine place to start.&lt;a href=&#34;#fnref2&#34; class=&#34;footnote-back&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>&#34;How to Survive a Plague&#34;: Part 2/$n$ of a premature book report</title>
      <link>/post/how-to-survive-a-plague-part-2-n-of-a-premature-book-report/</link>
      <pubDate>Mon, 30 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/how-to-survive-a-plague-part-2-n-of-a-premature-book-report/</guid>
      <description>&lt;div id=&#34;hit-the-pause&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Hit the pause&lt;/h2&gt;
&lt;p&gt;I started this series intending to add semiregular installments. Perhaps I’d add one every other month or so. It turns out I’m just not up to it, right now.&lt;/p&gt;
&lt;p&gt;Someone important to me died during this plague. Reading and blogging on this book was and has been a way to connect with them—to honor their life. The experience has been rich and raw and meaningful. I hope that not too far off in the future, I’ll be in a better place to take up this task. Until then, take care of you and, to the extent you can bear, look upon those around you with kindness in your heart.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Bayesian power analysis: Part III.b. What about 0/1 data?</title>
      <link>/post/bayesian-power-analysis-part-iii-b/</link>
      <pubDate>Tue, 27 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/bayesian-power-analysis-part-iii-b/</guid>
      <description>&lt;div id=&#34;version-1.0.0&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Version 1.0.0&lt;/h2&gt;
&lt;p&gt;In the &lt;a href=&#34;https://solomonkurz.netlify.com/post/bayesian-power-analysis-part-iii-a/&#34;&gt;last post&lt;/a&gt;, we covered how the Poisson distribution is handy for modeling count data. Binary data are even weirder than counts. They typically only take on two values: 0 and 1. Sometimes 0 is a stand-in for “no” and 1 for “yes” (e.g., &lt;em&gt;Are you an expert in Bayesian power analysis?&lt;/em&gt; For me that would be &lt;code&gt;0&lt;/code&gt;). You can also have data of this kind if you asked people whether they’d like to choose option A or B. With those kinds of data, you might arbitrarily code A as 0 and B as 1. Binary data also often stand in for trials where 0 = “fail” and 1 = “success.” For example, if you answered “Yes” to the question &lt;em&gt;Are all data normally distributed?&lt;/em&gt; we’d mark your answer down as a &lt;code&gt;0&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Though 0s and 1s are popular, sometimes binary data appear in their aggregated form. Let’s say I gave you 10 algebra questions and you got 7 of them right. Here’s one way to encode those data.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;n &amp;lt;- 10
z &amp;lt;- 7

rep(0:1, times = c(n - z, z))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] 0 0 0 1 1 1 1 1 1 1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In that example, &lt;code&gt;n&lt;/code&gt; stood for the total number of trials and &lt;code&gt;z&lt;/code&gt; was the number you got correct (i.e., the number of times we encoded your response as a 1). A more compact way to encode that data is with two columns, one for &lt;code&gt;z&lt;/code&gt; and the other for &lt;code&gt;n&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidyverse)

tibble(z = z,
       n = n)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1 x 2
##       z     n
##   &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
## 1     7    10&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So then if you gave those same 10 questions to four of your friends, we could encode the results like this.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(3)

tibble(id = letters[1:5],
       z  = rpois(n = 5, lambda = 5),
       n  = n)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 5 x 3
##   id        z     n
##   &amp;lt;chr&amp;gt; &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt;
## 1 a         3    10
## 2 b         7    10
## 3 c         4    10
## 4 d         4    10
## 5 e         5    10&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you were &lt;code&gt;b&lt;/code&gt;, you’d be the smart one in the group.&lt;/p&gt;
&lt;p&gt;Anyway, whether working with binary or aggregated binary data, we’re interested in the probability a given trial will be 1.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;logistic-regression-with-unaggregated-binary-data&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Logistic regression with unaggregated binary data&lt;/h2&gt;
&lt;p&gt;Taking unaggregated binary data as a starting point, given &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt; data that includes a variable &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt; where the value in the &lt;span class=&#34;math inline&#34;&gt;\(i^\text{th}\)&lt;/span&gt; row is a 0 or a 1, we’d like to know the probability a given trial would be 1, given &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt; [i.e., &lt;span class=&#34;math inline&#34;&gt;\(p(y_i = 1 | d)\)&lt;/span&gt;]. The binomial distribution will help us get that estimate for &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt;. We’ll do so within the context of a logistic regression model following the form&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{align*}
y_i                        &amp;amp; \sim \text{Binomial} (n = 1, p_i) \\
\operatorname{logit} (p_i) &amp;amp; = \beta_0,
\end{align*}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;were the logit function is defined as the log odds&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\operatorname{logit} (p_i) = \operatorname{log} \bigg (\frac{p_i}{1 - p_i} \bigg),
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;which also means that&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\operatorname{log} \bigg (\frac{p_i}{1 - p_i} \bigg) = \beta_0.
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;In those formulas, &lt;span class=&#34;math inline&#34;&gt;\(\beta_0\)&lt;/span&gt; is the intercept. In a binomial model with no predictors &lt;a href=&#34;#fn1&#34; class=&#34;footnote-ref&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;, the intercept &lt;span class=&#34;math inline&#34;&gt;\(\beta_0\)&lt;/span&gt; is just the estimate for &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt;, but in the log-odds metric. So yes, similar to the Poisson models from the last post, we typically use a link function with our binomial models. Instead of the log link, we use the logit because it constrains the posterior for &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt; to values between 0 and 1. Just as the null value for a probability is .5, the null value for the parameters within a logistic regression model is typically 0.&lt;/p&gt;
&lt;p&gt;As with the Poisson, I’m not going to go into a full-blown tutorial on the binomial distribution or on logistic regression. For more thorough introductions, check out chapters 9 through 10 in McElreath’s &lt;a href=&#34;https://xcelab.net/rm/statistical-rethinking/&#34;&gt;&lt;em&gt;Statistical Rethinking&lt;/em&gt;&lt;/a&gt; or Agresti’s &lt;a href=&#34;https://www.wiley.com/en-us/Foundations+of+Linear+and+Generalized+Linear+Models-p-9781118730034&#34;&gt;&lt;em&gt;Foundations of Linear and Generalized Linear Models&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;div id=&#34;we-need-data.&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;We need data.&lt;/h3&gt;
&lt;p&gt;Time to simulate some data. Let’s say we’d like to estimate the probability someone will hit a ball in a baseball game. Nowadays, batting averages for professional baseball players tend around .25 (see &lt;a href=&#34;http://www.baseball-almanac.com/hitting/hibavg4.shtml&#34;&gt;here&lt;/a&gt;). So if we wanted to simulate 50 at-bats, we might do so like this.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(3)

d &amp;lt;- tibble(y = rbinom(n = 50, size = 1, prob = .25))

str(d)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Classes &amp;#39;tbl_df&amp;#39;, &amp;#39;tbl&amp;#39; and &amp;#39;data.frame&amp;#39;:    50 obs. of  1 variable:
##  $ y: int  0 1 0 0 0 0 0 0 0 0 ...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here are what those data look like in a bar plot.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;theme_set(theme_gray() + theme(panel.grid = element_blank()))

d %&amp;gt;% 
  mutate(y = factor(y)) %&amp;gt;% 
  
  ggplot(aes(x = y)) +
  geom_bar()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-08-27-bayesian-power-analysis-part-iii-b_files/figure-html/unnamed-chunk-5-1.png&#34; width=&#34;288&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;time-to-model.&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Time to model.&lt;/h3&gt;
&lt;p&gt;To practice modeling those data, we’ll want to fire up the &lt;a href=&#34;https://github.com/paul-buerkner/brms&#34;&gt;&lt;strong&gt;brms&lt;/strong&gt; package&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(brms)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can use the &lt;code&gt;get_prior()&lt;/code&gt; function to get the &lt;strong&gt;brms&lt;/strong&gt; default for our intercept-only logistic regression model.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;get_prior(data = d, 
          family = binomial,
          y | trials(1) ~ 1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Intercept ~ student_t(3, 0, 10)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As it turns out, that’s a really liberal prior. We might step up a bit and put a more skeptical &lt;code&gt;normal(0, 2)&lt;/code&gt; prior on that intercept. With the context of our logit link, that still puts a 95% probability that the &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt; is between .02 and .98, which is almost the entire parameter space. Here’s how to fit the model with the &lt;code&gt;brm()&lt;/code&gt; function.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fit1 &amp;lt;-
  brm(data = d, 
      family = binomial,
      y | trials(1) ~ 1,
      prior(normal(0, 2), class = Intercept),
      seed = 3)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the &lt;code&gt;brm()&lt;/code&gt; formula syntax, including a &lt;code&gt;|&lt;/code&gt; bar on the left side of a formula indicates we have extra supplementary information about our criterion variable. In this case, that information is that each &lt;code&gt;y&lt;/code&gt; value corresponds to a single trial [i.e., &lt;code&gt;trials(1)&lt;/code&gt;], which itself corresponds to the &lt;span class=&#34;math inline&#34;&gt;\(n = 1\)&lt;/span&gt; portion of the statistical formula, above. Here are the results.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;print(fit1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  Family: binomial 
##   Links: mu = logit 
## Formula: y | trials(1) ~ 1 
##    Data: d (Number of observations: 50) 
## Samples: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;
##          total post-warmup samples = 4000
## 
## Population-Level Effects: 
##           Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
## Intercept    -1.39      0.36    -2.12    -0.73 1.00     1527     1358
## 
## Samples were drawn using sampling(NUTS). For each parameter, Eff.Sample 
## is a crude measure of effective sample size, and Rhat is the potential 
## scale reduction factor on split chains (at convergence, Rhat = 1).&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Remember that that intercept is on the scale of the logit link, the log odds. We can transform it with the &lt;code&gt;brms::inv_logit_scaled()&lt;/code&gt; function.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fixef(fit1)[&amp;quot;Intercept&amp;quot;, 1] %&amp;gt;% 
  inv_logit_scaled()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.1991036&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we’d like to view the full posterior distribution, we’ll need to work with the posterior draws themselves. Then we’ll plot.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# extract the posterior draws
posterior_samples(fit1) %&amp;gt;% 
  # transform from the log-odds to a probability metric
  transmute(p = inv_logit_scaled(b_Intercept)) %&amp;gt;% 
  
  # plot!
  ggplot(aes(x = p)) +
  geom_density(fill = &amp;quot;grey25&amp;quot;, size = 0) +
  scale_x_continuous(&amp;quot;probability of a hit&amp;quot;, limits = c(0, 1)) +
  scale_y_continuous(NULL, breaks = NULL)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-08-27-bayesian-power-analysis-part-iii-b_files/figure-html/unnamed-chunk-11-1.png&#34; width=&#34;384&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Looks like the null hypothesis of &lt;span class=&#34;math inline&#34;&gt;\(p = .5\)&lt;/span&gt; is not credible for this simulation. If we’d like the posterior median and percentile-based 95% intervals, we might use the &lt;code&gt;median_qi()&lt;/code&gt; function from the handy &lt;a href=&#34;https://mjskay.github.io/tidybayes/index.html&#34;&gt;&lt;strong&gt;tidybayes&lt;/strong&gt; package&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidybayes)

posterior_samples(fit1) %&amp;gt;% 
  transmute(p = inv_logit_scaled(b_Intercept)) %&amp;gt;% 
  median_qi()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1 x 6
##       p .lower .upper .width .point .interval
##   &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;  &amp;lt;chr&amp;gt;    
## 1 0.201  0.108  0.325   0.95 median qi&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Yep, .5 was not within those intervals.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;but-what-about-power&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;But what about power?&lt;/h3&gt;
&lt;p&gt;That’s enough preliminary work. Let’s see what happens when we do a mini power analysis with 100 iterations. First we set up our simulation function using the same methods we introduced in earlier blog posts.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sim_data_fit &amp;lt;- function(seed, n_player) {
  
  n_trials &amp;lt;- 1
  prob_hit &amp;lt;- .25
  
  set.seed(seed)
  
  d &amp;lt;- tibble(y = rbinom(n    = n_player, 
                         size = n_trials, 
                         prob = prob_hit))
  
  update(fit1,
         newdata = d,
         seed = seed) %&amp;gt;% 
  posterior_samples() %&amp;gt;% 
  transmute(p = inv_logit_scaled(b_Intercept)) %&amp;gt;% 
  median_qi() %&amp;gt;% 
    select(.lower:.upper)
  
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Simulate.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sim1 &amp;lt;-
  tibble(seed = 1:100) %&amp;gt;% 
  mutate(ci = map(seed, sim_data_fit, n_player = 50)) %&amp;gt;% 
  unnest()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You might plot the intervals.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sim1 %&amp;gt;% 
  ggplot(aes(x = seed, ymin = .lower, ymax = .upper)) +
  geom_hline(yintercept = c(.25, .5), color = &amp;quot;white&amp;quot;) +
  geom_linerange() +
  xlab(&amp;quot;seed (i.e., simulation index)&amp;quot;) +
  scale_y_continuous(&amp;quot;probability of hitting the ball&amp;quot;, limits = c(0, 1))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-08-27-bayesian-power-analysis-part-iii-b_files/figure-html/unnamed-chunk-14-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Like one of my old coworkers used to say: &lt;em&gt;Purtier ’n a hog!&lt;/em&gt; Here we’ll summarize the results both in terms of their conventional power, their mean width, and the proportion of widths more narrow than .25. &lt;em&gt;Why .25?&lt;/em&gt; I don’t know. Without a substantively-informed alternative, it’s as good a criterion as any.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sim1 %&amp;gt;% 
  mutate(width = .upper - .lower) %&amp;gt;% 
  summarise(`conventional power` = mean(.upper &amp;lt; .5),
            `mean width`         = mean(width),
            `width below .25`    = mean(width &amp;lt; .25))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1 x 3
##   `conventional power` `mean width` `width below .25`
##                  &amp;lt;dbl&amp;gt;        &amp;lt;dbl&amp;gt;             &amp;lt;dbl&amp;gt;
## 1                 0.95        0.231               0.8&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Depending on your study needs, you’d adjust your sample size accordingly, do a mini simulation or two first, and then follow up with a proper power simulation with 1000+ iterations.&lt;/p&gt;
&lt;p&gt;I should point out that whereas in the last post we evaluated the power of the Poisson model with the parameters on the scale of the link function, here we evaluated the power for our logistic regression model after transforming the intercept back into the probability metric. Both methods are fine. I recommend you run your power simulation based on how you want to interpret and report your results.&lt;/p&gt;
&lt;p&gt;We should also acknowledge that this was our first example of a power simulation that wasn’t based on some group comparison. Comparing groups is fine and normal and important. And it’s also the case that we can care about power and/or parameter precision for more than group-based analyses. Our simulation-based approach is fine for both.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;aggregated-binomial-regression&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Aggregated binomial regression&lt;/h2&gt;
&lt;p&gt;It’s no more difficult to simulate and work with aggregated binomial data. But since the mechanics for &lt;code&gt;brms::brm()&lt;/code&gt; and thus the down-the-road simulation setup are a little different, we should practice. With our new setup, we’ll consider a new example. Since .25 is the typical batting average, it might better sense to define the null hypothesis like this:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[H_0 \text{: } p = .25.\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Consider a case where we had some intervention where we expected a new batting average of .35. How many trials would we need, then, to either reject &lt;span class=&#34;math inline&#34;&gt;\(H_0\)&lt;/span&gt; or perhaps estimate &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt; with a satisfactory degree of precision? Here’s what the statistical formula for the implied aggregated binomial model might look like:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{align*}
y_i                        &amp;amp; \sim \text{Binomial} (n, p_i) \\
\operatorname{logit} (p_i) &amp;amp; = \beta_0.
\end{align*}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The big change is we no longer defined &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; as 1. Let’s say we wanted our aggregated binomial data set to contain the summary statistics for &lt;span class=&#34;math inline&#34;&gt;\(n = 100\)&lt;/span&gt; trials. Here’s what that might look like.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;n_trials &amp;lt;- 100
prob_hit &amp;lt;- .35

set.seed(3)

d &amp;lt;- tibble(n_trials = n_trials,
            y = rbinom(n    = 1, 
                       size = n_trials, 
                       prob = prob_hit))

d&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1 x 2
##   n_trials     y
##      &amp;lt;dbl&amp;gt; &amp;lt;int&amp;gt;
## 1      100    32&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we have two columns. The first, &lt;code&gt;n_trials&lt;/code&gt;, indicates how many cases or trials we’re summarizing. The second, &lt;code&gt;y&lt;/code&gt;, indicates how many successes/1s/hits we might expect given &lt;span class=&#34;math inline&#34;&gt;\(p = .35\)&lt;/span&gt;. This is the aggregated binomial equivalent of if we had a 100 row vector composed of 32 1s and 68 0s.&lt;/p&gt;
&lt;p&gt;Now, before we discuss fitting the model with &lt;strong&gt;brms&lt;/strong&gt;, let’s talk priors. Since we’ve updated our definition of &lt;span class=&#34;math inline&#34;&gt;\(H_0\)&lt;/span&gt;, it might make sense to update the prior for &lt;span class=&#34;math inline&#34;&gt;\(\beta_0\)&lt;/span&gt;. As it turns out, setting that prior to &lt;code&gt;normal(-1, 0.5)&lt;/code&gt; puts the posterior mode at about .25 on the probability space, but with fairly wide 95% intervals ranging from about .12 to .5. Though centered on our updated null value, this prior is still quite permissive given our hypothesized &lt;span class=&#34;math inline&#34;&gt;\(p = .35\)&lt;/span&gt;. Let’s give it a whirl.&lt;/p&gt;
&lt;p&gt;To fit an aggregated binomial model with the &lt;code&gt;brm()&lt;/code&gt; function, we augment the &lt;code&gt;&amp;lt;criterion&amp;gt; | trials()&lt;/code&gt; syntax where the value that goes in &lt;code&gt;trials()&lt;/code&gt; is either a fixed number or variable in the data indexing &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt;. Our approach will be the latter.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fit2 &amp;lt;-
  brm(data = d, 
      family = binomial,
      y | trials(n_trials) ~ 1,
      prior(normal(-1, 0.5), class = Intercept),
      seed = 3)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Inspect the summary.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;print(fit2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  Family: binomial 
##   Links: mu = logit 
## Formula: y | trials(n_trials) ~ 1 
##    Data: d (Number of observations: 1) 
## Samples: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;
##          total post-warmup samples = 4000
## 
## Population-Level Effects: 
##           Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
## Intercept    -0.81      0.20    -1.19    -0.42 1.00     1398     1843
## 
## Samples were drawn using sampling(NUTS). For each parameter, Eff.Sample 
## is a crude measure of effective sample size, and Rhat is the potential 
## scale reduction factor on split chains (at convergence, Rhat = 1).&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After a transformation, here’s what that looks like in a plot.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;posterior_samples(fit2) %&amp;gt;% 
  transmute(p = inv_logit_scaled(b_Intercept)) %&amp;gt;% 
  
  ggplot(aes(x = p, y = 0)) +
  geom_halfeyeh(.width = c(.5, .95)) +
  scale_x_continuous(&amp;quot;probability of a hit&amp;quot;, limits = c(0, 1)) +
  scale_y_continuous(NULL, breaks = NULL)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-08-27-bayesian-power-analysis-part-iii-b_files/figure-html/unnamed-chunk-19-1.png&#34; width=&#34;384&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Based on a single simulation, it looks like &lt;span class=&#34;math inline&#34;&gt;\(n = 100\)&lt;/span&gt; won’t quite be enough to reject &lt;span class=&#34;math inline&#34;&gt;\(H_0 \text{: } p = .25\)&lt;/span&gt; with a conventional 2-sided 95% interval. But it does look like we’re in the ballpark and that our basic data + model setup will work for a larger-scale simulation. Here’s an example of how you might update our custom simulation function.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sim_data_fit &amp;lt;- function(seed, n_trials) {
  
  prob_hit &amp;lt;- .35
  
  set.seed(seed)
  
  d &amp;lt;- tibble(y = rbinom(n    = 1, 
                         size = n_trials, 
                         prob = prob_hit),
              n_trials = n_trials)
  
  update(fit2,
         newdata = d,
         seed = seed) %&amp;gt;% 
  posterior_samples() %&amp;gt;% 
  transmute(p = inv_logit_scaled(b_Intercept)) %&amp;gt;% 
  median_qi() %&amp;gt;% 
    select(.lower:.upper)
  
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Simulate, this time trying out &lt;span class=&#34;math inline&#34;&gt;\(n = 120\)&lt;/span&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sim2 &amp;lt;-
  tibble(seed = 1:100) %&amp;gt;% 
  mutate(ci = map(seed, sim_data_fit, n_trials = 120)) %&amp;gt;% 
  unnest()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Plot the intervals.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sim2 %&amp;gt;% 
  ggplot(aes(x = seed, ymin = .lower, ymax = .upper)) +
  geom_hline(yintercept = c(.25, .35), color = &amp;quot;white&amp;quot;) +
  geom_linerange() +
  xlab(&amp;quot;seed (i.e., simulation index)&amp;quot;) +
  scale_y_continuous(&amp;quot;probability of hitting the ball&amp;quot;,
                     limits = c(0, 1), breaks = c(0, .25, .35, 1))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-08-27-bayesian-power-analysis-part-iii-b_files/figure-html/unnamed-chunk-21-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Overall, those intervals look pretty good. They’re fairly narrow and are hovering around the data generating &lt;span class=&#34;math inline&#34;&gt;\(p = .35\)&lt;/span&gt;. But it seems many are still crossing the .25 threshold. Let’s see the results of a formal summary.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sim2 %&amp;gt;% 
  mutate(width = .upper - .lower) %&amp;gt;% 
  summarise(`conventional power` = mean(.lower &amp;gt; .25),
            `mean width`         = mean(width),
            `width below .2`     = mean(width &amp;lt; .2))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1 x 3
##   `conventional power` `mean width` `width below .2`
##                  &amp;lt;dbl&amp;gt;        &amp;lt;dbl&amp;gt;            &amp;lt;dbl&amp;gt;
## 1                 0.56        0.155                1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;All widths were narrower than .2 and the mean width was about .16. In the abstract that might seem reasonably precise. But we’re still not precise enough to reject &lt;span class=&#34;math inline&#34;&gt;\(H_0\)&lt;/span&gt; with a conventional power level. Depending on your needs, adjust the &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; accordingly and simulate again.&lt;/p&gt;
&lt;p&gt;Now you’ve got a sense of how to work with the binomial likelihood for (aggregated)binary data, next time we’ll play with Likert-type data.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;session-info&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Session info&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sessionInfo()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## R version 3.6.0 (2019-04-26)
## Platform: x86_64-apple-darwin15.6.0 (64-bit)
## Running under: macOS High Sierra 10.13.6
## 
## Matrix products: default
## BLAS:   /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRblas.0.dylib
## LAPACK: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRlapack.dylib
## 
## locale:
## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
##  [1] tidybayes_1.1.0 brms_2.10.0     Rcpp_1.0.2      forcats_0.4.0  
##  [5] stringr_1.4.0   dplyr_0.8.3     purrr_0.3.2     readr_1.3.1    
##  [9] tidyr_1.0.0     tibble_2.1.3    ggplot2_3.2.1   tidyverse_1.2.1
## 
## loaded via a namespace (and not attached):
##   [1] colorspace_1.4-1          ggridges_0.5.1           
##   [3] rsconnect_0.8.13          ggstance_0.3.2           
##   [5] markdown_1.0              base64enc_0.1-3          
##   [7] rstudioapi_0.10           rstan_2.19.2             
##   [9] svUnit_0.7-12             DT_0.7                   
##  [11] fansi_0.4.0               mvtnorm_1.0-11           
##  [13] lubridate_1.7.4           xml2_1.2.0               
##  [15] bridgesampling_0.6-0      knitr_1.23               
##  [17] shinythemes_1.1.2         zeallot_0.1.0            
##  [19] bayesplot_1.7.0           jsonlite_1.6             
##  [21] broom_0.5.2               shiny_1.3.2              
##  [23] compiler_3.6.0            httr_1.4.0               
##  [25] backports_1.1.4           assertthat_0.2.1         
##  [27] Matrix_1.2-17             lazyeval_0.2.2           
##  [29] cli_1.1.0                 later_0.8.0              
##  [31] htmltools_0.3.6           prettyunits_1.0.2        
##  [33] tools_3.6.0               igraph_1.2.4.1           
##  [35] coda_0.19-2               gtable_0.3.0             
##  [37] glue_1.3.1                reshape2_1.4.3           
##  [39] cellranger_1.1.0          vctrs_0.2.0              
##  [41] nlme_3.1-139              blogdown_0.14            
##  [43] crosstalk_1.0.0           xfun_0.8                 
##  [45] ps_1.3.0                  rvest_0.3.4              
##  [47] mime_0.7                  miniUI_0.1.1.1           
##  [49] lifecycle_0.1.0           gtools_3.8.1             
##  [51] zoo_1.8-6                 scales_1.0.0             
##  [53] colourpicker_1.0          hms_0.4.2                
##  [55] promises_1.0.1            Brobdingnag_1.2-6        
##  [57] parallel_3.6.0            inline_0.3.15            
##  [59] shinystan_2.5.0           yaml_2.2.0               
##  [61] gridExtra_2.3             loo_2.1.0                
##  [63] StanHeaders_2.18.1-10     stringi_1.4.3            
##  [65] dygraphs_1.1.1.6          pkgbuild_1.0.3           
##  [67] rlang_0.4.0               pkgconfig_2.0.2          
##  [69] matrixStats_0.54.0        evaluate_0.14            
##  [71] lattice_0.20-38           rstantools_1.5.1         
##  [73] htmlwidgets_1.3           labeling_0.3             
##  [75] tidyselect_0.2.5          processx_3.3.1           
##  [77] plyr_1.8.4                magrittr_1.5             
##  [79] bookdown_0.12             R6_2.4.0                 
##  [81] generics_0.0.2            pillar_1.4.2             
##  [83] haven_2.1.0               withr_2.1.2              
##  [85] xts_0.11-2                abind_1.4-5              
##  [87] modelr_0.1.4              crayon_1.3.4             
##  [89] arrayhelpers_1.0-20160527 utf8_1.1.4               
##  [91] rmarkdown_1.13            grid_3.6.0               
##  [93] readxl_1.3.1              callr_3.2.0              
##  [95] threejs_0.3.1             digest_0.6.20            
##  [97] xtable_1.8-4              httpuv_1.5.1             
##  [99] stats4_3.6.0              munsell_0.5.0            
## [101] shinyjs_1.0&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;footnote&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Footnote&lt;/h2&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;In case this is all new to you and you and you had the question in your mind: Yes, you can add predictors to the logistic regression model. Say we had a model with two predictors, &lt;span class=&#34;math inline&#34;&gt;\(x_1\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(x_2\)&lt;/span&gt;. Our statistical model would then follow the form &lt;span class=&#34;math inline&#34;&gt;\(\operatorname{logit} (p_i) = \beta_0 + \beta_1 x_{1i} + \beta_2 x_{2i}\)&lt;/span&gt;.&lt;a href=&#34;#fnref1&#34; class=&#34;footnote-back&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Bayesian power analysis: Part III.a. Counts are special.</title>
      <link>/post/bayesian-power-analysis-part-iii-a/</link>
      <pubDate>Sun, 11 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/bayesian-power-analysis-part-iii-a/</guid>
      <description>&lt;div id=&#34;version-1.0.0&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Version 1.0.0&lt;/h2&gt;
&lt;/div&gt;
&lt;div id=&#34;tldr&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;tl;dr&lt;/h2&gt;
&lt;p&gt;So far we’ve covered Bayesian power simulations from both a null hypothesis orientation (see &lt;a href=&#34;https://solomonkurz.netlify.com/post/bayesian-power-analysis-part-i/&#34;&gt;part I&lt;/a&gt;) and a parameter width perspective (see &lt;a href=&#34;https://solomonkurz.netlify.com/post/bayesian-power-analysis-part-ii/&#34;&gt;part II&lt;/a&gt;). In both instances, we kept things simple and stayed with Gaussian (i.e., normally distributed) data. But not all data follow that form, so it might do us well to expand our skill set a bit. In the next few posts, we’ll cover how we might perform power simulations with other kinds of data. In this post, we’ll focus on how to use the Poisson likelihood to model counts. In follow-up posts, we’ll explore how to model binary and Likert-type data.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;the-poisson-distribution-is-handy-for-counts.&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;The Poisson distribution is handy for counts.&lt;/h2&gt;
&lt;p&gt;In the social sciences, count data arise when we ask questions like:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;How many sexual partners have you had?&lt;/li&gt;
&lt;li&gt;How many pets do you have at home?&lt;/li&gt;
&lt;li&gt;How many cigarettes did you smoke, yesterday?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The values these data will take are discrete &lt;a href=&#34;#fn1&#34; class=&#34;footnote-ref&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; in that you’ve either slept with 9 or 10 people, but definitely not 9.5. The values cannot go below zero in that even if you quit smoking cold turkey 15 years ago and have been a health nut since, you still could not have smoked -3 cigarettes, yesterday. Zero is as low as it goes.&lt;/p&gt;
&lt;p&gt;The canonical distribution for data of this type–non-zero integers–is the Poisson. It’s named after the French mathematician Siméon Denis Poisson, &lt;a href=&#34;https://upload.wikimedia.org/wikipedia/commons/e/e8/E._Marcellot_Siméon-Denis_Poisson_1804.jpg&#34;&gt;who had quite the confident stare in his youth&lt;/a&gt;. The Poisson distribution has one parameter, &lt;span class=&#34;math inline&#34;&gt;\(\lambda\)&lt;/span&gt;, which controls both its mean and variance. Although the numbers the Poisson describes are counts, the &lt;span class=&#34;math inline&#34;&gt;\(\lambda\)&lt;/span&gt; parameter does not need to be an integer. For example, here’s the plot of 1000 draws from a Poisson for which &lt;span class=&#34;math inline&#34;&gt;\(\lambda = 3.2\)&lt;/span&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidyverse)

theme_set(theme_gray() + theme(panel.grid = element_blank()))

tibble(x = rpois(n = 1e3, lambda = 3.2)) %&amp;gt;% 
  mutate(x = factor(x)) %&amp;gt;% 
  
  ggplot(aes(x = x)) +
  geom_bar()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-08-11-bayesian-power-analysis-part-iii-a_files/figure-html/unnamed-chunk-1-1.png&#34; width=&#34;384&#34; /&gt;&lt;/p&gt;
&lt;p&gt;In case you missed it, the key function for generating those data was &lt;code&gt;rpois()&lt;/code&gt;. I’m not going to go into a full-blown tutorial on the Poisson distribution or on count regression. For more thorough introductions, check out Atkins et al’s &lt;a href=&#34;https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3513584/pdf/nihms396181.pdf&#34;&gt;&lt;em&gt;A tutorial on count regression and zero-altered count models for longitudinal substance use data&lt;/em&gt;&lt;/a&gt;, chapters 9 through 11 in McElreath’s &lt;a href=&#34;https://xcelab.net/rm/statistical-rethinking/&#34;&gt;&lt;em&gt;Statistical Rethinking&lt;/em&gt;&lt;/a&gt;, or, if you really want to dive in, Agresti’s &lt;a href=&#34;https://www.wiley.com/en-us/Foundations+of+Linear+and+Generalized+Linear+Models-p-9781118730034&#34;&gt;&lt;em&gt;Foundations of Linear and Generalized Linear Models&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;For our power example, let’s say you were interested in drinking. Using data from &lt;a href=&#34;https://pubs.niaaa.nih.gov/publications/AA70/AA70.htm&#34;&gt;the National Epidemiologic Survey on Alcohol and Related Conditions&lt;/a&gt;, Christopher Ingraham presented &lt;a href=&#34;https://www.washingtonpost.com/news/wonk/wp/2014/09/25/think-you-drink-a-lot-this-chart-will-tell-you/?utm_term=.b81599bbbe25&#34;&gt;a data visualization&lt;/a&gt; of the average number of alcoholic drinks American adults consume, per week. By decile, the numbers were:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;0.00&lt;/li&gt;
&lt;li&gt;0.00&lt;/li&gt;
&lt;li&gt;0.00&lt;/li&gt;
&lt;li&gt;0.02&lt;/li&gt;
&lt;li&gt;0.14&lt;/li&gt;
&lt;li&gt;0.63&lt;/li&gt;
&lt;li&gt;2.17&lt;/li&gt;
&lt;li&gt;6.25&lt;/li&gt;
&lt;li&gt;15.28&lt;/li&gt;
&lt;li&gt;73.85&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Let’s say you wanted to run a study where you planned on comparing two demographic groups by their weekly drinking levels. Let’s further say you suspected one of those groups drank like the American adults in the 7&lt;sup&gt;th&lt;/sup&gt; decile and the other drank like American adults in the 8&lt;sup&gt;th&lt;/sup&gt;. We’ll call them low and high drinkers, respectively. For convenience, let’s further presume you’ll be able to recruit equal numbers of participants from both groups. The objective for our power analysis–or sample size analysis if you prefer to avoid the language of &lt;em&gt;power&lt;/em&gt;–is to determine how many you’d need per group to detect reliable differences. Using &lt;span class=&#34;math inline&#34;&gt;\(n = 50\)&lt;/span&gt; as a starting point, here’s what the data for our hypothetical groups might look like.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mu_7 &amp;lt;- 2.17
mu_8 &amp;lt;- 6.25

n &amp;lt;- 50

set.seed(3)

d &amp;lt;-
  tibble(low  = rpois(n = n, lambda = mu_7),
         high = rpois(n = n, lambda = mu_8)) %&amp;gt;% 
  gather(group, count) 

d %&amp;gt;%
  mutate(count = factor(count)) %&amp;gt;% 
  
  ggplot(aes(x = count)) +
  geom_bar() +
  facet_wrap(~group, ncol = 1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-08-11-bayesian-power-analysis-part-iii-a_files/figure-html/unnamed-chunk-2-1.png&#34; width=&#34;384&#34; /&gt;&lt;/p&gt;
&lt;p&gt;This will be our primary data type. Our next step is to determine how to express our research question as a regression model. Like with our two-group Gaussian models, we can predict counts in terms of an intercept (i.e., standing for the expected value on the reference group) and slope (i.e., standing for the expected difference between the reference group and the comparison group). If we coded our two groups by a &lt;code&gt;high&lt;/code&gt; variable for which 0 stood for low drinkers and 1 stood for high drinkers, the basic model would follow the form&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{align*}
\text{drinks_per_week}_i         &amp;amp; \sim \text{Poisson}(\lambda_i) \\
\operatorname{log} (\lambda_i)   &amp;amp; = \beta_0 + \beta_1 \text{high}_i.
\end{align*}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Here’s how to set the data up for that model.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;d &amp;lt;-
  d %&amp;gt;% 
  mutate(high = ifelse(group == &amp;quot;low&amp;quot;, 0, 1))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you were attending closely to our model formula, you noticed we ran into a detail. Count regression, such as with the Poisson likelihood, tends to use the log link. &lt;em&gt;Why?&lt;/em&gt; you ask. Recall that counts need to be 0 and above. Same deal for our &lt;span class=&#34;math inline&#34;&gt;\(\lambda\)&lt;/span&gt; parameter. In order to make sure our models don’t yield silly estimates for &lt;span class=&#34;math inline&#34;&gt;\(\lambda\)&lt;/span&gt;, like -2 or something, we typically use the log link. You don’t have to, of course. The world is your playground. But this is the method most of your colleagues are likely to use and it’s the one I suggest you use until you have compelling reasons to do otherwise.&lt;/p&gt;
&lt;p&gt;So then since we’re now fitting a model with a log link, it might seem challenging to pick good priors. As a place to start, we can use the &lt;code&gt;brms::get_prior()&lt;/code&gt; function to see the &lt;strong&gt;brms&lt;/strong&gt; defaults.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(brms)

get_prior(data = d,
          family = poisson,
          count ~ 0 + intercept + high)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   prior class      coef group resp dpar nlpar bound
## 1           b                                      
## 2           b      high                            
## 3           b intercept&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Hopefully two things popped out. First, there’s no prior of &lt;code&gt;class = sigma&lt;/code&gt;. Since the Poisson distribution only has one parameter &lt;span class=&#34;math inline&#34;&gt;\(\lambda\)&lt;/span&gt;, we don’t need to set a prior for &lt;span class=&#34;math inline&#34;&gt;\(\sigma\)&lt;/span&gt;. Our model won’t have one. Second, because we’re continuing to use the &lt;code&gt;0 + intercept&lt;/code&gt; syntax for our model intercept, both our intercept and slope are of prior &lt;code&gt;class = b&lt;/code&gt; and those currently have default flat priors with &lt;strong&gt;brms&lt;/strong&gt;. To be sure, flat priors aren’t the best. But maybe if this was your first time playing around with a Poisson model, default flat priors might seem like a safe place to start. &lt;a href=&#34;https://xkcd.com/386/&#34;&gt;Feel free to disagree&lt;/a&gt;. In the meantime, here’s how to fit that default Poisson model with &lt;code&gt;brms::brm()&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fit1 &amp;lt;-
  brm(data = d,
      family = poisson,
      count ~ 0 + intercept + high,
      seed = 3)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;print(fit1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  Family: poisson 
##   Links: mu = log 
## Formula: count ~ 0 + intercept + high 
##    Data: d (Number of observations: 100) 
## Samples: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;
##          total post-warmup samples = 4000
## 
## Population-Level Effects: 
##           Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
## intercept     0.59      0.11     0.37     0.81 1.00      988     1225
## high          1.27      0.12     1.02     1.50 1.00     1005     1078
## 
## Samples were drawn using sampling(NUTS). For each parameter, Eff.Sample 
## is a crude measure of effective sample size, and Rhat is the potential 
## scale reduction factor on split chains (at convergence, Rhat = 1).&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since we used the log link, our model results are in the log metric, too. If you’d like them in the metric of the data, you’d work directly with the poster samples and exponentiate.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;post &amp;lt;- 
  posterior_samples(fit1) %&amp;gt;% 
  mutate(`beta_0 (i.e., low)`                       = exp(b_intercept),
         `beta_1 (i.e., difference score for high)` = exp(b_high))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can then just summarize our parameters of interest.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;post %&amp;gt;% 
  select(starts_with(&amp;quot;beta_&amp;quot;)) %&amp;gt;% 
  gather() %&amp;gt;% 
  group_by(key) %&amp;gt;% 
  summarise(mean  = mean(value),
            lower = quantile(value, prob = .025),
            upper = quantile(value, prob = .975))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 2 x 4
##   key                                       mean lower upper
##   &amp;lt;chr&amp;gt;                                    &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
## 1 beta_0 (i.e., low)                        1.81  1.45  2.24
## 2 beta_1 (i.e., difference score for high)  3.58  2.78  4.50&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For the sake of simulation, it’ll be easier if we press on with evaluating the parameters on the log metric, though. If you’re working within a null-hypothesis oriented power paradigm, you’ll be happy to know zero is still the number to beat for evaluating our 95% intervals for &lt;span class=&#34;math inline&#34;&gt;\(\beta_1\)&lt;/span&gt;, even when that parameter is in the log metric. Here it is, again.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(broom)

tidy(fit1, prob = .95) %&amp;gt;% 
  filter(term == &amp;quot;b_high&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     term estimate std.error   lower    upper
## 1 b_high 1.266527 0.1232635 1.02143 1.504801&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So our first fit suggests we’re on good footing to run a quick power simulation holding &lt;span class=&#34;math inline&#34;&gt;\(n = 50\)&lt;/span&gt;. As in the prior blog posts, our lives will be simpler if we set up a custom simulation function. Since we’ll be using it to simulate the data and fit the model in one step, let’s call it &lt;code&gt;sim_data_fit()&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sim_data_fit &amp;lt;- function(seed, n) {
  
  # define our mus in the function
  mu_7 &amp;lt;- 2.17
  mu_8 &amp;lt;- 6.25

  # make your results reproducible
  set.seed(seed)
  
  # simulate the data
  d &amp;lt;-
    tibble(high  = rep(0:1, each = n),
           count = c(rpois(n = n, lambda = mu_7),
                     rpois(n = n, lambda = mu_8)))
  
  # fit and summarise
  update(fit1,
         newdata = d,
         seed = seed) %&amp;gt;% 
  tidy(prob = .95) %&amp;gt;% 
  filter(term == &amp;quot;b_high&amp;quot;) %&amp;gt;% 
  select(lower:upper)
  
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here’s the simulation for a simple 100 iterations.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sim1 &amp;lt;-
  tibble(seed = 1:100) %&amp;gt;% 
  mutate(ci = map(seed, sim_data_fit, n = 50)) %&amp;gt;% 
  unnest()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That went quick–less than 3 minutes on my old laptop. Here’s what those 100 &lt;span class=&#34;math inline&#34;&gt;\(\beta_1\)&lt;/span&gt; intervals look like in bulk.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sim1 %&amp;gt;% 
  
  ggplot(aes(x = seed, ymin = lower, ymax = upper)) +
  geom_hline(yintercept = 0, color = &amp;quot;white&amp;quot;) +
  geom_linerange() +
  labs(x = &amp;quot;seed (i.e., simulation index)&amp;quot;,
       y = expression(beta[1]))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-08-11-bayesian-power-analysis-part-iii-a_files/figure-html/unnamed-chunk-10-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;p&gt;None of them are anywhere near the null value 0. So it appears we’re well above .8 power to reject the typical &lt;span class=&#34;math inline&#34;&gt;\(H_0\)&lt;/span&gt; with &lt;span class=&#34;math inline&#34;&gt;\(n = 50\)&lt;/span&gt;. Switching to the precision orientation, here’s the distribution of their widths.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sim1 %&amp;gt;% 
  mutate(width = upper - lower) %&amp;gt;% 
  
  ggplot(aes(x = width)) +
  geom_histogram(binwidth = 0.01)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-08-11-bayesian-power-analysis-part-iii-a_files/figure-html/unnamed-chunk-11-1.png&#34; width=&#34;384&#34; /&gt;&lt;/p&gt;
&lt;p&gt;What if we wanted a mean width of 0.25 on the log scale? We might try the simulation with &lt;span class=&#34;math inline&#34;&gt;\(n = 150\)&lt;/span&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sim2 &amp;lt;-
  tibble(seed = 1:100) %&amp;gt;% 
  mutate(ci = map(seed, sim_data_fit, n = 150)) %&amp;gt;% 
  unnest()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here we’ll summarize the widths both in terms of their mean and what proportion were smaller than 0.25.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sim2 %&amp;gt;% 
  mutate(width = upper - lower) %&amp;gt;% 
  summarise(`mean width` = mean(width),
            `below 0.25` = mean(width &amp;lt; 0.25))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1 x 2
##   `mean width` `below 0.25`
##          &amp;lt;dbl&amp;gt;        &amp;lt;dbl&amp;gt;
## 1        0.253          0.4&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we wanted to focus on the mean, we did pretty good. Perhaps set the &lt;span class=&#34;math inline&#34;&gt;\(n = 155\)&lt;/span&gt; and simulate a full 1000+ iterations for a serious power analysis. But if we wanted to make the stricter criteria of all below 0.25, we’d need to up the &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; quite a bit more. And of course, once you have a little experience working with Poisson models, you might do the power simulations with more ambitious priors. For example, if your count values are lower than like 1000, there’s a good chance a &lt;code&gt;normal(0, 6)&lt;/code&gt; prior on your &lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt; parameters will be nearly flat within the reasonable neighborhoods of the parameter space.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;but-logs-are-hard.&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;But logs are hard.&lt;/h2&gt;
&lt;p&gt;If we approach our Bayesian power analysis from a precision perspective, it can be difficult to settle on a reasonable interval width when they’re on the log scale. So let’s modify our simulation flow so it converts the width summaries back into the natural metric. Before we go big, let’s practice with a single iteration.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;seed &amp;lt;- 0
set.seed(seed)

# simulate the data
d &amp;lt;-
  tibble(high  = rep(0:1, each = n),
         count = c(rpois(n = n, lambda = mu_7),
                   rpois(n = n, lambda = mu_8)))

# fit the model
fit2 &amp;lt;-
  update(fit1,
       newdata = d,
       seed = seed) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now summarize.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidybayes)

fit2 %&amp;gt;% 
  posterior_samples() %&amp;gt;% 
  transmute(`beta_1` = exp(b_high)) %&amp;gt;% 
  mean_qi()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1 x 6
##   beta_1 .lower .upper .width .point .interval
##    &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;  &amp;lt;chr&amp;gt;    
## 1   2.69   2.16   3.32   0.95 mean   qi&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Before we used the handy &lt;code&gt;broom::tidy()&lt;/code&gt; function to extract our intervals, which took the brms fit object as input. Here we took a different approach. Because we are transforming &lt;span class=&#34;math inline&#34;&gt;\(\beta_1\)&lt;/span&gt;, we used the &lt;code&gt;posterior_samples()&lt;/code&gt; function to work directly with the posterior draws. We then exponentiated within &lt;code&gt;transmute()&lt;/code&gt;, which returned a single-column tibble, not a brms fit object. So instead of &lt;code&gt;broom::tidy()&lt;/code&gt;, it’s easier to get our summary statistics with the &lt;code&gt;tidybayes::mean_qi()&lt;/code&gt; function. Do note that now our lower and upper levels are named &lt;code&gt;.lower&lt;/code&gt; and &lt;code&gt;.upper&lt;/code&gt;, respectively (i.e., they now have a &lt;code&gt;.&lt;/code&gt; prefix).&lt;/p&gt;
&lt;p&gt;Now we’ve practiced with the new flow, let’s redefine our simulation function.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sim_data_fit &amp;lt;- function(seed, n) {
  
  # define our mus in the function
  mu_7 &amp;lt;- 2.17
  mu_8 &amp;lt;- 6.25

  # make your results reproducible
  set.seed(seed)
  
  # simulate the data
  d &amp;lt;-
    tibble(high  = rep(0:1, each = n),
           count = c(rpois(n = n, lambda = mu_7),
                     rpois(n = n, lambda = mu_8)))
  
  # fit and summarize
  update(fit1,
         newdata = d,
         seed = seed) %&amp;gt;% 
  posterior_samples() %&amp;gt;% 
  transmute(`beta_1` = exp(b_high)) %&amp;gt;% 
  mean_qi()
  
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Simulate.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sim3 &amp;lt;-
  tibble(seed = 1:100) %&amp;gt;% 
  mutate(ci = map(seed, sim_data_fit, n = 50)) %&amp;gt;% 
  unnest()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here’s what those 100 &lt;span class=&#34;math inline&#34;&gt;\(\beta_1\)&lt;/span&gt; intervals look like in bulk.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sim3 %&amp;gt;% 
  ggplot(aes(x = seed, y = beta_1, ymin = .lower, ymax = .upper)) +
  geom_hline(yintercept = 0, color = &amp;quot;white&amp;quot;) +
  geom_pointrange(fatten = 1) +
  labs(x = &amp;quot;seed (i.e., simulation index)&amp;quot;,
       y = expression(beta[1]))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-08-11-bayesian-power-analysis-part-iii-a_files/figure-html/unnamed-chunk-17-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Inspect the distribution of their widths.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sim3 %&amp;gt;% 
  mutate(width = .upper - .lower) %&amp;gt;% 
  
  ggplot(aes(x = width)) +
  geom_histogram(binwidth = 0.05)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-08-11-bayesian-power-analysis-part-iii-a_files/figure-html/unnamed-chunk-18-1.png&#34; width=&#34;384&#34; /&gt;&lt;/p&gt;
&lt;p&gt;What if we wanted a mean 95% interval width of 1? Let’s run the simulation again, this time with &lt;span class=&#34;math inline&#34;&gt;\(n = 100\)&lt;/span&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sim4 &amp;lt;-
  tibble(seed = 1:100) %&amp;gt;% 
  mutate(ci = map(seed, sim_data_fit, n = 100)) %&amp;gt;% 
  unnest() %&amp;gt;% 
  mutate(width = .upper - .lower)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here’s the new width distribution.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sim4 %&amp;gt;% 
  ggplot(aes(x = width)) +
  geom_histogram(binwidth = 0.05)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-08-11-bayesian-power-analysis-part-iii-a_files/figure-html/unnamed-chunk-19-1.png&#34; width=&#34;384&#34; /&gt;&lt;/p&gt;
&lt;p&gt;And the mean width is:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sim4 %&amp;gt;% 
  summarise(mean_width = mean(width))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1 x 1
##   mean_width
##        &amp;lt;dbl&amp;gt;
## 1      0.912&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nice! If we want a mean width of 1, it looks like we’re a little &lt;em&gt;overpowered&lt;/em&gt; with &lt;span class=&#34;math inline&#34;&gt;\(n = 100\)&lt;/span&gt;. The next step would be to up your iterations to 1000 or so to do a proper simulation.&lt;/p&gt;
&lt;p&gt;Now you’ve got a sense of how to work with the Poisson likelihood, next time we’ll play with binary data.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;session-info&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Session info&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sessionInfo()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## R version 3.6.0 (2019-04-26)
## Platform: x86_64-apple-darwin15.6.0 (64-bit)
## Running under: macOS High Sierra 10.13.6
## 
## Matrix products: default
## BLAS:   /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRblas.0.dylib
## LAPACK: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRlapack.dylib
## 
## locale:
## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
##  [1] tidybayes_1.1.0 broom_0.5.2     brms_2.10.0     Rcpp_1.0.2     
##  [5] forcats_0.4.0   stringr_1.4.0   dplyr_0.8.3     purrr_0.3.2    
##  [9] readr_1.3.1     tidyr_1.0.0     tibble_2.1.3    ggplot2_3.2.1  
## [13] tidyverse_1.2.1
## 
## loaded via a namespace (and not attached):
##   [1] colorspace_1.4-1          ellipsis_0.2.0.1         
##   [3] ggridges_0.5.1            rsconnect_0.8.13         
##   [5] ggstance_0.3.2            markdown_1.0             
##   [7] base64enc_0.1-3           rstudioapi_0.10          
##   [9] rstan_2.19.2              svUnit_0.7-12            
##  [11] DT_0.7                    fansi_0.4.0              
##  [13] mvtnorm_1.0-11            lubridate_1.7.4          
##  [15] xml2_1.2.0                bridgesampling_0.6-0     
##  [17] codetools_0.2-16          knitr_1.23               
##  [19] shinythemes_1.1.2         zeallot_0.1.0            
##  [21] bayesplot_1.7.0           jsonlite_1.6             
##  [23] shiny_1.3.2               compiler_3.6.0           
##  [25] httr_1.4.0                backports_1.1.4          
##  [27] assertthat_0.2.1          Matrix_1.2-17            
##  [29] lazyeval_0.2.2            cli_1.1.0                
##  [31] later_0.8.0               htmltools_0.3.6          
##  [33] prettyunits_1.0.2         tools_3.6.0              
##  [35] igraph_1.2.4.1            coda_0.19-2              
##  [37] gtable_0.3.0              glue_1.3.1               
##  [39] reshape2_1.4.3            cellranger_1.1.0         
##  [41] vctrs_0.2.0               nlme_3.1-139             
##  [43] blogdown_0.14             crosstalk_1.0.0          
##  [45] xfun_0.8                  ps_1.3.0                 
##  [47] rvest_0.3.4               mime_0.7                 
##  [49] miniUI_0.1.1.1            lifecycle_0.1.0          
##  [51] gtools_3.8.1              zoo_1.8-6                
##  [53] scales_1.0.0              colourpicker_1.0         
##  [55] hms_0.4.2                 promises_1.0.1           
##  [57] Brobdingnag_1.2-6         parallel_3.6.0           
##  [59] inline_0.3.15             shinystan_2.5.0          
##  [61] yaml_2.2.0                gridExtra_2.3            
##  [63] loo_2.1.0                 StanHeaders_2.18.1-10    
##  [65] stringi_1.4.3             dygraphs_1.1.1.6         
##  [67] pkgbuild_1.0.3            rlang_0.4.0              
##  [69] pkgconfig_2.0.2           matrixStats_0.54.0       
##  [71] evaluate_0.14             lattice_0.20-38          
##  [73] rstantools_1.5.1          htmlwidgets_1.3          
##  [75] labeling_0.3              tidyselect_0.2.5         
##  [77] processx_3.3.1            plyr_1.8.4               
##  [79] magrittr_1.5              bookdown_0.12            
##  [81] R6_2.4.0                  generics_0.0.2           
##  [83] pillar_1.4.2              haven_2.1.0              
##  [85] withr_2.1.2               xts_0.11-2               
##  [87] abind_1.4-5               modelr_0.1.4             
##  [89] crayon_1.3.4              arrayhelpers_1.0-20160527
##  [91] utf8_1.1.4                rmarkdown_1.13           
##  [93] grid_3.6.0                readxl_1.3.1             
##  [95] callr_3.2.0               threejs_0.3.1            
##  [97] digest_0.6.20             xtable_1.8-4             
##  [99] httpuv_1.5.1              stats4_3.6.0             
## [101] munsell_0.5.0             shinyjs_1.0&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;footnote&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Footnote&lt;/h2&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;Yes, one can smoke half a cigarette or drink 1/3 of a drink. Ideally, we’d have the exact amount of nicotine in your blood at a given moment and over time and the same for the amount of alcohol in your system relative to your blood volume and such. But in practice, substance use researchers just don’t tend to have access to data of that quality. Instead, we’re typically stuck with simple counts. And I look forward to the day the right team of engineers, computer scientists, and substance use researchers (and whoever else I forgot to mention) release the cheap, non-invasive technology we need to passively measure these things. Until then: &lt;em&gt;How many standard servings of alcohol did you drink, last night?&lt;/em&gt;&lt;a href=&#34;#fnref1&#34; class=&#34;footnote-back&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Bayesian power analysis: Part II. Some might prefer precision to power</title>
      <link>/post/bayesian-power-analysis-part-ii/</link>
      <pubDate>Wed, 24 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/bayesian-power-analysis-part-ii/</guid>
      <description>&lt;div id=&#34;version-1.0.0&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Version 1.0.0&lt;/h2&gt;
&lt;/div&gt;
&lt;div id=&#34;tldr&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;tl;dr&lt;/h2&gt;
&lt;p&gt;When researchers decide on a sample size for an upcoming project, there are more things to consider than null-hypothesis-oriented power. Bayesian researchers might like to frame their concerns in terms of precision. Stick around to learn what and how.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;are-bayesians-doomed-to-refer-to-h_0-1-with-sample-size-planning&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Are Bayesians doomed to refer to &lt;span class=&#34;math inline&#34;&gt;\(H_0\)&lt;/span&gt; &lt;a href=&#34;#fn1&#34; class=&#34;footnote-ref&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; with sample-size planning?&lt;/h2&gt;
&lt;p&gt;If you read my last post, you may have found yourself thinking: &lt;em&gt;Sure, last time you avoided computing &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt;-values with your 95% Bayesian credible intervals. But weren’t you still operating like a NHSTesting frequentist with all that &lt;span class=&#34;math inline&#34;&gt;\(H_0 / H_1\)&lt;/span&gt; talk?&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Solid criticism. We didn’t even bother discussing all the type-I versus type-II error details. Yet they too were lurking in the background the way we just chose the typical .8 power benchmark. That’s not to say the null-hypothesis-oriented approach isn’t legitimate. It’s certainly congruent with what most reviewers would expect. But this all seems at odds with a model-oriented Bayesian approach, which is what I generally prefer. Happily, we have other options to explore.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;lets-just-pick-up-where-we-left-off.&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Let’s just pick up where we left off.&lt;/h2&gt;
&lt;p&gt;Load our primary statistical packages.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidyverse)
library(brms)
library(broom)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As a recap, here’s how we performed the last simulation-based Bayesian power analysis from part I. First, we simulated a single data set and fit an initial model.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# define the means
mu_c &amp;lt;- 0
mu_t &amp;lt;- 0.5

# determine the group size
n &amp;lt;- 50

# simulate the data
set.seed(1)
d &amp;lt;-
  tibble(group     = rep(c(&amp;quot;control&amp;quot;, &amp;quot;treatment&amp;quot;), each = n)) %&amp;gt;% 
  mutate(treatment = ifelse(group == &amp;quot;control&amp;quot;, 0, 1),
         y         = ifelse(group == &amp;quot;control&amp;quot;, 
                            rnorm(n, mean = mu_c, sd = 1),
                            rnorm(n, mean = mu_t, sd = 1)))
# fit the model
fit &amp;lt;-
  brm(data = d,
      family = gaussian,
      y ~ 0 + intercept + treatment,
      prior = c(prior(normal(0, 2), class = b),
                prior(student_t(3, 1, 1), class = sigma)),
      seed = 1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next, we made a custom function that both simulated data sets and used the &lt;code&gt;update()&lt;/code&gt; function to update that initial fit in order to avoid additional compilation time.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sim_d_and_fit &amp;lt;- function(seed, n) {
  
  mu_c &amp;lt;- 0
  mu_t &amp;lt;- 0.5
  
  set.seed(seed)
  
  d &amp;lt;-
    tibble(group     = rep(c(&amp;quot;control&amp;quot;, &amp;quot;treatment&amp;quot;), each = n)) %&amp;gt;% 
    mutate(treatment = ifelse(group == &amp;quot;control&amp;quot;, 0, 1),
           y         = ifelse(group == &amp;quot;control&amp;quot;, 
                              rnorm(n, mean = mu_c, sd = 1),
                              rnorm(n, mean = mu_t, sd = 1)))
  
  update(fit,
         newdata = d, 
         seed = seed) %&amp;gt;% 
    tidy(prob = .95) %&amp;gt;% 
    filter(term == &amp;quot;b_treatment&amp;quot;)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then we finally iterated over &lt;code&gt;n_sim &amp;lt;- 100&lt;/code&gt; times.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;n_sim &amp;lt;- 100

s3 &amp;lt;-
  tibble(seed = 1:n_sim) %&amp;gt;% 
  mutate(tidy = map(seed, sim_d_and_fit, n = 50)) %&amp;gt;% 
  unnest(tidy)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The results looked like so:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;theme_set(theme_grey() +
            theme(panel.grid = element_blank()))

s3 %&amp;gt;% 
  ggplot(aes(x = seed, y = estimate, ymin = lower, ymax = upper)) +
  geom_hline(yintercept = c(0, .5), color = &amp;quot;white&amp;quot;) +
  geom_pointrange(fatten = 1/2) +
  labs(x = &amp;quot;seed (i.e., simulation index)&amp;quot;,
       y = expression(beta[1]))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-07-24-bayesian-power-analysis-part-ii_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;p&gt;It’s time to build on the foundation.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;we-might-evaluate-power-by-widths.&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;We might evaluate “power” by widths.&lt;/h2&gt;
&lt;p&gt;Instead of just ordering the point-ranges by their &lt;code&gt;seed&lt;/code&gt; values, we might instead arrange them by the &lt;code&gt;lower&lt;/code&gt; levels.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;s3 %&amp;gt;%
  ggplot(aes(x = reorder(seed, lower), y = estimate, ymin = lower, ymax = upper)) +
  geom_hline(yintercept = c(0, .5), color = &amp;quot;white&amp;quot;) +
  geom_pointrange(fatten = 1/2) +
  scale_x_discrete(&amp;quot;reordered by the lower level of the 95% intervals&amp;quot;, breaks = NULL) +
  ylab(expression(beta[1])) +
  coord_cartesian(ylim = c(-.5, 1.3))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-07-24-bayesian-power-analysis-part-ii_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Notice how this arrangement highlights the differences in widths among the intervals. The wider the interval, the less precise the estimate. Some intervals were wider than others, but all tended to hover in a similar range. We might quantify those ranges by computing a &lt;code&gt;width&lt;/code&gt; variable.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;s3 &amp;lt;-
  s3 %&amp;gt;% 
  mutate(width = upper - lower)

head(s3)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 7
##    seed term        estimate std.error   lower upper width
##   &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt;          &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
## 1     1 b_treatment    0.518     0.184  0.159  0.892 0.733
## 2     2 b_treatment    0.297     0.237 -0.176  0.765 0.941
## 3     3 b_treatment    0.641     0.178  0.296  0.982 0.686
## 4     4 b_treatment    0.224     0.178 -0.124  0.582 0.706
## 5     5 b_treatment    0.436     0.190  0.0560 0.796 0.740
## 6     6 b_treatment    0.300     0.206 -0.106  0.694 0.799&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here’s the &lt;code&gt;width&lt;/code&gt; distribution.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;s3 %&amp;gt;% 
  ggplot(aes(x = width)) +
  geom_histogram(binwidth = .01)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-07-24-bayesian-power-analysis-part-ii_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;384&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The widths of our 95% intervals range from 0.6 to 0.95, with the bulk sitting around 0.8. Let’s focus a bit and take a random sample from one of the simulation iterations.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(1)

s3 %&amp;gt;% 
  sample_n(1) %&amp;gt;% 
  mutate(seed = seed %&amp;gt;% as.character()) %&amp;gt;% 

  ggplot(aes(x = seed, y = estimate, ymin = lower, ymax = upper)) +
  geom_hline(yintercept = c(0, .5), color = &amp;quot;white&amp;quot;) +
  geom_pointrange() +
  coord_flip() +
  labs(x = &amp;quot;seed #&amp;quot;,
       y = expression(beta[1]))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-07-24-bayesian-power-analysis-part-ii_files/figure-html/unnamed-chunk-7-1.png&#34; width=&#34;384&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Though the posterior mean suggests the most probable value for &lt;span class=&#34;math inline&#34;&gt;\(\beta_1\)&lt;/span&gt; is about 0.6, the intervals suggest values from about 0.2 to almost 1 are within the 95% probability range. That’s a wide spread. Within psychology, a standardized mean difference of 0.2 would typically be considered small, whereas a difference of 1 would be large enough to raise a skeptical eyebrow or two.&lt;/p&gt;
&lt;p&gt;So instead of focusing on rejecting a null hypothesis like &lt;span class=&#34;math inline&#34;&gt;\(\mu_\text{control} = \mu_\text{treatment}\)&lt;/span&gt;, we might instead use our simulation skills to determine the sample size we need to have most of our 95% intervals come in at a certain level of precision. This has been termed the accuracy in parameter estimation (AIPE; &lt;a href=&#34;https://www3.nd.edu/~kkelley/publications/articles/Maxwell_Kelley_Rausch_2008.pdf&#34;&gt;Maxwell, Kelley, &amp;amp; Rausch, 2008&lt;/a&gt;; see also &lt;a href=&#34;http://www.indiana.edu/~kruschke/DoingBayesianDataAnalysis/&#34;&gt;Kruschke, 2014&lt;/a&gt;) approach to sample size planning.&lt;/p&gt;
&lt;p&gt;Thinking in terms of AIPE, in terms of precision, let’s say we wanted widths of 0.7 or smaller. Here’s how we did with &lt;code&gt;s3&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;s3 %&amp;gt;% 
  mutate(check = ifelse(width &amp;lt; .7, 1, 0)) %&amp;gt;% 
  summarise(`width power` = mean(check))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1 x 1
##   `width power`
##           &amp;lt;dbl&amp;gt;
## 1          0.08&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We did terrible. I’m not sure the term “width power” is even a thing. But hopefully you get the point. Our baby 100-iteration simulation suggests we have about a .08 probability of achieving 95% CI widths of 0.7 or smaller with &lt;span class=&#34;math inline&#34;&gt;\(n = 50\)&lt;/span&gt; per group. Though we’re pretty good at excluding zero, we don’t tend to do so with precision above that.&lt;/p&gt;
&lt;p&gt;That last bit about excluding zero brings up an important point. Once we’re concerned about width size, about precision, the null hypothesis is no longer of direct relevance. And since we’re no longer wed to thinking in terms of the null hypothesis, there’s no real need to stick with a .8 threshold for evaluating width power (okay, I’ll stop using that term). Now if we wanted to stick with .8, we could. Though a little nonsensical, the .8 criterion would give our AIPE analyses a sense of familiarity with traditional power analyses, which some reviewers might appreciate. But in his text, Kruschke mentioned several other alternatives. One would be to set maximum value for our CI widths and simulate to find the &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; necessary so all our simulations pass that criterion. Another would follow Joseph, Wolfson, and du Berger (&lt;a href=&#34;http://www.medicine.mcgill.ca/epidemiology/Joseph/publications%5CMethodological%5Css_binom.pdf&#34;&gt;1995a&lt;/a&gt;, &lt;a href=&#34;http://www.med.mcgill.ca/epidemiology/Joseph/publications/Methodological/ss_hpd.pdf&#34;&gt;1995b&lt;/a&gt;), who suggested we shoot for an &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; that produces widths that pass that criterion on average. Here’s how we did based on the average-width criterion.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;s3 %&amp;gt;% 
  summarise(`average width` = mean(width))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1 x 1
##   `average width`
##             &amp;lt;dbl&amp;gt;
## 1           0.784&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Close. Let’s see how increasing our sample size to 75 per group effects these metrics.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;s4 &amp;lt;-
  tibble(seed = 1:n_sim) %&amp;gt;% 
  mutate(tidy = map(seed, sim_d_and_fit, n = 75)) %&amp;gt;% 
  unnest(tidy) %&amp;gt;%
  mutate(width = upper - lower)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here’s what our new batch of 95% intervals looks like.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;s4 %&amp;gt;% 
  ggplot(aes(x = reorder(seed, lower), y = estimate, ymin = lower, ymax = upper)) +
  geom_hline(yintercept = c(0, .5), color = &amp;quot;white&amp;quot;) +
  geom_pointrange(fatten = 1/2) +
  scale_x_discrete(&amp;quot;reordered by the lower level of the 95% intervals&amp;quot;, breaks = NULL) +
  ylab(expression(beta[1])) +
  # this kept the scale on the y-axis the same as the simulation with n = 50
  coord_cartesian(ylim = c(-.5, 1.3))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-07-24-bayesian-power-analysis-part-ii_files/figure-html/unnamed-chunk-10-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Some of the intervals are still more precise than others, but they all now hover more tightly around their true data-generating value of 0.5. Here’s our updated “power” for producing interval widths smaller than 0.7.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;s4 %&amp;gt;% 
  mutate(check = ifelse(width &amp;lt; .7, 1, 0)) %&amp;gt;% 
  summarise(`proportion below 0.7` = mean(check),
            `average width`        = mean(width))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1 x 2
##   `proportion below 0.7` `average width`
##                    &amp;lt;dbl&amp;gt;           &amp;lt;dbl&amp;gt;
## 1                   0.94           0.637&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we hold to the NHST-oriented .8 threshold, we did great and are even “overpowered”. We didn’t quite meet Kruschke’s strict limiting-worst-precision threshold, but we got close enough we’d have a good sense of what range of &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; values we might evaluate over next. As far as the mean-precision criterion, we did great by that one and even beat it by about 0.04.&lt;/p&gt;
&lt;p&gt;Here’s a look at how this batch of widths is distributed.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;s4 %&amp;gt;% 
  ggplot(aes(x = width)) +
  geom_histogram(binwidth = .02) +
  geom_rug(size = 1/6)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-07-24-bayesian-power-analysis-part-ii_files/figure-html/unnamed-chunk-12-1.png&#34; width=&#34;384&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Let’s see if we can nail down the &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt;s for our three AIPE criteria. Since we’re so close to fulfilling Kruschke’s limiting-worst-precision criterion, we’ll start there. I’m thinking &lt;span class=&#34;math inline&#34;&gt;\(n = 85\)&lt;/span&gt; should just about do it.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;s5 &amp;lt;-
  tibble(seed = 1:n_sim) %&amp;gt;% 
  mutate(tidy = map(seed, sim_d_and_fit, n = 85)) %&amp;gt;% 
  unnest(tidy) %&amp;gt;%
  mutate(width = upper - lower)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Did we pass?&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;s5 %&amp;gt;% 
  mutate(check = ifelse(width &amp;lt; .7, 1, 0)) %&amp;gt;% 
  summarise(`proportion below 0.7` = mean(check))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1 x 1
##   `proportion below 0.7`
##                    &amp;lt;dbl&amp;gt;
## 1                      1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Success! We might look at how they’re distributed.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;s5 %&amp;gt;% 
  ggplot(aes(x = width)) +
  geom_histogram(binwidth = .01) +
  geom_rug(size = 1/6)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-07-24-bayesian-power-analysis-part-ii_files/figure-html/unnamed-chunk-14-1.png&#34; width=&#34;384&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Two of our simulated widths were pretty close to the 0.7 boundary. If we were to do a proper simulation with 1000+ iterations, I’d worry one or two would creep over that boundary. So perhaps &lt;span class=&#34;math inline&#34;&gt;\(n = 90\)&lt;/span&gt; would be a better candidate for a large-scale simulation.&lt;/p&gt;
&lt;p&gt;If we just wanted to meet the mean-precision criterion, we might look at something like &lt;span class=&#34;math inline&#34;&gt;\(n = 65\)&lt;/span&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;s6 &amp;lt;-
  tibble(seed = 1:n_sim) %&amp;gt;% 
  mutate(tidy = map(seed, sim_d_and_fit, n = 65)) %&amp;gt;% 
  unnest(tidy) %&amp;gt;%
  mutate(width = upper - lower)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Did we pass?&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;s6 %&amp;gt;% 
  summarise(`average width` = mean(width))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1 x 1
##   `average width`
##             &amp;lt;dbl&amp;gt;
## 1           0.686&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We got it! It looks like something like &lt;span class=&#34;math inline&#34;&gt;\(n = 65\)&lt;/span&gt; would be a good candidate for a larger-scale simulation. Here’s the distribution.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;s6 %&amp;gt;% 
  ggplot(aes(x = width)) +
  geom_histogram(binwidth = .02) +
  geom_rug(size = 1/6)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-07-24-bayesian-power-analysis-part-ii_files/figure-html/unnamed-chunk-16-1.png&#34; width=&#34;384&#34; /&gt;&lt;/p&gt;
&lt;p&gt;For our final possible criterion, just get .8 of the widths below the threshold, we’ll want an &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; somewhere between 65 and 85. 70, perhaps?&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;s7 &amp;lt;-
  tibble(seed = 1:n_sim) %&amp;gt;% 
  mutate(tidy = map(seed, sim_d_and_fit, n = 70)) %&amp;gt;% 
  unnest(tidy) %&amp;gt;%
  mutate(width = upper - lower)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Did we pass?&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;s7 %&amp;gt;% 
  mutate(check = ifelse(width &amp;lt; .7, 1, 0)) %&amp;gt;% 
  summarise(`proportion below 0.7` = mean(check))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1 x 1
##   `proportion below 0.7`
##                    &amp;lt;dbl&amp;gt;
## 1                   0.82&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Yep. Here’s the distribution.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;s7 %&amp;gt;% 
  ggplot(aes(x = width)) +
  geom_histogram(binwidth = .02) +
  geom_rug(size = 1/6)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-07-24-bayesian-power-analysis-part-ii_files/figure-html/unnamed-chunk-18-1.png&#34; width=&#34;384&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;how-are-we-defining-our-widths&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;How are we defining our widths?&lt;/h2&gt;
&lt;p&gt;In frequentist analyses, we typically work with 95% confidence intervals because of their close connection to the conventional &lt;span class=&#34;math inline&#34;&gt;\(p &amp;lt; .05\)&lt;/span&gt; threshold. Another consequence of dropping our focus on rejecting &lt;span class=&#34;math inline&#34;&gt;\(H_0\)&lt;/span&gt; is that it no longer seems necessary to evaluate our posteriors with 95% intervals. And as it turns out, some Bayesians aren’t fans of the 95% interval. McElreath, for example, defiantly used 89% intervals in his &lt;a href=&#34;http://xcelab.net/rm/statistical-rethinking/&#34;&gt;text&lt;/a&gt;. In contrast, Gelman has &lt;a href=&#34;https://statmodeling.stat.columbia.edu/2016/11/05/why-i-prefer-50-to-95-intervals/&#34;&gt;blogged&lt;/a&gt; on his fondness for 50% intervals. Just for kicks, let’s follow Gelman’s lead and practice evaluating an &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; based on 50% intervals. This will require us to update our &lt;code&gt;sim_d_and_fit()&lt;/code&gt; function to allow us to change the &lt;code&gt;prob&lt;/code&gt; setting in the &lt;code&gt;broom::tidy()&lt;/code&gt; function.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sim_d_and_fit &amp;lt;- function(seed, n, prob) {
  
  mu_c &amp;lt;- 0
  mu_t &amp;lt;- 0.5
  
  set.seed(seed)
  
  d &amp;lt;-
    tibble(group     = rep(c(&amp;quot;control&amp;quot;, &amp;quot;treatment&amp;quot;), each = n)) %&amp;gt;% 
    mutate(treatment = ifelse(group == &amp;quot;control&amp;quot;, 0, 1),
           y         = ifelse(group == &amp;quot;control&amp;quot;, 
                              rnorm(n, mean = mu_c, sd = 1),
                              rnorm(n, mean = mu_t, sd = 1)))
  
  update(fit,
         newdata = d, 
         seed = seed) %&amp;gt;% 
    tidy(prob = prob) %&amp;gt;% 
    filter(term == &amp;quot;b_treatment&amp;quot;)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now simulate to examine those 50% intervals. We’ll start with the original &lt;span class=&#34;math inline&#34;&gt;\(n = 50\)&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;n_sim &amp;lt;- 100

s8 &amp;lt;-
  tibble(seed = 1:n_sim) %&amp;gt;% 
  mutate(tidy = map(seed, sim_d_and_fit, n = 50, prob = .5)) %&amp;gt;% 
  unnest(tidy) %&amp;gt;% 
  mutate(width = upper - lower)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here is the distribution of our 50% interval widths.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;s8 %&amp;gt;% 
  mutate(width = upper - lower) %&amp;gt;% 
  
  ggplot(aes(x = width)) +
  geom_histogram(binwidth = .01) +
  geom_rug(size = 1/6)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-07-24-bayesian-power-analysis-part-ii_files/figure-html/unnamed-chunk-20-1.png&#34; width=&#34;384&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Since we’ve gone from 95% to 50% intervals, it should be no surprise that their widths are substantially more narrow. Accordingly, we should evaluate then with a higher standard. Perhaps it’s more reasonable to ask for an average width of 0.1. Let’s see how close &lt;span class=&#34;math inline&#34;&gt;\(n = 150\)&lt;/span&gt; gets us.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;s9 &amp;lt;-
  tibble(seed = 1:n_sim) %&amp;gt;% 
  mutate(tidy = map(seed, sim_d_and_fit, n = 150, prob = .5)) %&amp;gt;% 
  unnest(tidy) %&amp;gt;% 
  mutate(width = upper - lower)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Look at the distribution.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;s9 %&amp;gt;% 
  ggplot(aes(x = width)) +
  geom_histogram(binwidth = .0025) +
  geom_rug(size = 1/6)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-07-24-bayesian-power-analysis-part-ii_files/figure-html/unnamed-chunk-21-1.png&#34; width=&#34;384&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Nope, we’re not there yet. Perhaps &lt;span class=&#34;math inline&#34;&gt;\(n = 200\)&lt;/span&gt; or &lt;span class=&#34;math inline&#34;&gt;\(250\)&lt;/span&gt; is the ticket. This is an iterative process. Anyway, once we’re talking that AIPE/precision/interval-width talk, we can get all kinds of creative with which intervals we’re even interested in. As far as I can tell, the topic is wide open for fights and collaborations between statisticians, methodologists, and substantive researchers to find sensible ways forward.&lt;/p&gt;
&lt;p&gt;Maybe you should write a dissertation on it.&lt;/p&gt;
&lt;p&gt;Regardless, stay tuned for part III where we’ll liberate ourselves from the tyranny of the Gauss.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;session-info&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Session info&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sessionInfo()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## R version 3.6.0 (2019-04-26)
## Platform: x86_64-apple-darwin15.6.0 (64-bit)
## Running under: macOS High Sierra 10.13.6
## 
## Matrix products: default
## BLAS:   /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRblas.0.dylib
## LAPACK: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRlapack.dylib
## 
## locale:
## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
##  [1] broom_0.5.2     brms_2.10.0     Rcpp_1.0.2      forcats_0.4.0  
##  [5] stringr_1.4.0   dplyr_0.8.3     purrr_0.3.2     readr_1.3.1    
##  [9] tidyr_1.0.0     tibble_2.1.3    ggplot2_3.2.1   tidyverse_1.2.1
## 
## loaded via a namespace (and not attached):
##  [1] nlme_3.1-139          matrixStats_0.54.0    xts_0.11-2           
##  [4] lubridate_1.7.4       threejs_0.3.1         httr_1.4.0           
##  [7] rstan_2.19.2          tools_3.6.0           backports_1.1.4      
## [10] utf8_1.1.4            R6_2.4.0              DT_0.7               
## [13] lazyeval_0.2.2        colorspace_1.4-1      withr_2.1.2          
## [16] prettyunits_1.0.2     processx_3.3.1        tidyselect_0.2.5     
## [19] gridExtra_2.3         Brobdingnag_1.2-6     compiler_3.6.0       
## [22] cli_1.1.0             rvest_0.3.4           xml2_1.2.0           
## [25] shinyjs_1.0           labeling_0.3          colourpicker_1.0     
## [28] bookdown_0.12         scales_1.0.0          dygraphs_1.1.1.6     
## [31] mvtnorm_1.0-11        callr_3.2.0           ggridges_0.5.1       
## [34] StanHeaders_2.18.1-10 digest_0.6.20         rmarkdown_1.13       
## [37] base64enc_0.1-3       pkgconfig_2.0.2       htmltools_0.3.6      
## [40] htmlwidgets_1.3       rlang_0.4.0           readxl_1.3.1         
## [43] rstudioapi_0.10       shiny_1.3.2           generics_0.0.2       
## [46] zoo_1.8-6             jsonlite_1.6          crosstalk_1.0.0      
## [49] gtools_3.8.1          inline_0.3.15         magrittr_1.5         
## [52] loo_2.1.0             bayesplot_1.7.0       Matrix_1.2-17        
## [55] fansi_0.4.0           munsell_0.5.0         abind_1.4-5          
## [58] lifecycle_0.1.0       stringi_1.4.3         yaml_2.2.0           
## [61] pkgbuild_1.0.3        plyr_1.8.4            grid_3.6.0           
## [64] parallel_3.6.0        promises_1.0.1        crayon_1.3.4         
## [67] miniUI_0.1.1.1        lattice_0.20-38       haven_2.1.0          
## [70] hms_0.4.2             ps_1.3.0              zeallot_0.1.0        
## [73] knitr_1.23            pillar_1.4.2          igraph_1.2.4.1       
## [76] markdown_1.0          shinystan_2.5.0       stats4_3.6.0         
## [79] reshape2_1.4.3        rstantools_1.5.1      glue_1.3.1           
## [82] evaluate_0.14         blogdown_0.14         modelr_0.1.4         
## [85] vctrs_0.2.0           httpuv_1.5.1          cellranger_1.1.0     
## [88] gtable_0.3.0          assertthat_0.2.1      xfun_0.8             
## [91] mime_0.7              xtable_1.8-4          coda_0.19-2          
## [94] later_0.8.0           rsconnect_0.8.13      shinythemes_1.1.2    
## [97] bridgesampling_0.6-0&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;footnote&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Footnote&lt;/h2&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;To be clear, one can consider the null hypothesis within the Bayesian paradigm. I don’t tend to take this approach, but it’d be unfair not to at least mention some resources. Kurschke covered the topic in chapters 11 and 12 in his text, &lt;a href=&#34;http://www.indiana.edu/~kruschke/DoingBayesianDataAnalysis/&#34;&gt;&lt;em&gt;Doing Bayesian Data Analysis, Second Edition:
A Tutorial with R, JAGS, and Stan&lt;/em&gt;&lt;/a&gt;. You might also check out Rouder et al’s &lt;a href=&#34;https://link.springer.com/content/pdf/10.3758/PBR.16.2.225.pdf&#34;&gt;&lt;em&gt;Bayesian t tests for accepting and rejecting the null hypothesis&lt;/em&gt;&lt;/a&gt; or Morey and Rouder’s &lt;a href=&#34;https://s3.amazonaws.com/academia.edu.documents/45416179/Bayes_Factor_Approaches_for_Testing_Inte20160506-23207-1t89l96.pdf?response-content-disposition=inline%3B%20filename%3DBayes_factor_approaches_for_testing_inte.pdf&amp;amp;X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;amp;X-Amz-Credential=AKIAIWOWYYGZ2Y53UL3A%2F20190724%2Fus-east-1%2Fs3%2Faws4_request&amp;amp;X-Amz-Date=20190724T201328Z&amp;amp;X-Amz-Expires=3600&amp;amp;X-Amz-SignedHeaders=host&amp;amp;X-Amz-Signature=76ce5abb6bf9fb41c9c677038f79bb75e19e65bc21d97233519701035304d712&#34;&gt;&lt;em&gt;Bayes Factor Approaches for Testing Interval Null Hypotheses&lt;/em&gt;&lt;/a&gt;.&lt;a href=&#34;#fnref1&#34; class=&#34;footnote-back&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Bayesian power analysis: Part I. Prepare to reject $H_0$ with simulation.</title>
      <link>/post/bayesian-power-analysis-part-i/</link>
      <pubDate>Thu, 18 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/bayesian-power-analysis-part-i/</guid>
      <description>&lt;div id=&#34;version-1.0.0&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Version 1.0.0&lt;/h2&gt;
&lt;/div&gt;
&lt;div id=&#34;tldr&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;tl;dr&lt;/h2&gt;
&lt;p&gt;If you’d like to learn how to do Bayesian power calculations using &lt;strong&gt;brms&lt;/strong&gt;, stick around for this multi-part blog series. Here with part I, we’ll set the foundation.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;power-is-hard-especially-for-bayesians.&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Power is hard, especially for Bayesians.&lt;/h2&gt;
&lt;p&gt;Many journals, funding agencies, and dissertation committees require power calculations for your primary analyses. Frequentists have a variety of tools available to perform these calculations (e.g., &lt;a href=&#34;https://rpsychologist.com/analytical-and-simulation-based-power-analyses-for-mixed-design-anovas&#34;&gt;here&lt;/a&gt;). Bayesians, however, have a more difficult time of it. Most of our research questions and data issues are sufficiently complicated that we cannot solve the problems by hand. We need Markov chain Monte Carlo methods to iteratively sample from the posterior to summarize the parameters from our models. Same deal for power. If you’d like to compute the power for a given combination of &lt;span class=&#34;math inline&#34;&gt;\(N\)&lt;/span&gt;, likelihood &lt;span class=&#34;math inline&#34;&gt;\(p(\text{data} | \theta)\)&lt;/span&gt;, and set of priors &lt;span class=&#34;math inline&#34;&gt;\(p (\theta)\)&lt;/span&gt;, you’ll need to simulate.&lt;/p&gt;
&lt;p&gt;It’s been one of my recent career goals to learn how to do this. You know how they say: &lt;em&gt;The best way to learn is to teach&lt;/em&gt;. This series of blog posts is the evidence of me learning by teaching. It will be an exploration of what a Bayesian power simulation workflow might look like. The overall statistical framework will be &lt;strong&gt;R&lt;/strong&gt;, with an emphasis on code style based on the &lt;a href=&#34;https://www.tidyverse.org&#34;&gt;&lt;strong&gt;tidyverse&lt;/strong&gt;&lt;/a&gt;. We’ll be fitting our Bayesian models with Bürkner’s &lt;a href=&#34;https://github.com/paul-buerkner/brms&#34;&gt;&lt;strong&gt;brms&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;What this series is not, however, is an introduction to statistical power itself. Keep reading if you’re ready to roll up your sleeves, put on your applied hat, and learn how to get things done. If you’re more interested in introductions to power, see the references in the next section.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;i-make-assumptions.&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;I make assumptions.&lt;/h2&gt;
&lt;p&gt;For this series, I’m presuming you are familiar with linear regression, familiar with the basic differences between frequentist and Bayesian approaches to statistics, and have a basic sense of what we mean by statistical power. Here are some resources if you’d like to shore up.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If you’re unfamiliar with statistical power, Kruschke covered it in chapter 13 of his &lt;a href=&#34;http://www.indiana.edu/~kruschke/DoingBayesianDataAnalysis/&#34;&gt;text&lt;/a&gt;. You might also check out &lt;a href=&#34;https://www3.nd.edu/~kkelley/publications/articles/Maxwell_Kelley_Rausch_2008.pdf&#34;&gt;this review paper&lt;/a&gt; by Maxwell, Kelley, and Rausch. There’s always, of course, the original work by Cohen (e.g., &lt;a href=&#34;https://www.worldcat.org/title/statistical-power-analysis-for-the-behavioral-sciences/oclc/17877467&#34;&gt;here&lt;/a&gt;). You might also like this &lt;a href=&#34;https://www.khanacademy.org/math/ap-statistics/tests-significance-ap/error-probabilities-power/v/introduction-to-power-in-significance-tests&#34;&gt;Khan Academy video&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;To learn about Bayesian regression, I recommend the introductory text books by either McElreath (&lt;a href=&#34;https://xcelab.net/rm/statistical-rethinking/&#34;&gt;here&lt;/a&gt;) or Kruschke (&lt;a href=&#34;http://www.indiana.edu/~kruschke/DoingBayesianDataAnalysis/&#34;&gt;here&lt;/a&gt;). Both authors host blogs (&lt;a href=&#34;http://doingbayesiandataanalysis.blogspot.com&#34;&gt;here&lt;/a&gt; and &lt;a href=&#34;http://elevanth.org/blog/&#34;&gt;here&lt;/a&gt;, respectively). If you go with McElreath, do check out his &lt;a href=&#34;https://www.youtube.com/channel/UCNJK6_DZvcMqNSzQdEkzvzA/playlists&#34;&gt;online lectures&lt;/a&gt; and &lt;a href=&#34;https://bookdown.org/connect/#/apps/1850/access&#34;&gt;my project&lt;/a&gt; translating his text to &lt;strong&gt;brms&lt;/strong&gt; and &lt;strong&gt;tidyverse&lt;/strong&gt; code. I’m working on a &lt;a href=&#34;https://github.com/ASKurz/Doing-Bayesian-Data-Analysis-in-brms-and-the-tidyverse&#34;&gt;similar project&lt;/a&gt; for Kruschke’s text, but it still has a ways to go before I release it in full.&lt;/li&gt;
&lt;li&gt;For even more &lt;strong&gt;brms&lt;/strong&gt;-related resources, you can find vignettes and documentation &lt;a href=&#34;https://cran.r-project.org/web/packages/brms/index.html&#34;&gt;here&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;For &lt;strong&gt;tidyverse&lt;/strong&gt; introductions, your best bets are &lt;a href=&#34;https://r4ds.had.co.nz&#34;&gt;&lt;em&gt;R4DS&lt;/em&gt;&lt;/a&gt; and &lt;a href=&#34;https://style.tidyverse.org&#34;&gt;&lt;em&gt;The tidyverse style guide&lt;/em&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;We’ll be simulating data. If that’s new to you, both Kruschke and McElreath cover that a little in their texts. You can find nice online tutorials &lt;a href=&#34;https://debruine.github.io/tutorials/sim-data.html&#34;&gt;here&lt;/a&gt; and &lt;a href=&#34;https://aosmith.rbind.io/2018/08/29/getting-started-simulating-data/&#34;&gt;here&lt;/a&gt;, too.&lt;/li&gt;
&lt;li&gt;We’ll also be making a couple custom functions. If that’s new, you might check out &lt;a href=&#34;https://r4ds.had.co.nz/functions.html&#34;&gt;&lt;em&gt;R4DS&lt;/em&gt;, chapter 19&lt;/a&gt; or &lt;a href=&#34;https://bookdown.org/rdpeng/rprogdatascience/functions.html&#34;&gt;chapter 14&lt;/a&gt; of Roger Peng’s &lt;em&gt;R Programming for Data Science&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;we-need-to-warm-up-before-jumping-into-power.&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;We need to warm up before jumping into power.&lt;/h2&gt;
&lt;p&gt;Let’s load our primary packages. The &lt;strong&gt;tidyverse&lt;/strong&gt; helps organize data, we model with &lt;strong&gt;brms&lt;/strong&gt;, and &lt;strong&gt;broom&lt;/strong&gt; will help organize the model summaries.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidyverse)
library(brms)
library(broom)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Consider a case where you have some dependent variable &lt;span class=&#34;math inline&#34;&gt;\(Y\)&lt;/span&gt; that you’d like to compare between two groups, which we’ll call treatment and control. Here we presume &lt;span class=&#34;math inline&#34;&gt;\(Y\)&lt;/span&gt; is continuous and, for the sake of simplicity, is in a standardized metric for the control condition. Letting &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt; stand for control and &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; index the data row for a given case, we might write that as &lt;span class=&#34;math inline&#34;&gt;\(y_{i, c} \sim \text{Normal} (0, 1)\)&lt;/span&gt;. The mean for our treatment condition is 0.5, with the standard deviation still in the standardized metric. In the social sciences a standardized mean difference of 0.5 would typically be considered a medium effect size. Here’s what that’d look like.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# set our theme because, though I love the default ggplot theme, I hate gridlines
theme_set(theme_grey() +
            theme(panel.grid = element_blank()))

# define the means
mu_c &amp;lt;- 0
mu_t &amp;lt;- 0.5

# set up the data
tibble(x = seq(from = -4, to = 5, by = .01)) %&amp;gt;%
  mutate(c = dnorm(x, mean = mu_c, sd = 1),
         t = dnorm(x, mean = mu_t, sd = 1)) %&amp;gt;% 
  
  # plot
  ggplot(aes(x = x, ymin = 0)) +
  geom_ribbon(aes(ymax = c),
              size = 0, alpha = 1/3, fill = &amp;quot;grey25&amp;quot;) +
  geom_ribbon(aes(ymax = t),
              size = 0, alpha = 1/3, fill = &amp;quot;blue2&amp;quot;) +
  geom_text(data = tibble(x = c(-.5, 1),
                          y = .385,
                          label = c(&amp;quot;control&amp;quot;, &amp;quot;treatment&amp;quot;),
                          hjust = 1:0),
            aes(y = y, label = label, color = label, hjust = hjust),
            size = 5, show.legend = F) +
  scale_x_continuous(NULL, breaks = -4:5) +
  scale_y_continuous(NULL, breaks = NULL) +
  scale_color_manual(values = c(&amp;quot;grey25&amp;quot;, &amp;quot;blue2&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-07-18-bayesian-power-analysis-part-i_files/figure-html/unnamed-chunk-2-1.png&#34; width=&#34;576&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Sure, those distributions have a lot of overlap. But their means are clearly different and we’d like to make sure we plan on collecting enough data to do a good job showing that. A power analysis will help.&lt;/p&gt;
&lt;p&gt;Within the conventional frequentist paradigm, power is the probability of rejecting the null hypothesis &lt;span class=&#34;math inline&#34;&gt;\(H_0\)&lt;/span&gt; in favor of the alternative hypothesis &lt;span class=&#34;math inline&#34;&gt;\(H_1\)&lt;/span&gt;, given the alternative hypothesis is “true.” In this case, the typical null hypothesis is&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[H_0\text{: } \mu_c = \mu_t,\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;or put differently,&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
H_0\text{: } \mu_t - \mu_c = 0.
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;And the alternative hypothesis is often just&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[H_1\text{: } \mu_c \neq \mu_t,\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;or otherwise put,&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
H_1\text{: } \mu_t - \mu_c \neq 0.
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Within the regression framework, we’ll be comparing &lt;span class=&#34;math inline&#34;&gt;\(\mu\)&lt;/span&gt;s using the formula&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{align*}
y_i &amp;amp; \sim \text{Normal} (\mu_i, \sigma) \\
\mu_i &amp;amp; = \beta_0 + \beta_1 \text{treatment}_i,
\end{align*}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;where &lt;span class=&#34;math inline&#34;&gt;\(\text{treatment}\)&lt;/span&gt; is a dummy variable coded 0 = control 1 = treatment and varies across cases indexed by &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;. In this setup, &lt;span class=&#34;math inline&#34;&gt;\(\beta_0\)&lt;/span&gt; is the estimate for &lt;span class=&#34;math inline&#34;&gt;\(\mu_c\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(\beta_1\)&lt;/span&gt; is the estimate of the difference between condition means, &lt;span class=&#34;math inline&#34;&gt;\(\mu_t - \mu_c\)&lt;/span&gt;. Thus our focal parameter, the one we care about the most in our power analysis, will be &lt;span class=&#34;math inline&#34;&gt;\(\beta_1\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Within the frequentist paradigm, we typically compare these hypotheses using a &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt;-value for &lt;span class=&#34;math inline&#34;&gt;\(H_0\)&lt;/span&gt; with the critical value, &lt;span class=&#34;math inline&#34;&gt;\(\alpha\)&lt;/span&gt;, set to .05. Thus, power is the probability we’ll have &lt;span class=&#34;math inline&#34;&gt;\(p &amp;lt; .05\)&lt;/span&gt; when it is indeed the case that &lt;span class=&#34;math inline&#34;&gt;\(\mu_c \neq \mu_t\)&lt;/span&gt;. We won’t be computing &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt;-values in this project, but we will use 95% intervals. Recall that the result of a Bayesian analysis, the posterior distribution, is the probability of the parameters, given the data &lt;span class=&#34;math inline&#34;&gt;\(p (\theta | \text{data})\)&lt;/span&gt;. With our 95% Bayesian credible intervals, we’ll be able to describe the parameter space over which our estimate of &lt;span class=&#34;math inline&#34;&gt;\(\mu_t - \mu_c\)&lt;/span&gt; is 95% probable. That is, for our power analysis, we’re interested in the probability our 95% credible intervals for &lt;span class=&#34;math inline&#34;&gt;\(\beta_1\)&lt;/span&gt; contain zero within their bounds when we know a priori &lt;span class=&#34;math inline&#34;&gt;\(\mu_c \neq \mu_t\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;The reason we know &lt;span class=&#34;math inline&#34;&gt;\(\mu_c \neq \mu_t\)&lt;/span&gt; is because we’ll be simulating the data that way. What our power analysis will help us determine is how many cases we’ll need to achieve a predetermined level of power. The conventional threshold is .8.&lt;/p&gt;
&lt;div id=&#34;dry-run-number-1.&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Dry run number 1.&lt;/h3&gt;
&lt;p&gt;To make this all concrete, let’s start with a simple example. We’ll simulate a single set of data, fit a Bayesian regression model, and examine the results for the critical parameter &lt;span class=&#34;math inline&#34;&gt;\(\beta_1\)&lt;/span&gt;. For the sake of simplicity, let’s keep our two groups, treatment and control, the same size. We’ll start with &lt;span class=&#34;math inline&#34;&gt;\(n = 50\)&lt;/span&gt; for each.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;n &amp;lt;- 50&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We already decided above that&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{align*}
y_{i, c} &amp;amp; \sim \text{Normal} (0, 1) \text{ and}\\
y_{i, t} &amp;amp; \sim \text{Normal} (0.5, 1).
\end{align*}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Here’s how we might simulate data along those lines.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(1)

d &amp;lt;-
  tibble(group     = rep(c(&amp;quot;control&amp;quot;, &amp;quot;treatment&amp;quot;), each = n)) %&amp;gt;% 
  mutate(treatment = ifelse(group == &amp;quot;control&amp;quot;, 0, 1),
         y         = ifelse(group == &amp;quot;control&amp;quot;, 
                            rnorm(n, mean = mu_c, sd = 1),
                            rnorm(n, mean = mu_t, sd = 1)))

glimpse(d)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Observations: 100
## Variables: 3
## $ group     &amp;lt;chr&amp;gt; &amp;quot;control&amp;quot;, &amp;quot;control&amp;quot;, &amp;quot;control&amp;quot;, &amp;quot;control&amp;quot;, &amp;quot;control&amp;quot;,…
## $ treatment &amp;lt;dbl&amp;gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, …
## $ y         &amp;lt;dbl&amp;gt; -0.62645381, 0.18364332, -0.83562861, 1.59528080, 0.32…&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In case it wasn’t clear, the two variables &lt;code&gt;group&lt;/code&gt; and &lt;code&gt;treatment&lt;/code&gt; are redundant. Whereas the former is composed of names, the latter is the dummy-variable equivalent (i.e., control = 0, treatment = 1). The main event was how we used the &lt;code&gt;rnorm()&lt;/code&gt; function to simulate the normally-distributed values for &lt;code&gt;y&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Before we fit our model, we need to decide on priors. To give us ideas, here are the &lt;strong&gt;brms&lt;/strong&gt; defaults for our model and data.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;get_prior(data = d,
          family = gaussian,
          y ~ 0 + intercept + treatment)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                 prior class      coef group resp dpar nlpar bound
## 1                         b                                      
## 2                         b intercept                            
## 3                         b treatment                            
## 4 student_t(3, 0, 10) sigma&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A few things: Notice that here we’re using the &lt;code&gt;0 + intercept&lt;/code&gt; syntax. This is because &lt;strong&gt;brms&lt;/strong&gt; handles the priors for the default intercept under the presumption you’ve mean-centered all your predictor variables. However, since our &lt;code&gt;treatment&lt;/code&gt; variable is a dummy, that assumption won’t fly. The &lt;code&gt;0 + intercept&lt;/code&gt; allows us to treat the model intercept as just another &lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt; parameter, which makes no assumptions about centering. Along those lines, you’ll notice &lt;strong&gt;brms&lt;/strong&gt; currently defaults to flat priors for the &lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt; parameters (i.e., those for which &lt;code&gt;class = b&lt;/code&gt;). And finally, the default prior on &lt;span class=&#34;math inline&#34;&gt;\(\sigma\)&lt;/span&gt; is rather wide &lt;code&gt;student_t(3, 0, 10)&lt;/code&gt;. By default, &lt;strong&gt;brms&lt;/strong&gt; also sets the left bounds for &lt;span class=&#34;math inline&#34;&gt;\(\sigma\)&lt;/span&gt; parameters at zero, making that a folded-&lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; distribution. If you’re confused by these details, spend some time with the &lt;a href=&#34;https://cran.r-project.org/web/packages/brms/brms.pdf&#34;&gt;&lt;strong&gt;brms&lt;/strong&gt; reference manual&lt;/a&gt;, particularly the &lt;code&gt;brm&lt;/code&gt; and &lt;code&gt;brmsformula&lt;/code&gt; sections.&lt;/p&gt;
&lt;p&gt;In this project, we’ll be primarily using two kinds of priors: default flat priors and weakly-regularizing priors. Hopefully flat priors are self-explanatory. They let the likelihood (data) dominate the posterior and tend to produce results similar to those from frequentist estimators.&lt;/p&gt;
&lt;p&gt;As for weakly-regularizing priors, McElreath covered them in his text. They’re mentioned a bit in the &lt;strong&gt;Stan&lt;/strong&gt; team’s &lt;a href=&#34;https://github.com/stan-dev/stan/wiki/Prior-Choice-Recommendations&#34;&gt;&lt;em&gt;Prior Choice Recommendations&lt;/em&gt;&lt;/a&gt; wiki, and you can learn even more from Gelman, Simpson, and Betancourt’s &lt;a href=&#34;http://www.stat.columbia.edu/~gelman/research/published/entropy-19-00555-v2.pdf&#34;&gt;&lt;em&gt;The prior can only be understood in the context of the likelihood&lt;/em&gt;&lt;/a&gt;. These priors aren’t strongly informative and aren’t really representative of our research hypotheses. But they’re not as absurd as flat priors, either. Rather, with just a little bit of knowledge about the data, these priors are set to keep the MCMC chains on target. Since our &lt;code&gt;y&lt;/code&gt; variable has a mean near zero and a standard deviation near one and since our sole predictor, &lt;code&gt;treatment&lt;/code&gt; is a dummy, setting &lt;span class=&#34;math inline&#34;&gt;\(\text{Normal} (0, 2)\)&lt;/span&gt; as the prior for both &lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt; parameters might be a good place to start. The prior is permissive enough that it will let likelihood dominate the posterior, but it also rules out ridiculous parts of the parameter space (e.g., a standardized mean difference of 20, an intercept of -93). And since we know the data are on the unit scale, we might just center our folded-Student-&lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; prior on one and add a gentle scale setting of one.&lt;/p&gt;
&lt;p&gt;Feel free to disagree and use your own priors. The great thing about priors is that they can be proposed, defended, criticized and improved. The point is to settle on the priors you can defend with written reasons. Select ones you’d feel comfortable defending to a skeptical reviewer.&lt;/p&gt;
&lt;p&gt;Here’s how we might fit the model:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fit &amp;lt;-
  brm(data = d,
      family = gaussian,
      y ~ 0 + intercept + treatment,
      prior = c(prior(normal(0, 2), class = b),
                prior(student_t(3, 1, 1), class = sigma)),
      seed = 1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Before we look at the summary, we might check the chains in a trace plot. We’re looking for “stuck” chains that don’t appear to come from a normal distribution (the chains are a profile-like view rather than histogram, allowing for inspection of dependence between samples).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot(fit)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-07-18-bayesian-power-analysis-part-i_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Yep, the chains all look good. Here’s the parameter summary.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;print(fit)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  Family: gaussian 
##   Links: mu = identity; sigma = identity 
## Formula: y ~ 0 + intercept + treatment 
##    Data: d (Number of observations: 100) 
## Samples: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;
##          total post-warmup samples = 4000
## 
## Population-Level Effects: 
##           Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
## intercept     0.10      0.13    -0.16     0.36 1.00     2047     1943
## treatment     0.52      0.18     0.16     0.89 1.00     2149     1874
## 
## Family Specific Parameters: 
##       Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
## sigma     0.91      0.07     0.80     1.05 1.00     2971     2371
## 
## Samples were drawn using sampling(NUTS). For each parameter, Eff.Sample 
## is a crude measure of effective sample size, and Rhat is the potential 
## scale reduction factor on split chains (at convergence, Rhat = 1).&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The 95% credible intervals for our &lt;span class=&#34;math inline&#34;&gt;\(\beta_1\)&lt;/span&gt; parameter, termed &lt;code&gt;treatment&lt;/code&gt; in the output, are well above zero.&lt;/p&gt;
&lt;p&gt;Another way to look at the model summary is with the handy &lt;code&gt;broom::tidy()&lt;/code&gt; function.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tidy(fit, prob = .95)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##          term     estimate  std.error        lower        upper
## 1 b_intercept    0.1000063 0.12981873   -0.1556717    0.3562807
## 2 b_treatment    0.5184121 0.18434842    0.1586011    0.8917591
## 3       sigma    0.9142217 0.06608646    0.7958666    1.0544574
## 4        lp__ -136.3247589 1.22142888 -139.4496219 -134.9134606&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It’s important to keep in mind that by default, &lt;code&gt;tidy()&lt;/code&gt; returns 90% intervals for &lt;code&gt;brm()&lt;/code&gt; fit objects. To get the conventional 95% intervals, you’ll need to specify &lt;code&gt;prob = .95&lt;/code&gt;. The intervals are presented for each parameter in the &lt;code&gt;lower&lt;/code&gt; and &lt;code&gt;upper&lt;/code&gt; columns. Once we start simulating in bulk, the &lt;code&gt;tidy()&lt;/code&gt; function will come in handy. You’ll see.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;you-can-reuse-a-fit.&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;You can reuse a fit.&lt;/h3&gt;
&lt;p&gt;Especially with simple models like this, a lot of the time we spend waiting for &lt;code&gt;brms::brm()&lt;/code&gt; to return the model is wrapped up in compilation. This is because &lt;strong&gt;brms&lt;/strong&gt; is a collection of user-friendly functions designed to fit models with &lt;a href=&#34;https://mc-stan.org&#34;&gt;&lt;strong&gt;Stan&lt;/strong&gt;&lt;/a&gt;. With each new model, &lt;code&gt;brm()&lt;/code&gt; translates your model into &lt;strong&gt;Stan&lt;/strong&gt; code, which then gets translated to C++ and is compiled afterwards (see &lt;a href=&#34;https://cran.r-project.org/web/packages/brms/vignettes/brms_overview.pdf&#34;&gt;here&lt;/a&gt; or &lt;a href=&#34;https://cran.r-project.org/web/packages/brms/brms.pdf&#34;&gt;here&lt;/a&gt;). However, we can use the &lt;code&gt;update()&lt;/code&gt; function to update a previously-compiled fit object with new data. This cuts out the compilation time and allows us to get directly to sampling. Here’s how to do it.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# set a new seed
set.seed(2)

# simulate new data based on that new seed
d &amp;lt;-
  tibble(group     = rep(c(&amp;quot;control&amp;quot;, &amp;quot;treatment&amp;quot;), each = n)) %&amp;gt;% 
  mutate(treatment = ifelse(group == &amp;quot;control&amp;quot;, 0, 1),
         y         = ifelse(group == &amp;quot;control&amp;quot;, 
                            rnorm(n, mean = mu_c, sd = 1),
                            rnorm(n, mean = mu_t, sd = 1)))

updated_fit &amp;lt;-
  update(fit,
         newdata = d,
         seed = 2)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Behold the &lt;code&gt;tidy()&lt;/code&gt; summary of our updated model.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tidy(updated_fit, prob = .95)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##          term      estimate  std.error        lower        upper
## 1 b_intercept    0.07077122 0.16805743   -0.2543290    0.3985108
## 2 b_treatment    0.29682847 0.23684942   -0.1755861    0.7650373
## 3       sigma    1.17641197 0.08439262    1.0282814    1.3555727
## 4        lp__ -161.29465297 1.27330433 -164.6938052 -159.8778327&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Well how about that? In this case, our 95% credible intervals for &lt;span class=&#34;math inline&#34;&gt;\(\beta_1\)&lt;/span&gt; did include zero within their bounds. Though the posterior mean, 0.30, is still well away from zero, here we’d fail to reject &lt;span class=&#34;math inline&#34;&gt;\(H_0\)&lt;/span&gt; at the conventional level. This is why we simulate.&lt;/p&gt;
&lt;p&gt;To recap, we’ve&lt;/p&gt;
&lt;ol style=&#34;list-style-type: lower-alpha&#34;&gt;
&lt;li&gt;determined our primary data type,&lt;/li&gt;
&lt;li&gt;cast our research question in terms of a regression model,&lt;/li&gt;
&lt;li&gt;identified the parameter of interest,&lt;/li&gt;
&lt;li&gt;settled on defensible priors,&lt;/li&gt;
&lt;li&gt;picked an initial sample size,&lt;/li&gt;
&lt;li&gt;fit an initial model with a single simulated data set, and&lt;/li&gt;
&lt;li&gt;practiced reusing that fit with &lt;code&gt;update()&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We’re more than half way there! It’s time to do our first power simulation.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;simulate-to-determine-power.&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Simulate to determine power.&lt;/h2&gt;
&lt;p&gt;In this post, we’ll play with three ways to do a Bayesian power simulation. They’ll all be similar, but hopefully you’ll learn a bit as we transition from one to the next. Though if you’re impatient and all this seems remedial, you could probably just skip down to the final example, Version 3.&lt;/p&gt;
&lt;div id=&#34;version-1-lets-introduce-making-a-custom-model-fitting-function.&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Version 1: Let’s introduce making a custom model-fitting function.&lt;/h3&gt;
&lt;p&gt;For our power analysis, we’ll need to simulate a large number of data sets, each of which we’ll fit a model to. Here we’ll make a custom function, &lt;code&gt;sim_d()&lt;/code&gt;, that will simulate new data sets just like before. Our function will have two parameters: we’ll set our seeds with &lt;code&gt;seed&lt;/code&gt; and determine how many cases we’d like per group with &lt;code&gt;n&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sim_d &amp;lt;- function(seed, n) {
  
  mu_t &amp;lt;- .5
  mu_c &amp;lt;- 0

  set.seed(seed)
  
  tibble(group     = rep(c(&amp;quot;control&amp;quot;, &amp;quot;treatment&amp;quot;), each = n)) %&amp;gt;% 
  mutate(treatment = ifelse(group == &amp;quot;control&amp;quot;, 0, 1),
         y         = ifelse(group == &amp;quot;control&amp;quot;, 
                            rnorm(n, mean = mu_c, sd = 1),
                            rnorm(n, mean = mu_t, sd = 1)))
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here’s a quick example of how our function works.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sim_d(seed = 123, n = 2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 4 x 3
##   group     treatment      y
##   &amp;lt;chr&amp;gt;         &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
## 1 control           0 -0.560
## 2 control           0 -0.230
## 3 treatment         1  2.06 
## 4 treatment         1  0.571&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we’re ready to get down to business. We’re going to be saving our simulation results in a nested data frame, &lt;code&gt;s&lt;/code&gt;. Initially, &lt;code&gt;s&lt;/code&gt; will have one column of &lt;code&gt;seed&lt;/code&gt; values. These will serve a dual function. First, they are the values we’ll be feeding into the &lt;code&gt;seed&lt;/code&gt; argument of our custom data-generating function, &lt;code&gt;sim_d()&lt;/code&gt;. Second, since the &lt;code&gt;seed&lt;/code&gt; values serially increase, they also stand in as iteration indexes.&lt;/p&gt;
&lt;p&gt;For our second step, we add the data simulations and save them in a nested column, &lt;code&gt;d&lt;/code&gt;. In the first argument of the &lt;code&gt;purrr::map()&lt;/code&gt; function, we indicate we want to iterate over the values in &lt;code&gt;seed&lt;/code&gt;. In the second argument, we indicate we want to serially plug those &lt;code&gt;seed&lt;/code&gt; values into the first argument within the &lt;code&gt;sim_d()&lt;/code&gt; function. That argument, recall, is the well-named &lt;code&gt;seed&lt;/code&gt; argument. With the final argument in &lt;code&gt;map()&lt;/code&gt;, &lt;code&gt;n = 50&lt;/code&gt;, we hard code 50 into the &lt;code&gt;n&lt;/code&gt; argument of &lt;code&gt;sim_d()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For the third step, we expand our &lt;code&gt;purrr::map()&lt;/code&gt; skills from above to &lt;code&gt;purrr::map2()&lt;/code&gt;, which allows us to iteratively insert two arguments into a function. Within this paradigm, the two arguments are generically termed &lt;code&gt;.x&lt;/code&gt; and &lt;code&gt;.y&lt;/code&gt;. Thus our approach will be &lt;code&gt;.x = d, .y = seed&lt;/code&gt;. For our function, we specify &lt;code&gt;~update(fit, newdata = .x, seed = .y)&lt;/code&gt;. Thus we’ll be iteratively inserting our simulated &lt;code&gt;d&lt;/code&gt; data into the &lt;code&gt;newdata&lt;/code&gt; argument and will be simultaneously inserting our &lt;code&gt;seed&lt;/code&gt; values into the &lt;code&gt;seed&lt;/code&gt; argument.&lt;/p&gt;
&lt;p&gt;Also notice that the number of iterations we’ll be working with is determined by the number of rows in the &lt;code&gt;seed&lt;/code&gt; column. We are defining that number as &lt;code&gt;n_sim&lt;/code&gt;. Since this is just a blog post, I’m going to take it easy and use 100. But if this was a real power analysis for one of your projects, something like 1000 would be better.&lt;/p&gt;
&lt;p&gt;Finally, you don’t have to do this, but I’m timing my simulation by saving &lt;code&gt;Sys.time()&lt;/code&gt; values at the beginning and end of the simulation.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# how many simulations would you like?
n_sim &amp;lt;- 100

# this will help us track time
t1 &amp;lt;- Sys.time()

# here&amp;#39;s the main event!
s &amp;lt;-
  tibble(seed = 1:n_sim) %&amp;gt;% 
  mutate(d    = map(seed, sim_d, n = 50)) %&amp;gt;% 
  mutate(fit  = map2(d, seed, ~update(fit, newdata = .x, seed = .y)))

t2 &amp;lt;- Sys.time()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The entire simulation took just a couple minutes on my several-year-old laptop.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;t2 - t1&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Time difference of 1.952482 mins&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Your mileage may vary.&lt;/p&gt;
&lt;p&gt;Let’s take a look at what we’ve done.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;head(s)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 3
##    seed d                  fit      
##   &amp;lt;int&amp;gt; &amp;lt;list&amp;gt;             &amp;lt;list&amp;gt;   
## 1     1 &amp;lt;tibble [100 × 3]&amp;gt; &amp;lt;brmsfit&amp;gt;
## 2     2 &amp;lt;tibble [100 × 3]&amp;gt; &amp;lt;brmsfit&amp;gt;
## 3     3 &amp;lt;tibble [100 × 3]&amp;gt; &amp;lt;brmsfit&amp;gt;
## 4     4 &amp;lt;tibble [100 × 3]&amp;gt; &amp;lt;brmsfit&amp;gt;
## 5     5 &amp;lt;tibble [100 × 3]&amp;gt; &amp;lt;brmsfit&amp;gt;
## 6     6 &amp;lt;tibble [100 × 3]&amp;gt; &amp;lt;brmsfit&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In our 100-row nested tibble, we have all our simulated data sets in the &lt;code&gt;d&lt;/code&gt; column and all of our &lt;strong&gt;brms&lt;/strong&gt; fit objects nested in the &lt;code&gt;fit&lt;/code&gt; column. Next we’ll use &lt;code&gt;broom::tidy()&lt;/code&gt; and a little wrangling to extract the parameter of interest, &lt;code&gt;b_treatment&lt;/code&gt; (i.e., &lt;span class=&#34;math inline&#34;&gt;\(\beta_1\)&lt;/span&gt;), from each simulation.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;s %&amp;gt;% 
  mutate(treatment = map(fit, tidy, prob = .95)) %&amp;gt;% 
  unnest(treatment) %&amp;gt;% 
  filter(term == &amp;quot;b_treatment&amp;quot;) %&amp;gt;% 
  head()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 8
##    seed d               fit      term      estimate std.error   lower upper
##   &amp;lt;int&amp;gt; &amp;lt;list&amp;gt;          &amp;lt;list&amp;gt;   &amp;lt;chr&amp;gt;        &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
## 1     1 &amp;lt;tibble [100 ×… &amp;lt;brmsfi… b_treatm…    0.518     0.184  0.159  0.892
## 2     2 &amp;lt;tibble [100 ×… &amp;lt;brmsfi… b_treatm…    0.297     0.237 -0.176  0.765
## 3     3 &amp;lt;tibble [100 ×… &amp;lt;brmsfi… b_treatm…    0.641     0.178  0.296  0.982
## 4     4 &amp;lt;tibble [100 ×… &amp;lt;brmsfi… b_treatm…    0.224     0.178 -0.124  0.582
## 5     5 &amp;lt;tibble [100 ×… &amp;lt;brmsfi… b_treatm…    0.436     0.190  0.0560 0.796
## 6     6 &amp;lt;tibble [100 ×… &amp;lt;brmsfi… b_treatm…    0.300     0.206 -0.106  0.694&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As an aside, I know I’m moving kinda fast with all this wacky &lt;code&gt;purrr::map()&lt;/code&gt;/&lt;code&gt;purrr::map2()&lt;/code&gt; stuff. If you’re new to using the &lt;strong&gt;tidyverse&lt;/strong&gt; for iterating and saving the results in nested data structures, I recommend fixing an adult beverage and cozying up with Hadley Wickham’s presentation, &lt;a href=&#34;https://www.youtube.com/watch?v=rz3_FDVt9eg&#34;&gt;&lt;em&gt;Managing many models&lt;/em&gt;&lt;/a&gt;. And if you really hate it, both Kruschke and McElreath texts contain many examples of how to iterate in a more base &lt;strong&gt;R&lt;/strong&gt; sort of way.&lt;/p&gt;
&lt;p&gt;Anyway, here’s what those 100 &lt;span class=&#34;math inline&#34;&gt;\(\beta_1\)&lt;/span&gt; summaries look like in bulk.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;s %&amp;gt;% 
  mutate(treatment = map(fit, tidy, prob = .95)) %&amp;gt;% 
  unnest(treatment) %&amp;gt;% 
  filter(term == &amp;quot;b_treatment&amp;quot;) %&amp;gt;% 
  
  ggplot(aes(x = seed, y = estimate, ymin = lower, ymax = upper)) +
  geom_hline(yintercept = c(0, .5), color = &amp;quot;white&amp;quot;) +
  geom_pointrange(fatten = 1/2) +
  labs(x = &amp;quot;seed (i.e., simulation index)&amp;quot;,
       y = expression(beta[1]))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-07-18-bayesian-power-analysis-part-i_files/figure-html/unnamed-chunk-15-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The horizontal lines show the idealized effect size (0.5) and the null hypothesis (0). Already, it’s apparent that most of our intervals indicate there’s more than a 95% probability the null hypothesis is not credible. Several do. Here’s how to quantify that.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;s %&amp;gt;% 
  mutate(treatment = map(fit, tidy, prob = .95)) %&amp;gt;% 
  unnest(treatment) %&amp;gt;% 
  filter(term == &amp;quot;b_treatment&amp;quot;) %&amp;gt;% 
  mutate(check = ifelse(lower &amp;gt; 0, 1, 0)) %&amp;gt;% 
  summarise(power = mean(check))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1 x 1
##   power
##   &amp;lt;dbl&amp;gt;
## 1  0.67&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With the second &lt;code&gt;mutate()&lt;/code&gt; line, we used a logical statement within &lt;code&gt;ifelse()&lt;/code&gt; to code all instances where the lower limit of the 95% interval was greater than 0 as a 1, with the rest as 0. That left us with a vector of 1s and 0s, which we saved as &lt;code&gt;check&lt;/code&gt;. In the &lt;code&gt;summarise()&lt;/code&gt; line, we took the mean of that column, which returned our Bayesian power estimate.&lt;/p&gt;
&lt;p&gt;That is, in 67 of our 100 simulations, an &lt;span class=&#34;math inline&#34;&gt;\(n = 50\)&lt;/span&gt; per group was enough to produce a 95% Bayesian credible interval that did not straddle 0.&lt;/p&gt;
&lt;p&gt;I should probably point out that a 95% interval for which &lt;code&gt;upper &amp;lt; 0&lt;/code&gt; would have also been consistent with the alternative hypothesis of &lt;span class=&#34;math inline&#34;&gt;\(\mu_c \neq \mu_t\)&lt;/span&gt;. However, I didn’t bother to work that option into the definition of our &lt;code&gt;check&lt;/code&gt; variable because I knew from the outset that that would be a highly unlikely result. But if you’d like to work more rigor into your checks, by all means do.&lt;/p&gt;
&lt;p&gt;And if you’ve gotten this far and have been following along with code of your own, congratulations! You did it! You’ve estimated the power of a Bayesian model with a given &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt;. Now let’s refine our approach.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;version-2-we-might-should-be-more-careful-with-memory.&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Version 2: We might should be more careful with memory.&lt;/h3&gt;
&lt;p&gt;I really like it that our &lt;code&gt;s&lt;/code&gt; object contains all our &lt;code&gt;brm()&lt;/code&gt; fits. It makes it really handy to do global diagnostics like making sure our &lt;span class=&#34;math inline&#34;&gt;\(\hat R\)&lt;/span&gt; values are all within a respectable range.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;s %&amp;gt;% 
  mutate(rhat = map(fit, rhat)) %&amp;gt;% 
  unnest(rhat) %&amp;gt;% 
  
  ggplot(aes(x = rhat)) +
  geom_histogram(bins = 20)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-07-18-bayesian-power-analysis-part-i_files/figure-html/unnamed-chunk-17-1.png&#34; width=&#34;288&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Man those &lt;span class=&#34;math inline&#34;&gt;\(\hat R\)&lt;/span&gt; values look sweet. It’s great to have a workflow that lets you check them. But holding on to all those fits can take up a lot of memory. If the only thing you’re interested in are the parameter summaries, a better approach might be to do the model refitting and parameter extraction in one step. That way you only save the parameter summaries. Here’s how you might do that.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;t3 &amp;lt;- Sys.time()

s2 &amp;lt;-
  tibble(seed = 1:n_sim) %&amp;gt;% 
  mutate(d    = map(seed, sim_d, n = 50)) %&amp;gt;% 
  # here&amp;#39;s the new part
  mutate(tidy = map2(d, seed, ~update(fit, newdata = .x, seed = .y) %&amp;gt;% 
                       tidy(prob = .95) %&amp;gt;% 
                       filter(term == &amp;quot;b_treatment&amp;quot;)))

t4 &amp;lt;- Sys.time()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Like before, this only took a couple minutes.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;t4 - t3&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Time difference of 1.713578 mins&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As a point of comparison, here are the sizes of the results from our first approach to those from the second.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;object.size(s)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 79664720 bytes&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;object.size(s2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 502320 bytes&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That’s a big difference. Hopefully you get the idea. With more complicated models and 10+ times the number of simulations, size will eventually matter.&lt;/p&gt;
&lt;p&gt;Anyway, here are the results.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;s2 %&amp;gt;% 
  unnest(tidy) %&amp;gt;% 

  ggplot(aes(x = seed, y = estimate, ymin = lower, ymax = upper)) +
  geom_hline(yintercept = c(0, .5), color = &amp;quot;white&amp;quot;) +
  geom_pointrange(fatten = 1/2) +
  labs(x = &amp;quot;seed (i.e., simulation index)&amp;quot;,
       y = expression(beta[1]))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-07-18-bayesian-power-analysis-part-i_files/figure-html/unnamed-chunk-20-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Same parameter summaries, lower memory burden.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;version-3-still-talking-about-memory-we-can-be-even-stingier.&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Version 3: Still talking about memory, we can be even stingier.&lt;/h3&gt;
&lt;p&gt;So far, both of our simulation attempts resulted in our saving the simulated data sets. It’s a really nice option if you ever want to go back and take a look at those simulated data. For example, you might want to inspect a random subset of the data simulations with box plots.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(1)

s2 %&amp;gt;% 
  sample_n(12) %&amp;gt;% 
  unnest(d) %&amp;gt;% 
  
  ggplot(aes(x = group, y = y)) +
  geom_boxplot(aes(fill = group), 
               alpha = 2/3, show.legend = F) +
  scale_fill_manual(values = c(&amp;quot;grey25&amp;quot;, &amp;quot;blue2&amp;quot;)) +
  xlab(NULL) +
  facet_wrap(~seed)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-07-18-bayesian-power-analysis-part-i_files/figure-html/unnamed-chunk-21-1.png&#34; width=&#34;576&#34; /&gt;&lt;/p&gt;
&lt;p&gt;In this case, it’s no big deal if we keep the data around or not. The data sets are fairly small and we’re only simulating 100 of them. But in cases where the data are larger and you’re doing 1000s of simulations, keeping the data could become a memory drain.&lt;/p&gt;
&lt;p&gt;If you’re willing to forgo the luxury of inspecting your data simulations, it might make sense to run our power analysis in a way that avoids saving them. One way to do so would be to just wrap the data simulation and model fitting all in one function. We’ll call it &lt;code&gt;sim_d_and_fit()&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sim_d_and_fit &amp;lt;- function(seed, n) {
  
  mu_t &amp;lt;- .5
  mu_c &amp;lt;- 0
  
  set.seed(seed)
  
  d &amp;lt;-
    tibble(group     = rep(c(&amp;quot;control&amp;quot;, &amp;quot;treatment&amp;quot;), each = n)) %&amp;gt;% 
    mutate(treatment = ifelse(group == &amp;quot;control&amp;quot;, 0, 1),
           y         = ifelse(group == &amp;quot;control&amp;quot;, 
                              rnorm(n, mean = mu_c, sd = 1),
                              rnorm(n, mean = mu_t, sd = 1)))
  
  update(fit,
         newdata = d, 
         seed = seed) %&amp;gt;% 
    tidy(prob = .95) %&amp;gt;% 
    filter(term == &amp;quot;b_treatment&amp;quot;)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now iterate 100 times once more.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;t5 &amp;lt;- Sys.time()

s3 &amp;lt;-
  tibble(seed = 1:n_sim) %&amp;gt;% 
  mutate(tidy = map(seed, sim_d_and_fit, n = 50)) %&amp;gt;% 
  unnest(tidy)

t6 &amp;lt;- Sys.time()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That was pretty quick.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;t6 - t5&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Time difference of 1.612013 mins&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here’s what it returned.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;head(s3)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 6
##    seed term        estimate std.error   lower upper
##   &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt;          &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
## 1     1 b_treatment    0.518     0.184  0.159  0.892
## 2     2 b_treatment    0.297     0.237 -0.176  0.765
## 3     3 b_treatment    0.641     0.178  0.296  0.982
## 4     4 b_treatment    0.224     0.178 -0.124  0.582
## 5     5 b_treatment    0.436     0.190  0.0560 0.796
## 6     6 b_treatment    0.300     0.206 -0.106  0.694&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By wrapping our data simulation, model fitting, and parameter extraction steps all in one function, we simplified the output such that we’re no longer holding on to the data simulations or the &lt;strong&gt;brms&lt;/strong&gt; fit objects. We just have the parameter summaries and the &lt;code&gt;seed&lt;/code&gt;, making the product even smaller.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;object.size(s)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 79664720 bytes&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;object.size(s2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 502320 bytes&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;object.size(s3)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 5944 bytes&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But the primary results are the same.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;s3 %&amp;gt;% 
  ggplot(aes(x = seed, y = estimate, ymin = lower, ymax = upper)) +
  geom_hline(yintercept = c(0, .5), color = &amp;quot;white&amp;quot;) +
  geom_pointrange(fatten = 1/2) +
  labs(x = &amp;quot;seed (i.e., simulation index)&amp;quot;,
       y = expression(beta[1]))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-07-18-bayesian-power-analysis-part-i_files/figure-html/unnamed-chunk-26-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;p&gt;We still get the same power estimate, too.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;s3 %&amp;gt;% 
  mutate(check = ifelse(lower &amp;gt; 0, 1, 0)) %&amp;gt;% 
  summarise(power = mean(check))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1 x 1
##   power
##   &amp;lt;dbl&amp;gt;
## 1  0.67&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;next-steps&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Next steps&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;But my goal was to figure out what &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; will get me power of .8 or more!&lt;/em&gt;, you say. Fair enough. Try increasing &lt;code&gt;n&lt;/code&gt; to 65 or something.&lt;/p&gt;
&lt;p&gt;If that seems unsatisfying, welcome to the world of simulation. Since our Bayesian models are complicated, we don’t have the luxury of plugging a few values into some quick power formula. Just as simulation is an iterative process, determining on the right values to simulate over might well be an iterative process, too.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;wrap-up&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Wrap-up&lt;/h2&gt;
&lt;p&gt;Anyway, that’s the essence of the &lt;strong&gt;brms/tidyverse&lt;/strong&gt; workflow for Bayesian power analysis. You follow these steps:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Determine your primary data type.&lt;/li&gt;
&lt;li&gt;Determine your primary regression model and parameter(s) of interest.&lt;/li&gt;
&lt;li&gt;Pick defensible priors for all parameters–the kinds of priors you intend to use once you have the real data in hand.&lt;/li&gt;
&lt;li&gt;Select a sample size.&lt;/li&gt;
&lt;li&gt;Fit an initial model and save the fit object.&lt;/li&gt;
&lt;li&gt;Simulate some large number of data sets all following your prechosen form and use the &lt;code&gt;update()&lt;/code&gt; function to iteratively fit the models.&lt;/li&gt;
&lt;li&gt;Extract the parameter(s) of interest.&lt;/li&gt;
&lt;li&gt;Summarize.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In addition, we played with a few approaches based on logistical concerns like memory. In the next post, part II, we’ll see how the precision-oriented approach to sample-size planning is a viable alternative to power focused on rejecting null hypotheses.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;i-had-help.&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;I had help.&lt;/h2&gt;
&lt;p&gt;Special thanks to Christopher Peters (&lt;a href=&#34;https://github.com/statwonk&#34;&gt;@statwonk&lt;/a&gt;) for the helpful edits and suggestions.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;session-info&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Session info&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sessionInfo()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## R version 3.6.0 (2019-04-26)
## Platform: x86_64-apple-darwin15.6.0 (64-bit)
## Running under: macOS High Sierra 10.13.6
## 
## Matrix products: default
## BLAS:   /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRblas.0.dylib
## LAPACK: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRlapack.dylib
## 
## locale:
## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
##  [1] broom_0.5.2     brms_2.10.0     Rcpp_1.0.2      forcats_0.4.0  
##  [5] stringr_1.4.0   dplyr_0.8.3     purrr_0.3.2     readr_1.3.1    
##  [9] tidyr_1.0.0     tibble_2.1.3    ggplot2_3.2.1   tidyverse_1.2.1
## 
## loaded via a namespace (and not attached):
##  [1] nlme_3.1-139          matrixStats_0.54.0    xts_0.11-2           
##  [4] lubridate_1.7.4       threejs_0.3.1         httr_1.4.0           
##  [7] rstan_2.19.2          tools_3.6.0           backports_1.1.4      
## [10] utf8_1.1.4            R6_2.4.0              DT_0.7               
## [13] lazyeval_0.2.2        colorspace_1.4-1      withr_2.1.2          
## [16] prettyunits_1.0.2     processx_3.3.1        tidyselect_0.2.5     
## [19] gridExtra_2.3         Brobdingnag_1.2-6     compiler_3.6.0       
## [22] cli_1.1.0             rvest_0.3.4           xml2_1.2.0           
## [25] shinyjs_1.0           labeling_0.3          colourpicker_1.0     
## [28] bookdown_0.12         scales_1.0.0          dygraphs_1.1.1.6     
## [31] mvtnorm_1.0-11        callr_3.2.0           ggridges_0.5.1       
## [34] StanHeaders_2.18.1-10 digest_0.6.20         rmarkdown_1.13       
## [37] base64enc_0.1-3       pkgconfig_2.0.2       htmltools_0.3.6      
## [40] htmlwidgets_1.3       rlang_0.4.0           readxl_1.3.1         
## [43] rstudioapi_0.10       shiny_1.3.2           generics_0.0.2       
## [46] zoo_1.8-6             jsonlite_1.6          crosstalk_1.0.0      
## [49] gtools_3.8.1          inline_0.3.15         magrittr_1.5         
## [52] loo_2.1.0             bayesplot_1.7.0       Matrix_1.2-17        
## [55] fansi_0.4.0           munsell_0.5.0         abind_1.4-5          
## [58] lifecycle_0.1.0       stringi_1.4.3         yaml_2.2.0           
## [61] pkgbuild_1.0.3        plyr_1.8.4            grid_3.6.0           
## [64] parallel_3.6.0        promises_1.0.1        crayon_1.3.4         
## [67] miniUI_0.1.1.1        lattice_0.20-38       haven_2.1.0          
## [70] hms_0.4.2             ps_1.3.0              zeallot_0.1.0        
## [73] knitr_1.23            pillar_1.4.2          igraph_1.2.4.1       
## [76] markdown_1.0          shinystan_2.5.0       stats4_3.6.0         
## [79] reshape2_1.4.3        rstantools_1.5.1      glue_1.3.1           
## [82] evaluate_0.14         blogdown_0.14         modelr_0.1.4         
## [85] vctrs_0.2.0           httpuv_1.5.1          cellranger_1.1.0     
## [88] gtable_0.3.0          assertthat_0.2.1      xfun_0.8             
## [91] mime_0.7              xtable_1.8-4          coda_0.19-2          
## [94] later_0.8.0           rsconnect_0.8.13      shinythemes_1.1.2    
## [97] bridgesampling_0.6-0&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# for the hard-core scrollers:
# if you increase n to 65, the power becomes about .84
n_sim &amp;lt;- 100

t7 &amp;lt;- Sys.time()

s4 &amp;lt;-
  tibble(seed = 1:n_sim) %&amp;gt;% 
  mutate(tidy = map(seed, sim_d_and_fit, n = 65))

t8 &amp;lt;- Sys.time()

t8 - t7

object.size(s4)

s4 %&amp;gt;% 
  unnest(tidy) %&amp;gt;% 
  mutate(check = ifelse(lower &amp;gt; 0, 1, 0)) %&amp;gt;% 
  summarise(power = mean(check))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Would you like all your posteriors in one plot?</title>
      <link>/post/would-you-like-all-your-posteriors-in-one-plot/</link>
      <pubDate>Sat, 13 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/would-you-like-all-your-posteriors-in-one-plot/</guid>
      <description>&lt;p&gt;A colleague reached out to me earlier this week with a plotting question. They had fit a series of Bayesian models, all containing a common parameter of interest. They knew how to plot their focal parameter one model at a time, but were stumped on how to combine the plots across models into a seamless whole. It reminded me a bit of this gif&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://media.giphy.com/media/Bqn8Z7xdPCFy0/giphy.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;which I originally got from &lt;a href=&#34;https://twitter.com/JennyBryan&#34;&gt;Jenny Bryan&lt;/a&gt;’s great talk, &lt;a href=&#34;https://www.youtube.com/watch?v=4MfUCX_KpdE&#34;&gt;&lt;em&gt;Behind every great plot there’s a great deal of wrangling&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The goal of this post is to provide solutions. We’ll practice a few different ways you can combine the posterior samples from your Bayesian models into a single plot. As usual, we’ll be fitting our models with &lt;a href=&#34;https://github.com/paul-buerkner/brms&#34;&gt;&lt;strong&gt;brms&lt;/strong&gt;&lt;/a&gt;, wrangling with packages from the &lt;a href=&#34;https://www.tidyverse.org&#34;&gt;&lt;strong&gt;tidyverse&lt;/strong&gt;&lt;/a&gt;, and getting a little help from the &lt;a href=&#34;https://mjskay.github.io/tidybayes/index.html&#34;&gt;&lt;strong&gt;tidybayes&lt;/strong&gt; package&lt;/a&gt;.&lt;/p&gt;
&lt;div id=&#34;i-make-assumptions.&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;I make assumptions.&lt;/h2&gt;
&lt;p&gt;For this post, I’m presuming you are familiar Bayesian regression using &lt;strong&gt;brms.&lt;/strong&gt; I’m also assuming you’ve coded using some of the foundational functions from the &lt;strong&gt;tidyverse.&lt;/strong&gt; If you’d like to firm up your foundations a bit, check out these resources.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;To learn about Bayesian regression, I recommend the introductory text books by either McElreath (&lt;a href=&#34;(%5Bhere%5D())&#34;&gt;here&lt;/a&gt;) or Kruschke (&lt;a href=&#34;http://www.indiana.edu/~kruschke/DoingBayesianDataAnalysis/&#34;&gt;here&lt;/a&gt;). Both authors host blogs (&lt;a href=&#34;http://doingbayesiandataanalysis.blogspot.com&#34;&gt;here&lt;/a&gt; and &lt;a href=&#34;http://elevanth.org/blog/&#34;&gt;here&lt;/a&gt;, respectively). If you go with McElreath, do check out his &lt;a href=&#34;https://www.youtube.com/channel/UCNJK6_DZvcMqNSzQdEkzvzA/playlists&#34;&gt;online lectures&lt;/a&gt; and &lt;a href=&#34;https://bookdown.org/connect/#/apps/1850/access&#34;&gt;my project&lt;/a&gt; translating his text to &lt;strong&gt;brms&lt;/strong&gt; and &lt;strong&gt;tidyverse&lt;/strong&gt; code. I’m working on a &lt;a href=&#34;https://github.com/ASKurz/Doing-Bayesian-Data-Analysis-in-brms-and-the-tidyverse&#34;&gt;similar project&lt;/a&gt; for Kruschke’s text, but it still has a ways to go before I release it in full.&lt;/li&gt;
&lt;li&gt;For even more &lt;strong&gt;brms&lt;/strong&gt;-related resources, you can find vignettes and documentation &lt;a href=&#34;https://cran.r-project.org/web/packages/brms/index.html&#34;&gt;here&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;For &lt;strong&gt;tidyverse&lt;/strong&gt; introductions, your best bets are &lt;a href=&#34;https://r4ds.had.co.nz&#34;&gt;&lt;em&gt;R4DS&lt;/em&gt;&lt;/a&gt; and &lt;a href=&#34;https://style.tidyverse.org&#34;&gt;&lt;em&gt;The tidyverse style guide&lt;/em&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;same-parameter-different-models&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Same parameter, different models&lt;/h2&gt;
&lt;p&gt;Let’s load our primary statistical packages.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidyverse)
library(brms)
library(tidybayes)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Simulate &lt;span class=&#34;math inline&#34;&gt;\(n = 150\)&lt;/span&gt; draws from the standard normal distribution.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;n &amp;lt;- 150

set.seed(1)
d &amp;lt;-
  tibble(y = rnorm(n, mean = 0, sd = 1))

head(d)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 1
##        y
##    &amp;lt;dbl&amp;gt;
## 1 -0.626
## 2  0.184
## 3 -0.836
## 4  1.60 
## 5  0.330
## 6 -0.820&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here we’ll fit three intercept-only models for &lt;code&gt;y&lt;/code&gt;. Each will follow the form&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{align*}
y_i     &amp;amp; \sim \text{Normal} (\mu, \sigma) \\
\mu     &amp;amp; = \beta_0 \\
\beta_0 &amp;amp; \sim \text{Normal} (0, x) \\
\sigma  &amp;amp; \sim \text{Student-t}(3, 0, 10)
\end{align*}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;where &lt;span class=&#34;math inline&#34;&gt;\(\beta_0\)&lt;/span&gt; is the unconditional intercept (i.e., an intercept not conditioned on any predictors). We will be fitting three alternative models. All will have the same prior for &lt;span class=&#34;math inline&#34;&gt;\(\sigma\)&lt;/span&gt;, &lt;span class=&#34;math inline&#34;&gt;\(\text{Student-t}(3, 0, 10)\)&lt;/span&gt;, which is the &lt;strong&gt;brms&lt;/strong&gt; default in this case. [If you’d like to check, use the &lt;code&gt;get_prior()&lt;/code&gt; function.] The only way the models will differ is by their prior on the intercept &lt;span class=&#34;math inline&#34;&gt;\(\beta_0\)&lt;/span&gt;. By model, those priors will be&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fit1&lt;/code&gt;: &lt;span class=&#34;math inline&#34;&gt;\(\beta_0 \sim \text{Normal} (0, 10)\)&lt;/span&gt;,&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fit2&lt;/code&gt;: &lt;span class=&#34;math inline&#34;&gt;\(\beta_0 \sim \text{Normal} (0, 1)\)&lt;/span&gt;, and&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fit3&lt;/code&gt;: &lt;span class=&#34;math inline&#34;&gt;\(\beta_0 \sim \text{Normal} (0, 0.1)\)&lt;/span&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So if you were wondering, the &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; in the &lt;span class=&#34;math inline&#34;&gt;\(\beta_0 \sim \text{Normal} (0, x)\)&lt;/span&gt; line, above, was a stand-in for the varying &lt;a href=&#34;https://en.wikipedia.org/wiki/Hyperparameter&#34;&gt;hyperparameter&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Here we fit the models in bulk.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fit1 &amp;lt;-
  brm(data = d,
      family = gaussian,
      y ~ 1,
      prior(normal(0, 10), class = Intercept),
      seed = 1)

fit2 &amp;lt;-
  update(fit1,
         prior = prior(normal(0, 1), class = Intercept),
         seed = 1)

fit3 &amp;lt;-
  update(fit1,
         prior = prior(normal(0, 0.1), class = Intercept),
         seed = 1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Normally we’d use &lt;code&gt;plot()&lt;/code&gt; to make sure the chains look good and then use something like &lt;code&gt;print()&lt;/code&gt; or &lt;code&gt;posterior_summary()&lt;/code&gt; to summarize the models’ results. I’ve checked and they’re all fine. For the sake of space, let’s press forward.&lt;/p&gt;
&lt;p&gt;If you were going to plot the results of an individual fit using something like the &lt;code&gt;tidybayes::geom_halfeyeh()&lt;/code&gt; function, the next step would be extracting the posterior draws. Here we’ll do so with the &lt;code&gt;brms::posterior_samples()&lt;/code&gt; function.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;post1 &amp;lt;- posterior_samples(fit1)
post2 &amp;lt;- posterior_samples(fit2)
post3 &amp;lt;- posterior_samples(fit3)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Focusing on &lt;code&gt;fit1&lt;/code&gt;, here’s how we’d plot the results for the intercept &lt;span class=&#34;math inline&#34;&gt;\(\beta_0\)&lt;/span&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# this part is unnecessary; it just adjusts some theme defaults to my liking
theme_set(theme_gray() +
            theme(axis.text.y  = element_text(hjust = 0),
                  axis.ticks.y = element_blank(),
                  panel.grid   = element_blank()))

# plot!
post1 %&amp;gt;% 
  ggplot(aes(x = b_Intercept, y = 0)) +
  geom_halfeyeh() +
  scale_y_continuous(NULL, breaks = NULL)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-07-13-would-you-like-all-your-posteriors-in-one-plot_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;480&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;But how might we get the posterior draws from all three fits into one plot?&lt;/em&gt; The answer is by somehow combining the posterior draws from each into one data frame. There are many ways to do this. Perhaps the simplest is with the &lt;code&gt;bind_rows()&lt;/code&gt; function.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;posts &amp;lt;-
  bind_rows(
    post1,
    post2,
    post3
  ) %&amp;gt;% 
  mutate(prior = str_c(&amp;quot;normal(0, &amp;quot;, c(10, 1, 0.1), &amp;quot;)&amp;quot;) %&amp;gt;% rep(., each = 4000))

head(posts)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    b_Intercept     sigma      lp__         prior
## 1 -0.052176422 0.8568091 -204.1751 normal(0, 10)
## 2  0.124990457 0.8983495 -204.1663 normal(0, 10)
## 3 -0.006294612 0.9475288 -203.5528 normal(0, 10)
## 4  0.060904410 0.9410559 -203.5319 normal(0, 10)
## 5  0.177594575 0.9457762 -205.4991 normal(0, 10)
## 6  0.134879573 0.9267331 -204.3765 normal(0, 10)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;bind_rows()&lt;/code&gt; function worked well, here, because all three post objects had the same number of columns of the same names. So we just stacked them three high. That is, we went from three data objects of 4,000 rows and 3 columns to one data object with 12,000 rows and 3 columns. But with the &lt;code&gt;mutate()&lt;/code&gt; function we did add a fourth column, &lt;code&gt;prior&lt;/code&gt;, that indexed which model each row came from. Now our data are ready, we can plot.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;posts %&amp;gt;% 
  ggplot(aes(x = b_Intercept, y = prior)) +
  geom_halfeyeh()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-07-13-would-you-like-all-your-posteriors-in-one-plot_files/figure-html/unnamed-chunk-8-1.png&#34; width=&#34;576&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Our plot arrangement made it easy to compare the results of tightening the prior on &lt;span class=&#34;math inline&#34;&gt;\(\beta_0\)&lt;/span&gt;; the narrower the prior, the narrower the posterior.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;what-if-my-posterior_samples-arent-of-the-same-dimensions-across-models&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;What if my &lt;code&gt;posterior_samples()&lt;/code&gt; aren’t of the same dimensions across models?&lt;/h2&gt;
&lt;p&gt;For the next examples, we need new data. Here we’ll simulate three predictors–&lt;code&gt;x1&lt;/code&gt;, &lt;code&gt;x2&lt;/code&gt;, and &lt;code&gt;x3&lt;/code&gt;. We then simulate our criterion &lt;code&gt;y&lt;/code&gt; as a linear additive function of those predictors.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(1)
d &amp;lt;-
  tibble(x1 = rnorm(n, mean = 0, sd = 1),
         x2 = rnorm(n, mean = 0, sd = 1),
         x3 = rnorm(n, mean = 0, sd = 1)) %&amp;gt;% 
  mutate(y  = rnorm(n, mean = 0 + x1 * 0 + x2 * 0.2 + x3 * -0.4))

head(d)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 4
##       x1      x2     x3      y
##    &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
## 1 -0.626  0.450   0.894  0.694
## 2  0.184 -0.0186 -1.05  -0.189
## 3 -0.836 -0.318   1.97  -1.61 
## 4  1.60  -0.929  -0.384 -1.59 
## 5  0.330 -1.49    1.65  -2.41 
## 6 -0.820 -1.08    1.51  -0.764&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We are going to work with these data in two ways. For the first example, we’ll fit a series of univariable models following the same basic form, but each with a different predictor. For the second example, we’ll fit a series of multivariable models with various combinations of the predictors. Each requires its own approach.&lt;/p&gt;
&lt;div id=&#34;same-form-different-predictors.&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Same form, different predictors.&lt;/h3&gt;
&lt;p&gt;This time we’re just using the &lt;strong&gt;brms&lt;/strong&gt; default priors. As such, the models all follow the form&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{align*}
y_i     &amp;amp; \sim \text{Normal} (\mu_i, \sigma) \\
\mu_i   &amp;amp; = \beta_0 + \beta_n x_n\\
\beta_0 &amp;amp; \sim \text{Student-t}(3, 0, 10) \\
\sigma  &amp;amp; \sim \text{Student-t}(3, 0, 10)
\end{align*}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;You may be wondering &lt;em&gt;What about the prior for&lt;/em&gt; &lt;span class=&#34;math inline&#34;&gt;\(\beta_n\)&lt;/span&gt;&lt;em&gt;?&lt;/em&gt; The &lt;strong&gt;brms&lt;/strong&gt; defaults for those are improper flat priors. We define &lt;span class=&#34;math inline&#34;&gt;\(\beta_n x_n\)&lt;/span&gt; for the next three models as&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fit4&lt;/code&gt;: &lt;span class=&#34;math inline&#34;&gt;\(\beta_1 x_1\)&lt;/span&gt;,&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fit5&lt;/code&gt;: &lt;span class=&#34;math inline&#34;&gt;\(\beta_2 x_2\)&lt;/span&gt;, and&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fit5&lt;/code&gt;: &lt;span class=&#34;math inline&#34;&gt;\(\beta_3 x_3\)&lt;/span&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let’s fit the models.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fit4 &amp;lt;-
  brm(data = d,
      family = gaussian,
      y ~ 1 + x1,
      seed = 1)

fit5 &amp;lt;-
  update(fit4,
         newdata = d,
         y ~ 1 + x2,
         seed = 1)

fit6 &amp;lt;-
  update(fit4,
         newdata = d,
         y ~ 1 + x3,
         seed = 1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Like before, save the posterior draws for each as separate data frames.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;post4 &amp;lt;- posterior_samples(fit4)
post5 &amp;lt;- posterior_samples(fit5)
post6 &amp;lt;- posterior_samples(fit6)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This time, our simple &lt;code&gt;bind_rows()&lt;/code&gt; trick won’t work well.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;bind_rows(
  post4,
  post5,
  post6
) %&amp;gt;% 
  head()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    b_Intercept         b_x1    sigma      lp__ b_x2 b_x3
## 1  0.167513067 -0.179568244 1.154730 -243.4799   NA   NA
## 2 -0.017092084 -0.281401589 1.145705 -243.1930   NA   NA
## 3 -0.036944855 -0.204756757 1.191577 -242.1853   NA   NA
## 4  0.041075341 -0.009902425 1.183252 -242.0840   NA   NA
## 5  0.032423912 -0.050100545 1.147125 -241.8424   NA   NA
## 6  0.003649314 -0.161764444 1.183537 -241.7794   NA   NA&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We don’t want separate columns for &lt;code&gt;b_x1&lt;/code&gt;, &lt;code&gt;b_x2&lt;/code&gt;, and &lt;code&gt;b_x3&lt;/code&gt;. We want them all stacked atop one another. One simple solution is a two-step wherein we (1) select the relevant columns from each and bind them together with &lt;code&gt;bind_cols()&lt;/code&gt; and then (2) stack them atop one another with the &lt;code&gt;gather()&lt;/code&gt; function.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;posts &amp;lt;-
  bind_cols(
    post4 %&amp;gt;% select(b_x1),
    post5 %&amp;gt;% select(b_x2),
    post6 %&amp;gt;% select(b_x3)
  ) %&amp;gt;% 
  gather() %&amp;gt;% 
  mutate(predictor = str_remove(key, &amp;quot;b_&amp;quot;))

head(posts)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    key        value predictor
## 1 b_x1 -0.179568244        x1
## 2 b_x1 -0.281401589        x1
## 3 b_x1 -0.204756757        x1
## 4 b_x1 -0.009902425        x1
## 5 b_x1 -0.050100545        x1
## 6 b_x1 -0.161764444        x1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That &lt;code&gt;mutate()&lt;/code&gt; line at the end wasn’t necessary, but it will make the plot more attractive.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;posts %&amp;gt;% 
  ggplot(aes(x = value, y = predictor)) +
  geom_halfeyeh()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-07-13-would-you-like-all-your-posteriors-in-one-plot_files/figure-html/unnamed-chunk-14-1.png&#34; width=&#34;576&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;different-combinations-of-predictors-in-different-forms.&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Different combinations of predictors in different forms.&lt;/h3&gt;
&lt;p&gt;Now we fit a series of multivariable models. The first three will have combinations of two of the predictors. The final model will have all three. For simplicity, we continue to use the &lt;strong&gt;brms&lt;/strong&gt; default priors.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fit7 &amp;lt;-
  brm(data = d,
      family = gaussian,
      y ~ 1 + x1 + x2,
      seed = 1)

fit8 &amp;lt;-
  update(fit7,
         newdata = d,
         y ~ 1 + x1 + x3,
         seed = 1)

fit9 &amp;lt;-
  update(fit7,
         newdata = d,
         y ~ 1 + x2 + x3,
         seed = 1)

fit10 &amp;lt;-
  update(fit7,
         newdata = d,
         y ~ 1 + x1 + x2 + x3,
         seed = 1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Individually extract the posterior draws.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;post7  &amp;lt;- posterior_samples(fit7)
post8  &amp;lt;- posterior_samples(fit8)
post9  &amp;lt;- posterior_samples(fit9)
post10 &amp;lt;- posterior_samples(fit10)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Take a look at what happens this time when we use the &lt;code&gt;bind_rows()&lt;/code&gt; approach.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;posts &amp;lt;-
  bind_rows(
    post7,
    post8,
    post9,
    post10
  ) 

glimpse(posts)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Observations: 16,000
## Variables: 6
## $ b_Intercept &amp;lt;dbl&amp;gt; 0.09509318, 0.08186866, 0.02571336, -0.18844144, -0.06763395, 0.06137342, 0.0…
## $ b_x1        &amp;lt;dbl&amp;gt; -0.117031758, 0.004563560, -0.129202123, -0.125793634, -0.041442345, -0.02864…
## $ b_x2        &amp;lt;dbl&amp;gt; 0.19180539, 0.19254784, 0.31151419, 0.33083881, 0.08777655, 0.32273994, 0.158…
## $ sigma       &amp;lt;dbl&amp;gt; 1.118284, 1.122873, 1.159854, 1.108438, 1.041766, 1.214929, 1.220967, 1.28653…
## $ lp__        &amp;lt;dbl&amp;gt; -239.1799, -239.4599, -238.7769, -240.8443, -241.7296, -239.6411, -239.5687, …
## $ b_x3        &amp;lt;dbl&amp;gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We still have the various data frames stacked atop another, with the data from &lt;code&gt;post7&lt;/code&gt; in the first 4,000 rows. See how the values in the &lt;code&gt;b_x3&lt;/code&gt; column are all missing (i.e., filled with &lt;code&gt;NA&lt;/code&gt; values)? That’s because &lt;code&gt;fit7&lt;/code&gt; didn’t contain &lt;code&gt;x3&lt;/code&gt; as a predictor. Similarly, if we were to look at rows 4,001 through 8,000, we’d see column &lt;code&gt;b_x2&lt;/code&gt; would be the one filled with &lt;code&gt;NA&lt;/code&gt;s. This behavior is a good thing, here. After a little more wrangling, we’ll plot and it should be become clear why. Here’s the wrangling.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;posts &amp;lt;-
  posts %&amp;gt;% 
  select(starts_with(&amp;quot;b_x&amp;quot;)) %&amp;gt;% 
  mutate(contains = rep(c(&amp;quot;&amp;lt;1, 1, 0&amp;gt;&amp;quot;, &amp;quot;&amp;lt;1, 0, 1&amp;gt;&amp;quot;, &amp;quot;&amp;lt;0, 1, 1&amp;gt;&amp;quot;, &amp;quot;&amp;lt;1, 1, 1&amp;gt;&amp;quot;), each = 4000)) %&amp;gt;% 
  gather(key, value, -contains) %&amp;gt;% 
  mutate(coefficient = str_remove(key, &amp;quot;b_x&amp;quot;) %&amp;gt;% str_c(&amp;quot;beta[&amp;quot;, ., &amp;quot;]&amp;quot;))

head(posts)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    contains  key       value coefficient
## 1 &amp;lt;1, 1, 0&amp;gt; b_x1 -0.11703176     beta[1]
## 2 &amp;lt;1, 1, 0&amp;gt; b_x1  0.00456356     beta[1]
## 3 &amp;lt;1, 1, 0&amp;gt; b_x1 -0.12920212     beta[1]
## 4 &amp;lt;1, 1, 0&amp;gt; b_x1 -0.12579363     beta[1]
## 5 &amp;lt;1, 1, 0&amp;gt; b_x1 -0.04144234     beta[1]
## 6 &amp;lt;1, 1, 0&amp;gt; b_x1 -0.02864308     beta[1]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With the &lt;code&gt;contains&lt;/code&gt; variable, we indexed which fit the draws came from. The 1s and 0s within the angle brackets indicate which of the three predictors were present within the model with the 1s indicating they were and the 0s indicating they were not. For example, &lt;code&gt;&amp;lt;1, 1, 0&amp;gt;&lt;/code&gt; in the first row indicated this was the model including &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;. Importantly, we also added a &lt;code&gt;coefficient&lt;/code&gt; index. This is just a variant of &lt;code&gt;key&lt;/code&gt; that’ll make the strip labels in our plot more attractive. Behold:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;posts %&amp;gt;% 
  ggplot(aes(x = value, y = contains)) +
  geom_halfeyeh() +
  ylab(NULL) +
  facet_wrap(~coefficient, ncol = 1, labeller = label_parsed)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-07-13-would-you-like-all-your-posteriors-in-one-plot_files/figure-html/unnamed-chunk-18-1.png&#34; width=&#34;576&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Hopefully now it’s clear why it was good to save those cells with the &lt;code&gt;NA&lt;/code&gt;s.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;bonus-you-can-streamline-your-workflow.&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Bonus: You can streamline your workflow.&lt;/h2&gt;
&lt;p&gt;The workflows above are generally fine. But they’re a little inefficient. If you’d like to reduce the amount of code you’re writing and the number of objects you have floating around in your environment, you might consider a more streamlined workflow where you work with your fit objects in bulk. Here we’ll demonstrate a nested tibble approach with the first three fits.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;posts &amp;lt;-
  tibble(name  = str_c(&amp;quot;fit&amp;quot;, 1:3),
         prior = str_c(&amp;quot;normal(0, &amp;quot;, c(10, 1, 0.1), &amp;quot;)&amp;quot;)) %&amp;gt;% 
  mutate(fit   = map(name, get)) %&amp;gt;% 
  mutate(post  = map(fit, posterior_samples))
  
head(posts)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 3 x 4
##   name  prior          fit       post                
##   &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;          &amp;lt;list&amp;gt;    &amp;lt;list&amp;gt;              
## 1 fit1  normal(0, 10)  &amp;lt;brmsfit&amp;gt; &amp;lt;df[,3] [4,000 × 3]&amp;gt;
## 2 fit2  normal(0, 1)   &amp;lt;brmsfit&amp;gt; &amp;lt;df[,3] [4,000 × 3]&amp;gt;
## 3 fit3  normal(0, 0.1) &amp;lt;brmsfit&amp;gt; &amp;lt;df[,3] [4,000 × 3]&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We have a 3-row nested tibble. The first column, &lt;code&gt;name&lt;/code&gt; is just a character vector with the names of the fits. The next column isn’t necessary, but it nicely explicates the main difference in the models: the prior we used on the intercept. It’s in the &lt;code&gt;map()&lt;/code&gt; functions within the two &lt;code&gt;mutate()&lt;/code&gt;lines where all the magic happens. With the first, we used the &lt;code&gt;get()&lt;/code&gt; function to snatch up the &lt;strong&gt;brms&lt;/strong&gt; fit objects matching the names in the &lt;code&gt;name&lt;/code&gt; column. In the second, we used the &lt;code&gt;posterior_samples()&lt;/code&gt; function to extract the posterior draws from each of the fits saved in &lt;code&gt;fit&lt;/code&gt;. Do you see how each for in the &lt;code&gt;post&lt;/code&gt; column contains an entire &lt;span class=&#34;math inline&#34;&gt;\(4,000 \times 3\)&lt;/span&gt; data frame? That’s why we refer to this as a nested tibble. We have data frames compressed within data frames. If you’d like to access the data within the &lt;code&gt;post&lt;/code&gt; column, just &lt;code&gt;unnest()&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;posts %&amp;gt;% 
  unnest(post)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 12,000 x 6
##    name  prior         fit       b_Intercept sigma  lp__
##    &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;         &amp;lt;list&amp;gt;          &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
##  1 fit1  normal(0, 10) &amp;lt;brmsfit&amp;gt;    -0.0522  0.857 -204.
##  2 fit1  normal(0, 10) &amp;lt;brmsfit&amp;gt;     0.125   0.898 -204.
##  3 fit1  normal(0, 10) &amp;lt;brmsfit&amp;gt;    -0.00629 0.948 -204.
##  4 fit1  normal(0, 10) &amp;lt;brmsfit&amp;gt;     0.0609  0.941 -204.
##  5 fit1  normal(0, 10) &amp;lt;brmsfit&amp;gt;     0.178   0.946 -205.
##  6 fit1  normal(0, 10) &amp;lt;brmsfit&amp;gt;     0.135   0.927 -204.
##  7 fit1  normal(0, 10) &amp;lt;brmsfit&amp;gt;    -0.0777  0.874 -204.
##  8 fit1  normal(0, 10) &amp;lt;brmsfit&amp;gt;     0.116   0.973 -205.
##  9 fit1  normal(0, 10) &amp;lt;brmsfit&amp;gt;     0.134   0.852 -205.
## 10 fit1  normal(0, 10) &amp;lt;brmsfit&amp;gt;     0.0197  0.929 -203.
## # … with 11,990 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After un-nesting, we can remake the plot from above.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;posts %&amp;gt;% 
  unnest(post) %&amp;gt;% 

  ggplot(aes(x = b_Intercept, y = prior)) +
  geom_halfeyeh()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-07-13-would-you-like-all-your-posteriors-in-one-plot_files/figure-html/unnamed-chunk-21-1.png&#34; width=&#34;576&#34; /&gt;&lt;/p&gt;
&lt;p&gt;To learn more about using the &lt;strong&gt;tidyverse&lt;/strong&gt; for iterating and saving the results in nested tibbles, check out &lt;a href=&#34;https://twitter.com/hadleywickham&#34;&gt;Hadley Wickham&lt;/a&gt;’s great talk, &lt;a href=&#34;https://www.youtube.com/watch?v=rz3_FDVt9eg&#34;&gt;&lt;em&gt;Managing many models&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;session-information&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Session information&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sessionInfo()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## R version 3.6.0 (2019-04-26)
## Platform: x86_64-apple-darwin15.6.0 (64-bit)
## Running under: macOS High Sierra 10.13.6
## 
## Matrix products: default
## BLAS:   /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRblas.0.dylib
## LAPACK: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRlapack.dylib
## 
## locale:
## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
##  [1] tidybayes_1.1.0 brms_2.10.0     Rcpp_1.0.2      forcats_0.4.0   stringr_1.4.0   dplyr_0.8.3    
##  [7] purrr_0.3.2     readr_1.3.1     tidyr_1.0.0     tibble_2.1.3    ggplot2_3.2.1   tidyverse_1.2.1
## 
## loaded via a namespace (and not attached):
##   [1] colorspace_1.4-1          ellipsis_0.2.0.1          ggridges_0.5.1           
##   [4] rsconnect_0.8.13          ggstance_0.3.2            markdown_1.0             
##   [7] base64enc_0.1-3           rstudioapi_0.10           rstan_2.19.2             
##  [10] svUnit_0.7-12             DT_0.7                    fansi_0.4.0              
##  [13] mvtnorm_1.0-11            lubridate_1.7.4           xml2_1.2.0               
##  [16] bridgesampling_0.6-0      knitr_1.23                shinythemes_1.1.2        
##  [19] zeallot_0.1.0             bayesplot_1.7.0           jsonlite_1.6             
##  [22] broom_0.5.2               shiny_1.3.2               compiler_3.6.0           
##  [25] httr_1.4.0                backports_1.1.4           assertthat_0.2.1         
##  [28] Matrix_1.2-17             lazyeval_0.2.2            cli_1.1.0                
##  [31] later_0.8.0               htmltools_0.3.6           prettyunits_1.0.2        
##  [34] tools_3.6.0               igraph_1.2.4.1            coda_0.19-2              
##  [37] gtable_0.3.0              glue_1.3.1                reshape2_1.4.3           
##  [40] cellranger_1.1.0          vctrs_0.2.0               nlme_3.1-139             
##  [43] blogdown_0.14             crosstalk_1.0.0           xfun_0.8                 
##  [46] ps_1.3.0                  rvest_0.3.4               mime_0.7                 
##  [49] miniUI_0.1.1.1            lifecycle_0.1.0           gtools_3.8.1             
##  [52] zoo_1.8-6                 scales_1.0.0              colourpicker_1.0         
##  [55] hms_0.4.2                 promises_1.0.1            Brobdingnag_1.2-6        
##  [58] parallel_3.6.0            inline_0.3.15             shinystan_2.5.0          
##  [61] yaml_2.2.0                gridExtra_2.3             loo_2.1.0                
##  [64] StanHeaders_2.18.1-10     stringi_1.4.3             dygraphs_1.1.1.6         
##  [67] pkgbuild_1.0.3            rlang_0.4.0               pkgconfig_2.0.2          
##  [70] matrixStats_0.54.0        evaluate_0.14             lattice_0.20-38          
##  [73] labeling_0.3              rstantools_1.5.1          htmlwidgets_1.3          
##  [76] tidyselect_0.2.5          processx_3.3.1            plyr_1.8.4               
##  [79] magrittr_1.5              bookdown_0.12             R6_2.4.0                 
##  [82] generics_0.0.2            pillar_1.4.2              haven_2.1.0              
##  [85] withr_2.1.2               xts_0.11-2                abind_1.4-5              
##  [88] modelr_0.1.4              crayon_1.3.4              arrayhelpers_1.0-20160527
##  [91] utf8_1.1.4                rmarkdown_1.13            grid_3.6.0               
##  [94] readxl_1.3.1              callr_3.2.0               threejs_0.3.1            
##  [97] digest_0.6.20             xtable_1.8-4              httpuv_1.5.1             
## [100] stats4_3.6.0              munsell_0.5.0             shinyjs_1.0&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Stein’s Paradox and What Partial Pooling Can Do For You</title>
      <link>/post/stein-s-paradox-and-what-partial-pooling-can-do-for-you/</link>
      <pubDate>Sat, 23 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/stein-s-paradox-and-what-partial-pooling-can-do-for-you/</guid>
      <description>&lt;div id=&#34;tldr&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;a href=&#34;https://www.urbandictionary.com/define.php?term=tl%3Bdr&#34;&gt;tl;dr&lt;/a&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Sometimes a mathematical result is strikingly contrary to generally held belief even though an obviously valid proof is given. &lt;a href=&#34;https://en.wikipedia.org/wiki/Charles_M._Stein&#34;&gt;Charles Stein&lt;/a&gt; of Stanford University discovered such a paradox in statistics in 1995. His result undermined a century and a half of work on estimation theory. (Efron &amp;amp; Morris, 1977, p. 119)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The James-Stein estimator leads to better predictions than simple means. Though I don’t recommend you actually use the James-Stein estimator in applied research, understanding why it works might help clarify why it’s time social scientists consider &lt;a href=&#34;http://elevanth.org/blog/2017/08/24/multilevel-regression-as-default/&#34;&gt;defaulting to multilevel models&lt;/a&gt; for their work-a-day projects.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;the-james-stein-can-help-us-understand-multilevel-models.&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;The James-Stein can help us understand multilevel models.&lt;/h2&gt;
&lt;p&gt;I recently noticed someone—I wish I could recall who—tweet about Efron and Morris’s classic, &lt;a href=&#34;http://statweb.stanford.edu/~ckirby/brad/other/Article1977.pdf&#34;&gt;&lt;em&gt;Stein’s Paradox in Statistics&lt;/em&gt;&lt;/a&gt;. At the time, I was vaguely aware of the paper but hadn’t taken the chance to read it. The tweet’s author mentioned how good a read it was. Now I’ve looked at it, I concur. I’m not a sports fan, but I really appreciated their primary example using batting averages from baseball players in 1970. It clarified why partial pooling leads to better estimates than taking simple averages.&lt;/p&gt;
&lt;p&gt;In this project, I’ll walk out Efron and Morris’s baseball example in R and then link it to contemporary Bayesian multilevel models.&lt;/p&gt;
&lt;div id=&#34;i-assume-things.&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;I assume things.&lt;/h3&gt;
&lt;p&gt;For this project, I’m presuming you are familiar with logistic regression, vaguely familiar with the basic differences between frequentist and Bayesian approaches to fitting regression models, and have heard of multilevel models. All code in is &lt;a href=&#34;https://www.r-project.org/about.html&#34;&gt;R&lt;/a&gt;, with a heavy use of the &lt;a href=&#34;https://www.tidyverse.org&#34;&gt;tidyverse&lt;/a&gt;—which you might learn a lot about &lt;a href=&#34;http://r4ds.had.co.nz&#34;&gt;here&lt;/a&gt;, especially &lt;a href=&#34;http://r4ds.had.co.nz/transform.html&#34;&gt;chapter 5&lt;/a&gt;—, and the &lt;a href=&#34;https://github.com/paul-buerkner/brms&#34;&gt;brms package&lt;/a&gt; for Bayesian regression.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;behold-the-baseball-data.&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Behold the &lt;code&gt;baseball&lt;/code&gt; data.&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Stein’s paradox concerns the use of observed averages to estimate unobservable quantities. Averaging is the second most basic process in statistics, the first being the simple act of counting. A baseball player who gets seven hits in 20 official times at bat is said to have a batting average of .350. In computing this statistic we are forming an estimate of the payer’s true batting ability in terms of his observed average rate of success. Asked how well the player will do in his next 100 times at bat, we would probably predict 35 more hits. In traditional statistical theory it can be proved that no other estimation rule is uniformly better than the observed average.&lt;/p&gt;
&lt;p&gt;The paradoxical element in Stein’s result is that it sometimes contradicts this elementary law of statistical theory. If we have three or more baseball players, and if we are interested in predicting future batting averages for each of them, then there is a procedure that is better than simply extrapolating from the three separate averages…&lt;/p&gt;
&lt;p&gt;As our primary data we shall consider the batting averages of 18 major-league players as they were recorded after their first 45 times at bat in the 1970 season. (p. 119)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Let’s enter the &lt;code&gt;baseball&lt;/code&gt; data.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidyverse)

baseball &amp;lt;- 
  tibble(player = c(&amp;quot;Clemente&amp;quot;, &amp;quot;F Robinson&amp;quot;, &amp;quot;F Howard&amp;quot;, &amp;quot;Johnstone&amp;quot;, &amp;quot;Berry&amp;quot;, &amp;quot;Spencer&amp;quot;, &amp;quot;Kessinger&amp;quot;, &amp;quot;L Alvarado&amp;quot;, &amp;quot;Santo&amp;quot;, &amp;quot;Swoboda&amp;quot;, &amp;quot;Unser&amp;quot;, &amp;quot;Williams&amp;quot;, &amp;quot;Scott&amp;quot;, &amp;quot;Petrocelli&amp;quot;, &amp;quot;E Rodriguez&amp;quot;, &amp;quot;Campaneris&amp;quot;, &amp;quot;Munson&amp;quot;, &amp;quot;Alvis&amp;quot;),
         hits = c(18:15, 14, 14:12, 11, 11, rep(10, times = 5), 9:7),
         times_at_bat = 45,
         true_ba = c(.346, .298, .276, .222, .273, .27, .263, .21, .269, .23, .264, .256, .303, .264, .226, .286, .316, .2))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here’s what they look like.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;glimpse(baseball)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Observations: 18
## Variables: 4
## $ player       &amp;lt;chr&amp;gt; &amp;quot;Clemente&amp;quot;, &amp;quot;F Robinson&amp;quot;, &amp;quot;F Howard&amp;quot;, &amp;quot;Johnstone&amp;quot;, &amp;quot;Berry&amp;quot;, &amp;quot;Spencer&amp;quot;, &amp;quot;Kess…
## $ hits         &amp;lt;dbl&amp;gt; 18, 17, 16, 15, 14, 14, 13, 12, 11, 11, 10, 10, 10, 10, 10, 9, 8, 7
## $ times_at_bat &amp;lt;dbl&amp;gt; 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45
## $ true_ba      &amp;lt;dbl&amp;gt; 0.346, 0.298, 0.276, 0.222, 0.273, 0.270, 0.263, 0.210, 0.269, 0.230, 0.264,…&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We have data from 18 players. The main columns are of the number of &lt;code&gt;hits&lt;/code&gt; for their first 45 &lt;code&gt;times_at_bat&lt;/code&gt;. I got the &lt;code&gt;player&lt;/code&gt;, &lt;code&gt;hits&lt;/code&gt;, and &lt;code&gt;times_at_bat&lt;/code&gt; values directly from the paper. However, Efron and Morris didn’t include the batting averages for the end of the season in the paper. Happily, I was able to find those values &lt;a href=&#34;http://statweb.stanford.edu/~ckirby/brad/LSI/chapter1.pdf&#34;&gt;online&lt;/a&gt;. They’re included in the &lt;code&gt;true_ba&lt;/code&gt; column.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;…These were all the players who happened to have batted exactly 45 times the day the data were tabulated. A batting average is defined, of course, simply as the number of hits divided by the number of times at bat; it is always a number between 0 and 1. (p. 119)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I like use a lot of plots to better understand what I’m doing. Before we start plotting, I should point out the color theme in this project comes from &lt;a href=&#34;https://teamcolorcodes.com/seattle-mariners-color-codes/&#34;&gt;here&lt;/a&gt;. [Haters gonna hate.]&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;navy_blue &amp;lt;- &amp;quot;#0C2C56&amp;quot;
nw_green  &amp;lt;- &amp;quot;#005C5C&amp;quot;  
silver    &amp;lt;- &amp;quot;#C4CED4&amp;quot;
theme_set(theme_grey() +
            theme(panel.grid = element_blank(),
                  panel.background = element_rect(fill = silver),
                  strip.background = element_rect(fill = silver)))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We might use a histogram to get a sense of the &lt;code&gt;hits&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;baseball %&amp;gt;% 
  ggplot(aes(x = hits)) +
  geom_histogram(color = nw_green,
                 fill  = navy_blue,
                 size  = 1/10, binwidth = 1) +
  scale_x_continuous(&amp;quot;hits during the first 45 trials&amp;quot;,
                     breaks = 7:18)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-02-23-stein-s-paradox-and-what-partial-pooling-can-do-for-you_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;384&#34; /&gt;&lt;/p&gt;
&lt;p&gt;And here is the distribution of the end-of-the-season batting averages, &lt;code&gt;true_ba&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidybayes)

baseball %&amp;gt;% 
  ggplot(aes(x = true_ba, y = 0)) +
  geom_halfeyeh(color = navy_blue,
                fill  = alpha(nw_green, 2/3),
                point_range = median_qi, .width = .5) +
  geom_rug(color = navy_blue,
           size = 1/3, alpha = 1/2) +
  ggtitle(NULL, subtitle = &amp;quot;The dot and horizontal line are the median and\ninterquartile range, respectively.&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-02-23-stein-s-paradox-and-what-partial-pooling-can-do-for-you_files/figure-html/unnamed-chunk-5-1.png&#34; width=&#34;384&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;james-stein-will-help-us-achieve-our-goal.&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;James-Stein will help us achieve our goal.&lt;/h3&gt;
&lt;p&gt;For each of the 18 players in the data, our goal is to the best job possible to use the data for their first 45 times at bat (i.e., &lt;code&gt;hits&lt;/code&gt; and &lt;code&gt;times_at_bat&lt;/code&gt;) to predict their batting averages at the end of the season (i.e., &lt;code&gt;true_ba&lt;/code&gt;). Before Charles Stein, the conventional reasoning was their initial batting averages (i.e., &lt;code&gt;hits / times_at_bat&lt;/code&gt;) are the best way to do this. It turns out that would be naïve. To see why, let&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;y&lt;/code&gt; (i.e., &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt;) = the batting average for the first 45 times at bat&lt;/li&gt;
&lt;li&gt;&lt;code&gt;y_bar&lt;/code&gt; (i.e., &lt;span class=&#34;math inline&#34;&gt;\(\overline y\)&lt;/span&gt;) = the grand mean for the first 45 times at bat&lt;/li&gt;
&lt;li&gt;&lt;code&gt;c&lt;/code&gt; (i.e., &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt;) = shrinking factor&lt;/li&gt;
&lt;li&gt;&lt;code&gt;z&lt;/code&gt; (i.e., &lt;span class=&#34;math inline&#34;&gt;\(z\)&lt;/span&gt;) = James-Stein estimate&lt;/li&gt;
&lt;li&gt;&lt;code&gt;true_ba&lt;/code&gt; (i.e., &lt;code&gt;theta&lt;/code&gt;, &lt;span class=&#34;math inline&#34;&gt;\(\theta\)&lt;/span&gt;) = the batting average at the end of the season&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;The first step in applying Stein’s method is to determine the average of the averages. Obviously this grand average, which we give the symbol &lt;span class=&#34;math inline&#34;&gt;\(\overline y\)&lt;/span&gt;, must also lie between 0 and 1. The essential process in Stein’s method is the “shrinking” of all the individual averages toward this grand average. If a player’s hitting record is better than the grand average, then it must be reduced; if he is not hitting as well as the grand average, then his hitting record must be increased. The resulting shrunken value for each player we designate &lt;span class=&#34;math inline&#34;&gt;\(z\)&lt;/span&gt;. (p. 119)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;As such, the James-Stein estimator is:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[z = \overline y + c(y - \overline y)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;And in the paper, &lt;span class=&#34;math inline&#34;&gt;\(c = .212\)&lt;/span&gt;. Let’s get some of those values into the &lt;code&gt;baseball&lt;/code&gt; data.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(
  baseball &amp;lt;-
  baseball %&amp;gt;% 
  mutate(y     = hits / times_at_bat) %&amp;gt;% 
  mutate(y_bar = mean(y),
         c     = .212) %&amp;gt;% 
  mutate(z     = y_bar + c * (y - y_bar),
         theta = true_ba)
  )&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 18 x 9
##    player       hits times_at_bat true_ba     y y_bar     c     z theta
##    &amp;lt;chr&amp;gt;       &amp;lt;dbl&amp;gt;        &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
##  1 Clemente       18           45   0.346 0.4   0.265 0.212 0.294 0.346
##  2 F Robinson     17           45   0.298 0.378 0.265 0.212 0.289 0.298
##  3 F Howard       16           45   0.276 0.356 0.265 0.212 0.285 0.276
##  4 Johnstone      15           45   0.222 0.333 0.265 0.212 0.280 0.222
##  5 Berry          14           45   0.273 0.311 0.265 0.212 0.275 0.273
##  6 Spencer        14           45   0.27  0.311 0.265 0.212 0.275 0.27 
##  7 Kessinger      13           45   0.263 0.289 0.265 0.212 0.270 0.263
##  8 L Alvarado     12           45   0.21  0.267 0.265 0.212 0.266 0.21 
##  9 Santo          11           45   0.269 0.244 0.265 0.212 0.261 0.269
## 10 Swoboda        11           45   0.23  0.244 0.265 0.212 0.261 0.23 
## 11 Unser          10           45   0.264 0.222 0.265 0.212 0.256 0.264
## 12 Williams       10           45   0.256 0.222 0.265 0.212 0.256 0.256
## 13 Scott          10           45   0.303 0.222 0.265 0.212 0.256 0.303
## 14 Petrocelli     10           45   0.264 0.222 0.265 0.212 0.256 0.264
## 15 E Rodriguez    10           45   0.226 0.222 0.265 0.212 0.256 0.226
## 16 Campaneris      9           45   0.286 0.2   0.265 0.212 0.252 0.286
## 17 Munson          8           45   0.316 0.178 0.265 0.212 0.247 0.316
## 18 Alvis           7           45   0.2   0.156 0.265 0.212 0.242 0.2&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Which set of values, &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt; or &lt;span class=&#34;math inline&#34;&gt;\(z\)&lt;/span&gt;, is the better indicator of batting ability for the 18 players in our example? In order to answer that question in a precise way one would have to know the “true batting ability” of each player. This true average we shall designate &lt;span class=&#34;math inline&#34;&gt;\(\theta\)&lt;/span&gt; (the Greek letter theta). Actually it is an unknowable quantity, an abstraction representing the probability that a player will get a hit on any given time at bat. Although &lt;span class=&#34;math inline&#34;&gt;\(\theta\)&lt;/span&gt; is unobservable, we have a good approximation to it: the subsequent performance of the batters. It is sufficient to consider just the remainder of the 1970 season, which includes about nine times as much data as the preliminary averages were based on. (p. 119)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Now we have both &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(z\)&lt;/span&gt; in the data, let’s compare their distributions.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;baseball %&amp;gt;% 
  select(y, z) %&amp;gt;% 
  gather() %&amp;gt;% 
  mutate(label = ifelse(key == &amp;quot;z&amp;quot;, 
                        &amp;quot;the James-Stein estimate&amp;quot;, 
                        &amp;quot;early-season batting average&amp;quot;)) %&amp;gt;% 
  
  ggplot(aes(x = value, y = label)) +
  geom_vline(color = &amp;quot;white&amp;quot;,
             xintercept = 0.2654321, linetype = 2) +
  geom_halfeyeh(color = navy_blue,
                fill  = alpha(nw_green, 2/3),
                point_range = median_qi, .width = .5, relative_scale = 4) +
  labs(x = &amp;quot;batting average&amp;quot;, y = NULL) +
  coord_cartesian(ylim = c(1.25, 5.25))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-02-23-stein-s-paradox-and-what-partial-pooling-can-do-for-you_files/figure-html/unnamed-chunk-7-1.png&#34; width=&#34;480&#34; /&gt;&lt;/p&gt;
&lt;p&gt;As implied in the formula, the James-Stein estimates are substantially shrunken towards the grand mean, &lt;code&gt;y_bar&lt;/code&gt;. To get a sense of which estimate is better, we can subtract the estimate from &lt;code&gt;theta&lt;/code&gt;, the end of the season batting average.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;baseball &amp;lt;-
  baseball %&amp;gt;% 
  mutate(y_error = theta - y,
         z_error = theta - z)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since &lt;code&gt;y_error&lt;/code&gt; and &lt;code&gt;y_error&lt;/code&gt; are error distributions, we prefer values to be as close to zero as possible. Let’s take a look.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;baseball %&amp;gt;% 
  select(y_error:z_error) %&amp;gt;% 
  gather() %&amp;gt;% 
  
  ggplot(aes(x = value, y = key)) +
  geom_vline(xintercept = 0, linetype = 2,
             color = &amp;quot;white&amp;quot;) +
  geom_halfeyeh(color = navy_blue,
                fill  = alpha(nw_green, 2/3),
                point_range = median_qi, .width = .5, relative_scale = 2.5) +
  labs(x = NULL, y = NULL) +
  coord_cartesian(ylim = c(1.25, 4))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-02-23-stein-s-paradox-and-what-partial-pooling-can-do-for-you_files/figure-html/unnamed-chunk-9-1.png&#34; width=&#34;384&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The James-Stein errors (i.e., &lt;code&gt;z_error&lt;/code&gt;) are much more concentrated toward zero. In the paper, we read: “One method of evaluating the two estimates is by simply counting their successes and failures. For 16 of the 18 players the James-Stein estimator &lt;span class=&#34;math inline&#34;&gt;\(z\)&lt;/span&gt; is closer than the observed average &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt; to the ‘true,’ or seasonal, average &lt;span class=&#34;math inline&#34;&gt;\(\theta\)&lt;/span&gt;” (pp. 119–121). We can compute that with a little &lt;code&gt;ifelse()&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;baseball %&amp;gt;% 
  transmute(closer_to_theta = ifelse(abs(y_error) - abs(z_error) == 0, &amp;quot;equal&amp;quot;,
                                     ifelse(abs(y_error) - abs(z_error) &amp;gt; 0, &amp;quot;z&amp;quot;, &amp;quot;y&amp;quot;))) %&amp;gt;% 
  group_by(closer_to_theta) %&amp;gt;% 
  count()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 2 x 2
## # Groups:   closer_to_theta [2]
##   closer_to_theta     n
##   &amp;lt;chr&amp;gt;           &amp;lt;int&amp;gt;
## 1 y                   2
## 2 z                  16&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;A more quantitative way of comparing the two techniques is through the total squared error of estimation… The observed averages &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt; have a total squared error of .077, whereas the squared error of the James-Stein estimators is only .022. By this comparison, then, Stein’s method is 3.5 times as accurate. (p. 121)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;baseball %&amp;gt;% 
  select(y_error:z_error) %&amp;gt;% 
  gather() %&amp;gt;% 
  group_by(key) %&amp;gt;% 
  summarise(total_squared_error = sum(value * value))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 2 x 2
##   key     total_squared_error
##   &amp;lt;chr&amp;gt;                 &amp;lt;dbl&amp;gt;
## 1 y_error              0.0755
## 2 z_error              0.0214&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can get the 3.5 value with simple division.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;0.07548795 / 0.02137602&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 3.531431&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So it does indeed turn out that shrinking each player’s initial estimate toward the grand mean of those initial estimates does a better job of predicting their end-of-the-season batting averages than using their individual batting averages. To get a sense of what this looks like, let’s make our own version of the figure on page 121.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;baseball %&amp;gt;% 
  select(y, z, theta, player) %&amp;gt;% 
  gather(key, value, -player) %&amp;gt;% 
  mutate(time = ifelse(key == &amp;quot;theta&amp;quot;, &amp;quot;theta&amp;quot;, &amp;quot;estimate&amp;quot;)) %&amp;gt;% 
  bind_rows(
    baseball %&amp;gt;% 
      select(player, theta) %&amp;gt;% 
      rename(value = theta) %&amp;gt;% 
      mutate(key  = &amp;quot;theta&amp;quot;, 
             time = &amp;quot;theta&amp;quot;)
  ) %&amp;gt;% 
  mutate(facet = rep(c(&amp;quot;estimate = y&amp;quot;, &amp;quot;estimate = z&amp;quot;), each = n() / 4) %&amp;gt;% rep(., times = 2)) %&amp;gt;% 
  
  ggplot(aes(x = time, y = value, group = player)) +
  geom_hline(yintercept = 0.2654321, linetype = 2,
             color = &amp;quot;white&amp;quot;) +
  geom_line(alpha = 1/2,
            color = nw_green) +
  geom_point(alpha = 1/2,
             color = navy_blue) +
  labs(x = NULL,
       y = &amp;quot;batting average&amp;quot;) +
  theme(axis.ticks.x = element_blank()) +
  facet_wrap(~facet)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-02-23-stein-s-paradox-and-what-partial-pooling-can-do-for-you_files/figure-html/unnamed-chunk-13-1.png&#34; width=&#34;576&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The James-Stein estimator works because of its shrinkage. The shrinkage factor is &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt;. In the first parts of the paper, Efron and Morris just told us &lt;span class=&#34;math inline&#34;&gt;\(c = .212\)&lt;/span&gt;. A little later in the paper, they gave the actual formula for &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt;. If you let &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; be the number of means (i.e., the number of clusters), then:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[c = 1 - \frac{(k - 3)\sigma^2}{\sum (y - \overline y)^2}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The difficulty of that formula is we don’t know the value for &lt;span class=&#34;math inline&#34;&gt;\(\sigma^2\)&lt;/span&gt;. It’s not the simple variance of &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt; (i.e., &lt;code&gt;var(y)&lt;/code&gt;). An &lt;a href=&#34;https://stats.stackexchange.com/questions/5727/james-stein-estimator-how-did-efron-and-morris-calculate-sigma2-in-shrinkag&#34;&gt;answer to this stackexchange question&lt;/a&gt; appears to have uncovered the method Efron and Morris used in the paper. I’ll reproduce it in detail:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-02-23-stein-s-paradox-and-what-partial-pooling-can-do-for-you_files/answer.PNG&#34; style=&#34;width:100.0%&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Following along, we can compute &lt;code&gt;sigma_squared&lt;/code&gt; like so:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(sigma_squared &amp;lt;- mean(baseball$y) * (1 - mean(baseball$y)) / 45)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.004332842&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we can reproduce the &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt; value from the paper.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;baseball %&amp;gt;% 
  select(player, y:c) %&amp;gt;% 
  mutate(squared_deviation = (y - y_bar)^2) %&amp;gt;%
  summarise(c_by_hand = 1 - ((n() - 3) * sigma_squared / sum(squared_deviation)))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1 x 1
##   c_by_hand
##       &amp;lt;dbl&amp;gt;
## 1     0.212&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;lets-go-bayesian.&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Let’s go Bayesian.&lt;/h2&gt;
&lt;p&gt;This has been fun. But I don’t recommend you actually use the James-Stein estimator in your research.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The James-Stein estimator is not the only one that is known to be better than the sample averages…&lt;/p&gt;
&lt;p&gt;The search for new estimators continues. Recent efforts [in the 1970s, that is] have been concentrated on achieving results like those obtained with Stein’s method for problems involving distributions other than the normal distribution. Several lines of work, including Stein’s and Robbins’ and more formal &lt;em&gt;Bayesian methods&lt;/em&gt; seem to be converging on a powerful general theory of parameter estimation. (p. 127, &lt;em&gt;emphasis&lt;/em&gt; added)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The James-Stein estimator is not Bayesian, but it is a precursor to the kind of analyses we now do with Bayesian multilevel models, which pool cluster-level means toward a grand mean. To get a sense of this, let’s fit a couple models. First, let’s load the brms package.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(brms)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I typically work with the linear regression paradigm. If we were to analyze the &lt;code&gt;baseball&lt;/code&gt; data, we’d use an aggregated binomial mode, which is a particular kind of logistic regression. You can learn more about it &lt;a href=&#34;https://www.youtube.com/watch?v=DyrUkqK9Tj4&amp;amp;t=1581s&amp;amp;frags=pl%2Cwn&#34;&gt;here&lt;/a&gt; or &lt;a href=&#34;https://github.com/ASKurz/Statistical_Rethinking_with_brms_ggplot2_and_the_tidyverse/blob/master/10.md&#34;&gt;here&lt;/a&gt;. If we wanted a model that corresponded to the &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt; estimates, above, we’d use &lt;code&gt;hits&lt;/code&gt; as the criterion and allow each player to get his own &lt;em&gt;separate&lt;/em&gt; estimate. Since we’re working within the Bayesian paradigm, we also need to assign priors. In this case, we’ll use a weakly-regularizing &lt;span class=&#34;math inline&#34;&gt;\(\text{Normal} (0, 1.5)\)&lt;/span&gt; on the intercepts. See &lt;a href=&#34;https://github.com/stan-dev/stan/wiki/Prior-Choice-Recommendations&#34;&gt;this wiki&lt;/a&gt; for more on weakly-regularizing priors.&lt;/p&gt;
&lt;p&gt;Here’s the code to fit the model in brms.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fit_y &amp;lt;-
  brm(data = baseball, family = binomial,
      hits | trials(45) ~ 0 + player,
      prior(normal(0, 1.5), class = b),
      seed = 1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you were curious, that model followed the statistical formula&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{eqnarray}
\text{hits}_i &amp;amp; \sim &amp;amp; \text{Binomial} (n = 45, p_i) \\
\text{logit}(p_i) &amp;amp; = &amp;amp; \alpha_\text{player} \\
\alpha_\text{player} &amp;amp; \sim &amp;amp; \text{Normal} (0, 1.5)
\end{eqnarray}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;where &lt;span class=&#34;math inline&#34;&gt;\(p_i\)&lt;/span&gt; is the probability of player &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;, &lt;span class=&#34;math inline&#34;&gt;\(\alpha_\text{player}\)&lt;/span&gt; is a vector of &lt;span class=&#34;math inline&#34;&gt;\(\text{player}\)&lt;/span&gt;-specific intercepts from within the logistic regression model, and each of those intercepts are given a &lt;span class=&#34;math inline&#34;&gt;\(\text{Normal} (0, 1.5)\)&lt;/span&gt; prior on the log-odds scale. (If this is all new and confusing, don’t worry. I’ll recommended some resources at the end of this post.)&lt;/p&gt;
&lt;p&gt;For our analogue to the James-Stein estimate &lt;span class=&#34;math inline&#34;&gt;\(z\)&lt;/span&gt;, we’ll fit the multilevel version of that last model. While each player still gets his own estimate, those estimates are now partially-pooled toward the grand mean.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fit_z &amp;lt;-
  brm(data = baseball, family = binomial,
      hits | trials(45) ~ 1 + (1 | player),
      prior = c(prior(normal(0, 1.5), class = Intercept),
                prior(normal(0, 1.5), class = sd)),
      seed = 1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And that model followed the statistical formula&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{eqnarray}
\text{hits}_i &amp;amp; \sim &amp;amp; \text{Binomial} (n = 45, p_i) \\
\text{logit}(p_i) &amp;amp; = &amp;amp; \alpha + \alpha_\text{player} \\
\alpha &amp;amp; \sim &amp;amp; \text{Normal} (0, 1.5) \\ 
\alpha_\text{player} &amp;amp; \sim &amp;amp; \text{Normal} (0, \sigma_\text{player}) \\
\sigma_\text{player} &amp;amp; \sim &amp;amp; \text{HalfNormal} (0, 1.5)
\end{eqnarray}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;where &lt;span class=&#34;math inline&#34;&gt;\(\alpha\)&lt;/span&gt; is the grand mean among the &lt;span class=&#34;math inline&#34;&gt;\(\text{player}\)&lt;/span&gt;-specific intercepts, &lt;span class=&#34;math inline&#34;&gt;\(\alpha_\text{player}\)&lt;/span&gt; is the vector of &lt;span class=&#34;math inline&#34;&gt;\(\text{player}\)&lt;/span&gt;-specific deviations from the grand mean, which are Normally distributed with a mean of zero and a standard deviation of &lt;span class=&#34;math inline&#34;&gt;\(\sigma_\text{player}\)&lt;/span&gt;, which is estimated from the data.&lt;/p&gt;
&lt;p&gt;Here are the model summaries.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fit_y$fit&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Inference for Stan model: 1d2456d7f7a08ebf8ef5fda01ce9b808.
## 4 chains, each with iter=2000; warmup=1000; thin=1; 
## post-warmup draws per chain=1000, total post-warmup draws=4000.
## 
##                      mean se_mean   sd   2.5%    25%    50%    75%  97.5% n_eff Rhat
## b_playerAlvis       -1.63    0.00 0.39  -2.44  -1.89  -1.62  -1.35  -0.89  7862    1
## b_playerBerry       -0.78    0.00 0.31  -1.41  -0.98  -0.77  -0.56  -0.19  8886    1
## b_playerCampaneris  -1.34    0.00 0.35  -2.05  -1.57  -1.33  -1.10  -0.69  7628    1
## b_playerClemente    -0.39    0.00 0.30  -0.99  -0.59  -0.39  -0.19   0.18 10134    1
## b_playerERodriguez  -1.21    0.00 0.35  -1.93  -1.45  -1.20  -0.97  -0.55 10145    1
## b_playerFHoward     -0.59    0.00 0.31  -1.22  -0.79  -0.58  -0.38   0.03 10787    1
## b_playerFRobinson   -0.49    0.00 0.30  -1.08  -0.69  -0.49  -0.28   0.10 10544    1
## b_playerJohnstone   -0.69    0.00 0.31  -1.32  -0.88  -0.68  -0.48  -0.09  9763    1
## b_playerKessinger   -0.88    0.00 0.33  -1.55  -1.10  -0.88  -0.67  -0.28  9094    1
## b_playerLAlvarado   -0.98    0.00 0.32  -1.63  -1.20  -0.97  -0.76  -0.37 10622    1
## b_playerMunson      -1.48    0.00 0.38  -2.27  -1.72  -1.46  -1.21  -0.77 11067    1
## b_playerPetrocelli  -1.21    0.00 0.33  -1.89  -1.43  -1.20  -0.99  -0.59  9253    1
## b_playerSanto       -1.10    0.00 0.33  -1.78  -1.32  -1.09  -0.87  -0.46  9619    1
## b_playerScott       -1.22    0.00 0.36  -1.94  -1.45  -1.20  -0.98  -0.54 10948    1
## b_playerSpencer     -0.78    0.00 0.33  -1.45  -0.99  -0.77  -0.55  -0.14  8511    1
## b_playerSwoboda     -1.10    0.00 0.35  -1.81  -1.33  -1.10  -0.87  -0.42 10665    1
## b_playerUnser       -1.21    0.00 0.35  -1.92  -1.44  -1.21  -0.97  -0.54 11893    1
## b_playerWilliams    -1.22    0.00 0.35  -1.96  -1.45  -1.20  -0.97  -0.56  8597    1
## lp__               -73.45    0.08 2.93 -79.97 -75.21 -73.15 -71.34 -68.48  1444    1
## 
## Samples were drawn using NUTS(diag_e) at Sat Feb 23 17:19:53 2019.
## For each parameter, n_eff is a crude measure of effective sample size,
## and Rhat is the potential scale reduction factor on split chains (at 
## convergence, Rhat=1).&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fit_z$fit&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Inference for Stan model: 33295e60ce033f843c74128ac973bc03.
## 4 chains, each with iter=2000; warmup=1000; thin=1; 
## post-warmup draws per chain=1000, total post-warmup draws=4000.
## 
##                                   mean se_mean   sd   2.5%    25%    50%    75%  97.5% n_eff Rhat
## b_Intercept                      -1.02    0.00 0.09  -1.21  -1.08  -1.02  -0.96  -0.84  3116    1
## sd_player__Intercept              0.17    0.00 0.11   0.01   0.08   0.16   0.24   0.42  1643    1
## r_player[Alvis,Intercept]        -0.13    0.00 0.20  -0.62  -0.22  -0.07   0.00   0.17  2411    1
## r_player[Berry,Intercept]         0.05    0.00 0.17  -0.26  -0.03   0.02   0.13   0.44  4251    1
## r_player[Campaneris,Intercept]   -0.08    0.00 0.17  -0.51  -0.16  -0.04   0.02   0.21  3621    1
## r_player[Clemente,Intercept]      0.14    0.00 0.20  -0.13   0.00   0.09   0.25   0.63  2902    1
## r_player[E.Rodriguez,Intercept]  -0.05    0.00 0.16  -0.43  -0.12  -0.02   0.04   0.27  4722    1
## r_player[F.Howard,Intercept]      0.09    0.00 0.18  -0.20  -0.01   0.05   0.19   0.54  3081    1
## r_player[F.Robinson,Intercept]    0.12    0.00 0.19  -0.17   0.00   0.07   0.22   0.58  2766    1
## r_player[Johnstone,Intercept]     0.07    0.00 0.17  -0.22  -0.02   0.04   0.15   0.47  4122    1
## r_player[Kessinger,Intercept]     0.03    0.00 0.16  -0.29  -0.05   0.01   0.09   0.40  4051    1
## r_player[L.Alvarado,Intercept]    0.00    0.00 0.17  -0.37  -0.08   0.00   0.08   0.36  4060    1
## r_player[Munson,Intercept]       -0.10    0.00 0.19  -0.59  -0.18  -0.05   0.01   0.19  3625    1
## r_player[Petrocelli,Intercept]   -0.05    0.00 0.17  -0.46  -0.14  -0.02   0.04   0.25  4014    1
## r_player[Santo,Intercept]        -0.02    0.00 0.16  -0.40  -0.09  -0.01   0.05   0.30  4388    1
## r_player[Scott,Intercept]        -0.05    0.00 0.17  -0.45  -0.13  -0.02   0.04   0.26  3650    1
## r_player[Spencer,Intercept]       0.05    0.00 0.17  -0.27  -0.04   0.02   0.13   0.43  3611    1
## r_player[Swoboda,Intercept]      -0.03    0.00 0.16  -0.38  -0.10  -0.01   0.05   0.28  4562    1
## r_player[Unser,Intercept]        -0.05    0.00 0.16  -0.44  -0.13  -0.02   0.04   0.25  3412    1
## r_player[Williams,Intercept]     -0.05    0.00 0.17  -0.44  -0.13  -0.02   0.04   0.26  4306    1
## lp__                            -73.87    0.13 4.11 -82.53 -76.49 -73.67 -71.00 -66.54  1053    1
## 
## Samples were drawn using NUTS(diag_e) at Sat Feb 23 17:20:43 2019.
## For each parameter, n_eff is a crude measure of effective sample size,
## and Rhat is the potential scale reduction factor on split chains (at 
## convergence, Rhat=1).&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you’re new to aggregated binomial or logistic regression, those estimates might be confusing. For technical reasons—see &lt;a href=&#34;https://www.youtube.com/watch?v=DyrUkqK9Tj4&amp;amp;t=1430s&amp;amp;frags=pl%2Cwn&#34;&gt;here&lt;/a&gt;—, they’re in a log-odds metric. But we can use the &lt;code&gt;brms::inv_logit_scaled()&lt;/code&gt; function to convert them back to a probability metric. &lt;em&gt;Why would we want a probability metric?&lt;/em&gt;, you might ask. As it turns out, batting average is in a probability metric, too. So you might also think of the &lt;code&gt;inv_logit_scaled()&lt;/code&gt; function as turning the model results into a batting-average metric. For example, if we wanted to get the estimated batting average for E. Rodriguez baed on the &lt;code&gt;y_fit&lt;/code&gt; model (i.e., the model corresponding to the &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt; estimator), we might do something like this.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fixef(fit_y)[&amp;quot;playerERodriguez&amp;quot;, 1] %&amp;gt;% 
  inv_logit_scaled()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.2293629&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To double check the model returned a sensible estimate, here’s the corresponding &lt;code&gt;y&lt;/code&gt; value from the &lt;code&gt;baseball&lt;/code&gt; data.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;baseball %&amp;gt;% 
  filter(player == &amp;quot;E Rodriguez&amp;quot;) %&amp;gt;% 
  select(y)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1 x 1
##       y
##   &amp;lt;dbl&amp;gt;
## 1 0.222&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It’s a little off, but in the right ballpark. Here is the corresponding estimate from the multilevel model, &lt;code&gt;fit_z&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;coef(fit_z)$player[&amp;quot;E Rodriguez&amp;quot;, 1, ] %&amp;gt;% inv_logit_scaled()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.2558496&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And indeed that’s pretty close to the &lt;code&gt;z&lt;/code&gt; value from the &lt;code&gt;baseball&lt;/code&gt; data, too.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;baseball %&amp;gt;% 
  filter(player == &amp;quot;E Rodriguez&amp;quot;) %&amp;gt;% 
  select(z)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1 x 1
##       z
##   &amp;lt;dbl&amp;gt;
## 1 0.256&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So now we have these too competing ways to model the data of the first 45 times at bat, let’s see how well their estimates predict the &lt;code&gt;true_ba&lt;/code&gt; values. We’ll do so with a couple plots. This first one is of the single-level model which did not pool the batting averages.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# get the `fitted()` draws and wrangle a bit
f_y &amp;lt;-
  baseball %&amp;gt;% 
  distinct(player) %&amp;gt;% 
  add_fitted_draws(fit_y, dpar = &amp;quot;mu&amp;quot;) %&amp;gt;% 
  left_join(baseball %&amp;gt;% 
              select(player, true_ba))
  
# save the plot
p1 &amp;lt;-
  f_y %&amp;gt;% 
  ggplot(aes(x = mu, y = reorder(player, true_ba))) +
  geom_vline(xintercept = mean(baseball$true_ba), color = &amp;quot;white&amp;quot;) +
  stat_intervalh(.width = .95, alpha = 1/3, color = nw_green) +
  stat_intervalh(.width = .50, alpha = 1/3, color = nw_green) +
  geom_point(data = baseball,
             aes(x = true_ba),
             size = 2, alpha = 3/4,
             color = navy_blue) +
  labs(x = &amp;quot;batting average&amp;quot;, 
       y = NULL,
       subtitle = &amp;quot;fit_y, the no pooling model&amp;quot;) +
  coord_cartesian(xlim = c(0, .6)) +
  theme(axis.text.y   = element_text(hjust = 0),
        axis.ticks.y  = element_blank(),
        plot.subtitle = element_text(hjust = .5))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note our use of some handy convenience functions (i.e., &lt;code&gt;add_fitted_draws()&lt;/code&gt; and &lt;code&gt;stat_intervalh()&lt;/code&gt;) from the &lt;a href=&#34;https://github.com/mjskay/tidybayes&#34;&gt;tidybayes package&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This second plot is almost the same as the previous one, but this time based on the partial-pooling multilevel model.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;f_z &amp;lt;-
  baseball %&amp;gt;% 
  distinct(player) %&amp;gt;% 
  add_fitted_draws(fit_z, dpar = &amp;quot;mu&amp;quot;) %&amp;gt;% 
  left_join(baseball %&amp;gt;% 
              select(player, true_ba))

p2 &amp;lt;-
  f_z %&amp;gt;% 
  ggplot(aes(x = mu, y = reorder(player, true_ba))) +
  geom_vline(xintercept = mean(baseball$true_ba), color = &amp;quot;white&amp;quot;) +
  stat_intervalh(.width = .95, alpha = 1/3, color = nw_green) +
  stat_intervalh(.width = .50, alpha = 1/3, color = nw_green) +
  geom_point(data = baseball,
             aes(x = true_ba),
             size = 2, alpha = 3/4,
             color = navy_blue) +
  labs(x = &amp;quot;batting average&amp;quot;, 
       y = NULL,
       subtitle = &amp;quot;fit_z, the multilevel pooling model&amp;quot;) +
  coord_cartesian(xlim = c(0, .6)) +
  theme(axis.text.y   = element_text(hjust = 0),
        axis.ticks.y  = element_blank(),
        plot.subtitle = element_text(hjust = .5))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here we join them together.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(gridExtra)

grid.arrange(p1, p2, ncol = 2)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-02-23-stein-s-paradox-and-what-partial-pooling-can-do-for-you_files/figure-html/unnamed-chunk-24-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;p&gt;In both panels, the end-of-the-season batting averages (i.e., &lt;span class=&#34;math inline&#34;&gt;\(\theta\)&lt;/span&gt;) are the blue dots. The model-implied estimates are depicted by 95% and 50% interval bands (i.e., the lighter and darker green horizontal lines, respectively). The white line in the background marks off the mean of &lt;span class=&#34;math inline&#34;&gt;\(\theta\)&lt;/span&gt;. Although neither model was perfect, the multilevel model, our analogue to the James-Stein estimates, yielded predictions that appear both more valid and more precise.&lt;/p&gt;
&lt;p&gt;We might also compare the models by their prediction errors. Here we’ll subtract the end-of-the-season batting averages from the model estimates. But unlike with &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;z&lt;/code&gt; estimates, above, our &lt;code&gt;fit_y&lt;/code&gt; and &lt;code&gt;fit_z&lt;/code&gt; models yielded entire posterior distributions. Therefore, we’ll express our prediction errors in terms of error distributions, rather than single values.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# save the `fit_y` plot
p3 &amp;lt;-
  f_y %&amp;gt;% 
  # the error distribution is just the model-implied values minus 
  # the true end-of-season values
  mutate(error = mu - true_ba)  %&amp;gt;% 

  ggplot(aes(x = error, y = reorder(player, true_ba))) +
  geom_vline(xintercept = c(0, -.2, .2), size = c(1/2, 1/4, 1/4), 
             linetype = c(1, 3, 3), color = &amp;quot;white&amp;quot;) +
  geom_halfeyeh(point_interval = mean_qi, .width = .95,
                color = navy_blue, fill = alpha(nw_green, 2/3)) +
  coord_cartesian(xlim = c(-.35, .35)) +
  labs(x = &amp;quot;error&amp;quot;, 
       y = NULL,
       subtitle = &amp;quot;fit_y, the no pooling model&amp;quot;) +
  theme(axis.text.y   = element_text(hjust = 0),
        axis.ticks.y  = element_blank(),
        plot.subtitle = element_text(hjust = .5))

# save the `fit_z` plot
p4 &amp;lt;-
  f_z %&amp;gt;%   
  mutate(error = mu - true_ba)  %&amp;gt;% 
  
  ggplot(aes(x = error, y = reorder(player, true_ba))) +
  geom_vline(xintercept = c(0, -.2, .2), size = c(1/2, 1/4, 1/4), 
             linetype = c(1, 3, 3), color = &amp;quot;white&amp;quot;) +
  geom_halfeyeh(point_interval = mean_qi, .width = .95,
                color = navy_blue, fill = alpha(nw_green, 2/3)) +
  coord_cartesian(xlim = c(-.35, .35)) +
  labs(x = &amp;quot;error&amp;quot;, 
       y = NULL,
       subtitle = &amp;quot;fit_z, the multilevel pooling model&amp;quot;) +
  theme(axis.text.y   = element_text(hjust = 0),
        axis.ticks.y  = element_blank(),
        plot.subtitle = element_text(hjust = .5))

# now combine the two and behold
grid.arrange(p3, p4, ncol = 2)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-02-23-stein-s-paradox-and-what-partial-pooling-can-do-for-you_files/figure-html/unnamed-chunk-25-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;p&gt;For consistency, I’ve ordered the players along the y-axis the same as above. In both panels, we see the prediction error distribution for each player in green and then summarize those distributions in terms of their means and percentile-based 95% intervals. Since these are error distributions, we prefer them to be as close to zero as possible. Although neither model made perfect predictions, the overall errors in the multilevel model were clearly smaller. Much like with the James-Stein estimator, the partial pooling of the multilevel model made for better end-of-the-season estimates.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The paradoxical [consequence of Bayesian multilevel models] is that [they can contradict] this elementary law of statistical theory. If we have [two] or more baseball players, and if we are interested in predicting future batting averages for each of them, then [the Bayesian multilevel model can be better] than simply extrapolating from [the] separate averages. (p. 119)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This is another example of how the &lt;a href=&#34;https://en.wikipedia.org/wiki/KISS_principle&#34;&gt;KISS principle&lt;/a&gt; isn’t always the best bet with data analysis.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;next-steps&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Next steps&lt;/h2&gt;
&lt;p&gt;If you’re new to logistic regression, multilevel models or Bayesian statistics, I recommend any of the following texts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://xcelab.net/rm/statistical-rethinking/&#34;&gt;&lt;em&gt;Statistical Rethinking&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sites.google.com/site/doingbayesiandataanalysis/&#34;&gt;&lt;em&gt;Doing Bayesian Data Analysis&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.stat.columbia.edu/~gelman/arm/&#34;&gt;&lt;em&gt;Data Analysis Using Regression and Multilevel/Hierarchical Models&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And if you choose &lt;em&gt;Statistical Rethinking&lt;/em&gt;, do check out &lt;a href=&#34;https://www.youtube.com/channel/UCNJK6_DZvcMqNSzQdEkzvzA/playlists&#34;&gt;these great lectures&lt;/a&gt; on the text or &lt;a href=&#34;https://bookdown.org/connect/#/apps/1850/access&#34;&gt;my project translating the code in the text to brms and the tidyverse&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Also, don’t miss the provocative preprint by Davis-Stober, Dana and Rouder, &lt;a href=&#34;https://osf.io/2ukxj/&#34;&gt;&lt;em&gt;When are sample means meaningful? The role of modern estimation in psychological science&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;reference&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://statweb.stanford.edu/~ckirby/brad/other/Article1977.pdf&#34;&gt;Efron, B., &amp;amp; Morris, C. (1977). Stein’s paradox in statistics. &lt;em&gt;Scientific American, 236&lt;/em&gt;, 119–127, doi: 10.1038/scientificamerican0577-119&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;session-info&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Session info&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sessionInfo()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## R version 3.6.0 (2019-04-26)
## Platform: x86_64-apple-darwin15.6.0 (64-bit)
## Running under: macOS High Sierra 10.13.6
## 
## Matrix products: default
## BLAS:   /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRblas.0.dylib
## LAPACK: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRlapack.dylib
## 
## Random number generation:
##  RNG:     Mersenne-Twister 
##  Normal:  Inversion 
##  Sample:  Rounding 
##  
## locale:
## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
##  [1] gridExtra_2.3   brms_2.10.0     Rcpp_1.0.2      tidybayes_1.1.0 forcats_0.4.0   stringr_1.4.0  
##  [7] dplyr_0.8.3     purrr_0.3.2     readr_1.3.1     tidyr_1.0.0     tibble_2.1.3    ggplot2_3.2.1  
## [13] tidyverse_1.2.1
## 
## loaded via a namespace (and not attached):
##   [1] colorspace_1.4-1          ellipsis_0.2.0.1          ggridges_0.5.1           
##   [4] rsconnect_0.8.13          ggstance_0.3.2            markdown_1.0             
##   [7] base64enc_0.1-3           rstudioapi_0.10           rstan_2.19.2             
##  [10] svUnit_0.7-12             DT_0.7                    fansi_0.4.0              
##  [13] mvtnorm_1.0-11            lubridate_1.7.4           xml2_1.2.0               
##  [16] bridgesampling_0.6-0      knitr_1.23                shinythemes_1.1.2        
##  [19] zeallot_0.1.0             bayesplot_1.7.0           jsonlite_1.6             
##  [22] broom_0.5.2               shiny_1.3.2               compiler_3.6.0           
##  [25] httr_1.4.0                backports_1.1.4           assertthat_0.2.1         
##  [28] Matrix_1.2-17             lazyeval_0.2.2            cli_1.1.0                
##  [31] later_0.8.0               prettyunits_1.0.2         htmltools_0.3.6          
##  [34] tools_3.6.0               igraph_1.2.4.1            coda_0.19-2              
##  [37] gtable_0.3.0              glue_1.3.1                reshape2_1.4.3           
##  [40] cellranger_1.1.0          vctrs_0.2.0               nlme_3.1-139             
##  [43] blogdown_0.14             crosstalk_1.0.0           xfun_0.8                 
##  [46] ps_1.3.0                  rvest_0.3.4               mime_0.7                 
##  [49] miniUI_0.1.1.1            lifecycle_0.1.0           gtools_3.8.1             
##  [52] zoo_1.8-6                 scales_1.0.0              colourpicker_1.0         
##  [55] hms_0.4.2                 promises_1.0.1            Brobdingnag_1.2-6        
##  [58] parallel_3.6.0            inline_0.3.15             shinystan_2.5.0          
##  [61] yaml_2.2.0                StanHeaders_2.18.1-10     loo_2.1.0                
##  [64] stringi_1.4.3             dygraphs_1.1.1.6          pkgbuild_1.0.3           
##  [67] rlang_0.4.0               pkgconfig_2.0.2           matrixStats_0.54.0       
##  [70] evaluate_0.14             lattice_0.20-38           rstantools_1.5.1         
##  [73] htmlwidgets_1.3           labeling_0.3              processx_3.3.1           
##  [76] tidyselect_0.2.5          plyr_1.8.4                magrittr_1.5             
##  [79] bookdown_0.12             R6_2.4.0                  generics_0.0.2           
##  [82] pillar_1.4.2              haven_2.1.0               withr_2.1.2              
##  [85] xts_0.11-2                abind_1.4-5               modelr_0.1.4             
##  [88] crayon_1.3.4              arrayhelpers_1.0-20160527 utf8_1.1.4               
##  [91] rmarkdown_1.13            grid_3.6.0                readxl_1.3.1             
##  [94] callr_3.2.0               threejs_0.3.1             digest_0.6.20            
##  [97] xtable_1.8-4              httpuv_1.5.1              stats4_3.6.0             
## [100] munsell_0.5.0             viridisLite_0.3.0         shinyjs_1.0&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Bayesian Correlations: Let’s Talk Options.</title>
      <link>/post/bayesian-correlations-let-s-talk-options/</link>
      <pubDate>Sat, 16 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/bayesian-correlations-let-s-talk-options/</guid>
      <description>&lt;div id=&#34;tldr&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;tl;dr&lt;/h2&gt;
&lt;p&gt;There’s more than one way to fit a Bayesian correlation in brms.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;heres-the-deal.&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Here’s the deal.&lt;/h2&gt;
&lt;p&gt;In the last post, we considered how we might estimate correlations when our data contain influential outlier values. Our big insight was that if we use variants of Student’s &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;-distribution as the likelihood rather than the conventional normal distribution, our correlation estimates were less influenced by those outliers. And we mainly did that as Bayesians using the &lt;a href=&#34;https://github.com/paul-buerkner/brms&#34;&gt;brms package&lt;/a&gt;. Click &lt;a href=&#34;https://solomonkurz.netlify.com/post/bayesian-robust-correlations-with-brms-and-why-you-should-love-student-s-t/&#34;&gt;here&lt;/a&gt; for a refresher.&lt;/p&gt;
&lt;p&gt;Since the brms package is designed to fit regression models, &lt;a href=&#34;https://twitter.com/tjmahr/status/1094808459239981056&#34;&gt;it can be surprising&lt;/a&gt; when you discover it’s handy for correlations, too. In short, you can fit them using a few tricks based on the &lt;a href=&#34;https://cran.r-project.org/web/packages/brms/vignettes/brms_multivariate.html&#34;&gt;multivariate syntax&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Shortly after uploading the post, it occurred to me we had more options and it might be useful to walk through them a bit.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;i-assume-things.&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;I assume things.&lt;/h2&gt;
&lt;p&gt;For this post, I’m presuming you are vaguely familiar with linear regression–both univariate and multivariate–, have a little background with Bayesian statistics, and have used Paul Bürkner’s brms packge. As you might imagine, all code in is &lt;a href=&#34;https://www.r-bloggers.com/why-use-r-five-reasons/&#34;&gt;R&lt;/a&gt;, with a heavy use of the &lt;a href=&#34;http://style.tidyverse.org&#34;&gt;tidyverse&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;we-need-data.&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;We need data.&lt;/h2&gt;
&lt;p&gt;First, we’ll load our main packages.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(mvtnorm)
library(brms)
library(tidyverse)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We’ll use the &lt;a href=&#34;https://cran.r-project.org/web/packages/mvtnorm/index.html&#34;&gt;mvtnorm package&lt;/a&gt; to simulate three positively correlated variables.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;m &amp;lt;- c(10, 15, 20)  # the means
s &amp;lt;- c(10, 20, 30)  # the sigmas
r &amp;lt;- c(.9, .6, .3)  # the correlations

# here&amp;#39;s the variance/covariance matrix
v &amp;lt;- 
  matrix(c((s[1] * s[1]),        (s[2] * s[1] * r[1]), (s[3] * s[1] * r[2]),
           (s[2] * s[1] * r[1]), (s[2] * s[2]),        (s[3] * s[2] * r[3]),
           (s[3] * s[1] * r[2]), (s[3] * s[2] * r[3]), (s[3] * s[3])),
         nrow = 3, ncol = 3)

# after setting our seed, we&amp;#39;re ready to simulate with `rmvnorm()`
set.seed(1)
d &amp;lt;- 
  rmvnorm(n = 50, mean = m, sigma = v) %&amp;gt;% 
  as_tibble() %&amp;gt;% 
  set_names(&amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;, &amp;quot;z&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Our data look like so.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(GGally)
theme_set(theme_gray() +
            theme(panel.grid = element_blank()))

d %&amp;gt;% 
  ggpairs()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-02-16-bayesian-correlations-let-s-talk-options_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;384&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Do note the Pearson’s correlation coefficients in the upper triangle.&lt;/p&gt;
&lt;p&gt;In order to exploit all the methods we’ll cover in this post, we need to standardize our data. Here we do so by hand using the typical formula&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[z_{x_i} = \frac{x_i - \overline x}{s_x}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;where &lt;span class=&#34;math inline&#34;&gt;\(\overline x\)&lt;/span&gt; is the observed mean and &lt;span class=&#34;math inline&#34;&gt;\(s_x\)&lt;/span&gt; is the observed standard deviation.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;d &amp;lt;-
  d %&amp;gt;% 
  mutate(x_s = (x - mean(x)) / sd(x),
         y_s = (y - mean(y)) / sd(y),
         z_s = (z - mean(z)) / sd(z))

head(d)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 6
##       x     y     z    x_s      y_s    z_s
##   &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
## 1  3.90  11.5 -6.90 -0.723 -0.308   -0.928
## 2 17.7   29.5  4.01  0.758  0.653   -0.512
## 3 20.4   33.8 41.5   1.05   0.886    0.917
## 4 20.3   42.1 34.8   1.04   1.33     0.663
## 5 -3.64 -26.8 43.5  -1.53  -2.36     0.994
## 6 13.9   17.3 47.6   0.347  0.00255  1.15&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are at least two broad ways to get correlations out of standardized data in brms. One way uses the typical univariate syntax. The other way is an extension of the multivariate &lt;code&gt;cbind()&lt;/code&gt; approach. Let’s start univariate.&lt;/p&gt;
&lt;p&gt;And for a point of clarification, we’re presuming the Gaussian likelihood for all the examples in this post.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;univariate&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Univariate&lt;/h2&gt;
&lt;p&gt;If you fit a simple univariate model with standardized data and a single predictor, the coefficient for the slope will be in a correlation-like metric. Happily, since the data are all standardized, it’s easy to use &lt;a href=&#34;https://github.com/stan-dev/stan/wiki/Prior-Choice-Recommendations&#34;&gt;regularizing priors&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;f1 &amp;lt;- 
  brm(data = d, 
      family = gaussian,
      y_s ~ 1 + x_s,
      prior = c(prior(normal(0, 1), class = Intercept),
                prior(normal(0, 1), class = b),
                prior(normal(0, 1), class = sigma)),
      chains = 4, cores = 4, 
      seed = 1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Take a look at the model summary.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;print(f1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  Family: gaussian 
##   Links: mu = identity; sigma = identity 
## Formula: y_s ~ 1 + x_s 
##    Data: d (Number of observations: 50) 
## Samples: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;
##          total post-warmup samples = 4000
## 
## Population-Level Effects: 
##           Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
## Intercept     0.00      0.06    -0.11     0.12 1.00     3782     2599
## x_s           0.91      0.06     0.79     1.02 1.00     3847     2946
## 
## Family Specific Parameters: 
##       Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
## sigma     0.42      0.04     0.35     0.52 1.00     3811     2729
## 
## Samples were drawn using sampling(NUTS). For each parameter, Eff.Sample 
## is a crude measure of effective sample size, and Rhat is the potential 
## scale reduction factor on split chains (at convergence, Rhat = 1).&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The ‘Population-Level Effects’ has the summary information for our intercept and slope. Notice how our &lt;code&gt;x_s&lt;/code&gt; slope is the same as the Pearson’s correlation.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cor(d$x, d$y)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.9119708&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since this approach only yields one correlation at a time, we have to fit two more models to get the other two correlations. To do so with haste, we can use the &lt;code&gt;update()&lt;/code&gt; syntax.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;f2 &amp;lt;-
  update(f1,
         newdata = d,
         formula = z_s ~ 1 + x_s)

f3 &amp;lt;-
  update(f2,
         newdata = d,
         formula = z_s ~ 1 + y_s)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With the &lt;code&gt;fixef()&lt;/code&gt; function, we can easily isolate the &lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt; estimates.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fixef(f2)[2, ]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  Estimate Est.Error      Q2.5     Q97.5 
## 0.5836596 0.1155676 0.3569717 0.8123137&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fixef(f3)[2, ]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   Estimate  Est.Error       Q2.5      Q97.5 
## 0.31047431 0.13742697 0.03672921 0.57820500&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There’s another thing I’d like to point out. Plotting the model results will help make the point.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# define the predictor values you&amp;#39;d like the fitted values for
nd &amp;lt;- tibble(x_s = seq(from = -3, to = 3, length.out = d %&amp;gt;% nrow()))

# wrangle
fitted(f1,
       newdata = nd) %&amp;gt;% 
  as_tibble() %&amp;gt;% 
  bind_cols(nd) %&amp;gt;% 
  
  # plot
  ggplot(aes(x_s)) +
  geom_vline(xintercept = 0, color = &amp;quot;white&amp;quot;) +
  geom_hline(yintercept = 0, color = &amp;quot;white&amp;quot;) +
  geom_point(data = d,
             aes(y = y_s)) +
  geom_smooth(aes(y = Estimate, ymin = Q2.5, ymax = Q97.5),
              stat = &amp;quot;identity&amp;quot;,
              alpha = 1/4, size = 1/2) +
  coord_cartesian(xlim = range(d$x_s),
                  ylim = range(d$y_s))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-02-16-bayesian-correlations-let-s-talk-options_files/figure-html/unnamed-chunk-8-1.png&#34; width=&#34;336&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The blue line is the posterior mean and the surrounding gray ribbon depicts the 95% posterior interval. Notice how the data and their respective fitted lines pass through [0, 0]? This is a consequence of modeling standardized data. We should always expect the intercept of a model like this to be 0. Here are the intercept summaries for all three models.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fixef(f1)[&amp;quot;Intercept&amp;quot;, ] %&amp;gt;% round(3)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  Estimate Est.Error      Q2.5     Q97.5 
##     0.001     0.060    -0.114     0.119&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fixef(f2)[&amp;quot;Intercept&amp;quot;, ] %&amp;gt;% round(3)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  Estimate Est.Error      Q2.5     Q97.5 
##     0.002     0.117    -0.226     0.233&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fixef(f3)[&amp;quot;Intercept&amp;quot;, ] %&amp;gt;% round(3)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  Estimate Est.Error      Q2.5     Q97.5 
##     0.000     0.134    -0.261     0.266&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Within simulation error, they’re all centered on zero. So instead of estimating the intercept, why not just bake that into the models? Here we refit the models by fixing the intercept for each to zero.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;f4 &amp;lt;-
  update(f1,
         formula = y_s ~ 0 + x_s)

f5 &amp;lt;-
  update(f4,
         newdata = d,
         formula = z_s ~ 0 + x_s)

f6 &amp;lt;-
  update(f4,
         newdata = d,
         formula = z_s ~ 0 + y_s)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let’s take a look at the summary for the first.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;print(f4)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  Family: gaussian 
##   Links: mu = identity; sigma = identity 
## Formula: y_s ~ x_s - 1 
##    Data: d (Number of observations: 50) 
## Samples: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;
##          total post-warmup samples = 4000
## 
## Population-Level Effects: 
##     Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
## x_s     0.91      0.06     0.79     1.03 1.00     2390     2083
## 
## Family Specific Parameters: 
##       Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
## sigma     0.42      0.04     0.35     0.51 1.00     2791     2916
## 
## Samples were drawn using sampling(NUTS). For each parameter, Eff.Sample 
## is a crude measure of effective sample size, and Rhat is the potential 
## scale reduction factor on split chains (at convergence, Rhat = 1).&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Even though it may have seemed like we substantially changed the models by fixing the intercepts to 0, the summaries are essentially the same as when we estimated the intercepts. Here we’ll confirm the summaries with a plot, like above.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# wrangle
fitted(f4,
       newdata = nd) %&amp;gt;% 
  as_tibble() %&amp;gt;% 
  bind_cols(nd) %&amp;gt;% 
  
  # plot
  ggplot(aes(x_s)) +
  geom_vline(xintercept = 0, color = &amp;quot;white&amp;quot;) +
  geom_hline(yintercept = 0, color = &amp;quot;white&amp;quot;) +
  geom_point(data = d,
             aes(y = y_s)) +
  geom_smooth(aes(y = Estimate, ymin = Q2.5, ymax = Q97.5),
              stat = &amp;quot;identity&amp;quot;,
              alpha = 1/4, size = 1/2) +
  coord_cartesian(xlim = range(d$x_s),
                  ylim = range(d$y_s))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-02-16-bayesian-correlations-let-s-talk-options_files/figure-html/unnamed-chunk-11-1.png&#34; width=&#34;336&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The difference is subtle. By fixing the intercepts at 0, we estimated the slopes (i.e., the correlations) with increased precision as demonstrated by the slightly smaller posterior standard deviations (i.e., the values in the ‘Est.Error’ columns).&lt;/p&gt;
&lt;p&gt;Here are the correlation summaries for those last three models.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fixef(f4) %&amp;gt;% round(3)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     Estimate Est.Error  Q2.5 Q97.5
## x_s    0.909      0.06 0.789 1.033&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fixef(f5) %&amp;gt;% round(3)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     Estimate Est.Error  Q2.5 Q97.5
## x_s    0.581     0.117 0.356 0.809&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fixef(f6) %&amp;gt;% round(3)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     Estimate Est.Error  Q2.5 Q97.5
## y_s    0.311     0.137 0.047 0.585&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But anyway, you get the idea. If you want to estimate a correlation in brms using simple univariate syntax, just (a) standardize the data and (b) fit a univariate model with or without an intercept. The slop will be in a correlation-like metric.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;lets-go-multivariate.&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Let’s go multivariate.&lt;/h2&gt;
&lt;p&gt;If you don’t recall the steps to fit correlations in brms with the multivariate syntax, here they are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;List the variables you’d like correlations for within &lt;code&gt;cbind()&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Place the &lt;code&gt;cbind()&lt;/code&gt; function within the left side of the model formula.&lt;/li&gt;
&lt;li&gt;On the right side of the model formula, indicate you only want intercepts (i.e., &lt;code&gt;~ 1&lt;/code&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;f7 &amp;lt;- 
  brm(data = d, 
      family = gaussian,
      cbind(x_s, y_s, z_s) ~ 1,
      prior = c(prior(normal(0, 1), class = Intercept),
                prior(normal(1, 1), class = sigma, resp = xs),
                prior(normal(1, 1), class = sigma, resp = ys),
                prior(normal(1, 1), class = sigma, resp = zs),
                prior(lkj(2), class = rescor)),
      chains = 4, cores = 4, 
      seed = 1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Behold the summary.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;print(f7)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  Family: MV(gaussian, gaussian, gaussian) 
##   Links: mu = identity; sigma = identity
##          mu = identity; sigma = identity
##          mu = identity; sigma = identity 
## Formula: x_s ~ 1 
##          y_s ~ 1 
##          z_s ~ 1 
##    Data: d (Number of observations: 50) 
## Samples: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;
##          total post-warmup samples = 4000
## 
## Population-Level Effects: 
##              Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
## xs_Intercept    -0.01      0.13    -0.27     0.24 1.00     2359     2462
## ys_Intercept    -0.01      0.13    -0.28     0.25 1.00     2538     2458
## zs_Intercept    -0.00      0.14    -0.28     0.28 1.00     3096     2643
## 
## Family Specific Parameters: 
##          Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
## sigma_xs     0.99      0.10     0.82     1.19 1.00     2273     2300
## sigma_ys     1.00      0.10     0.83     1.23 1.00     2294     2296
## sigma_zs     1.02      0.10     0.84     1.25 1.00     3161     2751
## 
## Residual Correlations: 
##               Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
## rescor(xs,ys)     0.90      0.03     0.83     0.94 1.00     2432     2598
## rescor(xs,zs)     0.55      0.09     0.35     0.71 1.00     3190     2990
## rescor(ys,zs)     0.25      0.12     0.01     0.48 1.00     2919     2686
## 
## Samples were drawn using sampling(NUTS). For each parameter, Eff.Sample 
## is a crude measure of effective sample size, and Rhat is the potential 
## scale reduction factor on split chains (at convergence, Rhat = 1).&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Look at the ‘Residual Correlations:’ section at the bottom of the output. Since there are no predictors in the model, the residual correlations are just correlations. Now notice how the intercepts in this model are also hovering around 0, just like in our univariate models. Yep, we can fix those, too.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;f8 &amp;lt;- 
  brm(data = d, 
      family = gaussian,
      cbind(x_s, y_s, z_s) ~ 0,
      prior = c(prior(normal(1, 1), class = sigma, resp = xs),
                prior(normal(1, 1), class = sigma, resp = ys),
                prior(normal(1, 1), class = sigma, resp = zs),
                prior(lkj(2), class = rescor)),
      chains = 4, cores = 4, 
      seed = 1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Without the intercepts, the rest of the model is the same within simulation variance.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;print(f8)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  Family: MV(gaussian, gaussian, gaussian) 
##   Links: mu = identity; sigma = identity
##          mu = identity; sigma = identity
##          mu = identity; sigma = identity 
## Formula: x_s ~ 0 
##          y_s ~ 0 
##          z_s ~ 0 
##    Data: d (Number of observations: 50) 
## Samples: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;
##          total post-warmup samples = 4000
## 
## Family Specific Parameters: 
##          Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
## sigma_xs     0.98      0.09     0.81     1.19 1.00     1906     1751
## sigma_ys     0.99      0.10     0.82     1.20 1.00     1948     1975
## sigma_zs     1.02      0.10     0.84     1.24 1.00     2842     2253
## 
## Residual Correlations: 
##               Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
## rescor(xs,ys)     0.90      0.03     0.83     0.94 1.00     2399     2234
## rescor(xs,zs)     0.55      0.10     0.35     0.71 1.00     2631     2324
## rescor(ys,zs)     0.26      0.13     0.01     0.50 1.00     2567     1730
## 
## Samples were drawn using sampling(NUTS). For each parameter, Eff.Sample 
## is a crude measure of effective sample size, and Rhat is the potential 
## scale reduction factor on split chains (at convergence, Rhat = 1).&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you wanna get silly, we can prune even further. Did you notice how the estimates for &lt;span class=&#34;math inline&#34;&gt;\(\sigma\)&lt;/span&gt; are all hovering around 1? Since we have no predictors, &lt;span class=&#34;math inline&#34;&gt;\(\sigma\)&lt;/span&gt; is just an estimate of the population standard deviation. And since we’re working with standardized data, the population standard deviation has to be 1. Any other estimate would be nonsensical. So why not fix it to 1?&lt;/p&gt;
&lt;p&gt;With brms, we can fix those &lt;span class=&#34;math inline&#34;&gt;\(\sigma\)&lt;/span&gt;s to 1 with a trick of the nonlinear &lt;a href=&#34;https://cran.r-project.org/web/packages/brms/vignettes/brms_distreg.html&#34;&gt;distributional modeling syntax&lt;/a&gt;. Recall when you model &lt;span class=&#34;math inline&#34;&gt;\(\sigma\)&lt;/span&gt;, the brms default is to actually model its log. As is turns out, the log of 1 is zero.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;log(1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here’s how to make use of that within &lt;code&gt;brm()&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;f9 &amp;lt;-
  brm(data = d, 
      family = gaussian,
      bf(cbind(x_s, y_s, z_s) ~ 0,
         sigma ~ 0),
      prior = c(prior(lkj(2), class = rescor)),
      chains = 4, cores = 4, 
      seed = 1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Other than the &lt;code&gt;sigma ~ 0&lt;/code&gt; syntax, the main thing to notice is we’ve wrapped the entire model &lt;code&gt;formula&lt;/code&gt; into the &lt;code&gt;bf()&lt;/code&gt; function. Here are the results.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;print(f9)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  Family: MV(gaussian, gaussian, gaussian) 
##   Links: mu = identity; sigma = log
##          mu = identity; sigma = log
##          mu = identity; sigma = log 
## Formula: x_s ~ 0 
##          sigma ~ 0
##          y_s ~ 0 
##          sigma ~ 0
##          z_s ~ 0 
##          sigma ~ 0
##    Data: d (Number of observations: 50) 
## Samples: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;
##          total post-warmup samples = 4000
## 
## Residual Correlations: 
##               Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
## rescor(xs,ys)     0.91      0.02     0.87     0.93 1.00     2621     2710
## rescor(xs,zs)     0.57      0.07     0.42     0.69 1.00     3307     2727
## rescor(ys,zs)     0.29      0.09     0.11     0.47 1.00     3095     2393
## 
## Samples were drawn using sampling(NUTS). For each parameter, Eff.Sample 
## is a crude measure of effective sample size, and Rhat is the potential 
## scale reduction factor on split chains (at convergence, Rhat = 1).&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The correlations are the only things left in the model.&lt;/p&gt;
&lt;p&gt;Just to be clear, the multivariate approach does not require standardized data. To demonstrate, here we refit &lt;code&gt;f7&lt;/code&gt;, but with the unstandardized variables. And, since we’re no longer in the standardized metric, we’ll be less certain with our priors.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;f10 &amp;lt;- 
  brm(data = d, 
      family = gaussian,
      cbind(x, y, z) ~ 1,
      prior = c(prior(normal(0, 10), class = Intercept),
                prior(student_t(3, 0, 10), class = sigma, resp = x),
                prior(student_t(3, 0, 10), class = sigma, resp = y),
                prior(student_t(3, 0, 10), class = sigma, resp = z),
                prior(lkj(2), class = rescor)),
      chains = 4, cores = 4, 
      seed = 1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;See, the ‘rescor()’ results are about the same as with &lt;code&gt;f7&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;print(f10)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  Family: MV(gaussian, gaussian, gaussian) 
##   Links: mu = identity; sigma = identity
##          mu = identity; sigma = identity
##          mu = identity; sigma = identity 
## Formula: x ~ 1 
##          y ~ 1 
##          z ~ 1 
##    Data: d (Number of observations: 50) 
## Samples: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;
##          total post-warmup samples = 4000
## 
## Population-Level Effects: 
##             Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
## x_Intercept     9.64      1.20     7.29    12.00 1.00     1864     2582
## y_Intercept    15.57      2.47    10.69    20.34 1.00     2079     2631
## z_Intercept    14.85      3.38     8.00    21.42 1.00     2780     2773
## 
## Family Specific Parameters: 
##         Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
## sigma_x     8.99      0.87     7.50    10.91 1.00     2108     2278
## sigma_y    18.24      1.81    15.18    22.05 1.00     2114     2240
## sigma_z    26.09      2.62    21.58    31.77 1.00     3099     2736
## 
## Residual Correlations: 
##             Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
## rescor(x,y)     0.89      0.03     0.83     0.94 1.00     2252     2314
## rescor(x,z)     0.54      0.09     0.34     0.70 1.00     3067     2982
## rescor(y,z)     0.24      0.12    -0.00     0.47 1.00     2826     2709
## 
## Samples were drawn using sampling(NUTS). For each parameter, Eff.Sample 
## is a crude measure of effective sample size, and Rhat is the potential 
## scale reduction factor on split chains (at convergence, Rhat = 1).&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;its-time-to-compare-methods.&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;It’s time to compare methods.&lt;/h2&gt;
&lt;p&gt;To recap, we’ve compared several ways to fit correlations in brms. Some of the methods were with univariate syntax, others were with the multivariate syntax. Some of the models had all free parameters, others included fixed intercepts and sigmas. Whereas all the univariate models required standardized data, the multivariate approach can work with unstandardized data, too.&lt;/p&gt;
&lt;p&gt;Now it might be of help to compare the results from each of the methods to get a sense of which ones you might prefer. Before we do so, we’ll define a couple custom functions to streamline the data wrangling.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;get_rho &amp;lt;- function(fit) {
  posterior_samples(fit) %&amp;gt;% 
    select(starts_with(&amp;quot;b_&amp;quot;), -contains(&amp;quot;Intercept&amp;quot;)) %&amp;gt;% 
    set_names(&amp;quot;rho&amp;quot;) 
}

get_rescor &amp;lt;- function(fit) {
  posterior_samples(fit) %&amp;gt;% 
    select(starts_with(&amp;quot;rescor&amp;quot;)) %&amp;gt;% 
    set_names(&amp;quot;x with y&amp;quot;, &amp;quot;x with z&amp;quot;, &amp;quot;y with z&amp;quot;) %&amp;gt;% 
    gather(label, rho) %&amp;gt;% 
    select(rho, label)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now let’s put those functions to work and plot.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidybayes)

# collect the posteriors from the univariate models
tibble(name = str_c(&amp;quot;f&amp;quot;, 1:6)) %&amp;gt;% 
  mutate(fit = map(name, get)) %&amp;gt;% 
  mutate(rho = map(fit, get_rho)) %&amp;gt;% 
  unnest(rho) %&amp;gt;% 
  mutate(predictor = rep(c(&amp;quot;x&amp;quot;, &amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;), each = 4000) %&amp;gt;% rep(., times = 2),
         criterion = rep(c(&amp;quot;y&amp;quot;, &amp;quot;z&amp;quot;, &amp;quot;z&amp;quot;), each = 4000) %&amp;gt;% rep(., times = 2)) %&amp;gt;% 
  mutate(label = str_c(predictor, &amp;quot; with &amp;quot;, criterion)) %&amp;gt;% 
  select(-c(predictor:criterion)) %&amp;gt;% 
  # add in the posteriors from the multivariate models
  bind_rows(
    tibble(name = str_c(&amp;quot;f&amp;quot;, 7:10)) %&amp;gt;% 
      mutate(fit = map(name, get)) %&amp;gt;% 
      mutate(post = map(fit, get_rescor)) %&amp;gt;% 
      unnest(post)
  ) %&amp;gt;% 
  # wrangle a bit just to make the y axis easier to understand
  mutate(name = factor(name, 
                       levels = c(str_c(&amp;quot;f&amp;quot;, 1:10)),
                       labels = c(&amp;quot;1. standardized, univariate&amp;quot;,
                                  &amp;quot;2. standardized, univariate&amp;quot;,
                                  &amp;quot;3. standardized, univariate&amp;quot;,
                                  &amp;quot;4. standardized, univariate, fixed intercepts&amp;quot;,
                                  &amp;quot;5. standardized, univariate, fixed intercepts&amp;quot;,
                                  &amp;quot;6. standardized, univariate, fixed intercepts&amp;quot;,
                                  &amp;quot;7. standardized, multivariate, fixed intercepts&amp;quot;,
                                  &amp;quot;8. standardized, multivariate, fixed intercepts&amp;quot;,
                                  &amp;quot;9. standardized, multivariate, fixed intercepts/sigmas&amp;quot;,
                                  &amp;quot;10. unstandardized, multivariate&amp;quot;))) %&amp;gt;%
  
  # plot
  ggplot(aes(x = rho, y = name)) +
  geom_vline(data = tibble(label = c(&amp;quot;x with y&amp;quot;, &amp;quot;x with z&amp;quot;, &amp;quot;y with z&amp;quot;),
                           rho   = r),
             aes(xintercept = rho), color = &amp;quot;white&amp;quot;) +
  geom_halfeyeh(.width = .95, size = 5/4) +
  scale_x_continuous(breaks = c(0, r)) +
  labs(x = expression(rho),
       y = NULL) +
  coord_cartesian(0:1) +
  theme(axis.ticks.y = element_blank(),
        axis.text.y  = element_text(hjust = 0)) +
  facet_wrap(~label, ncol = 3)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-02-16-bayesian-correlations-let-s-talk-options_files/figure-html/unnamed-chunk-19-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;p&gt;To my eye, a few patterns emerged. First, the point estimates were about the same across methods. Second, fixing the intercepts didn’t seem to effect things, much. But, third, it appears that fixing the sigmas in the multivariate models did narrow the posteriors a bit.&lt;/p&gt;
&lt;p&gt;Fourth, and perhaps most importantly, notice how the posteriors for the multivariate models were more asymmetric when they approached 1. Hopefully this makes intuitive sense. Correlations are bound between -1 and 1. However, standardized regression coefficients are not so bound. Accordingly, notice how the posteriors from the univariate models stayed symmetric when approaching 1 and some of their right tails even crossed over 1. So while the univariate approach did a reasonable job capturing the correlation point estimates, their posteriors weren’t quite in a correlation metric. Alternately, the univariate approach did make it convenient to express the correlations with fitted regression lines in scatter plots.&lt;/p&gt;
&lt;p&gt;Both univariate and multivariate approaches appear to have their strengths and weaknesses. Choose which methods seems most appropriate for your correlation needs.&lt;/p&gt;
&lt;p&gt;Happy modeling.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sessionInfo()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## R version 3.6.0 (2019-04-26)
## Platform: x86_64-apple-darwin15.6.0 (64-bit)
## Running under: macOS High Sierra 10.13.6
## 
## Matrix products: default
## BLAS:   /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRblas.0.dylib
## LAPACK: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRlapack.dylib
## 
## Random number generation:
##  RNG:     Mersenne-Twister 
##  Normal:  Inversion 
##  Sample:  Rounding 
##  
## locale:
## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
##  [1] tidybayes_1.1.0 GGally_1.4.0    forcats_0.4.0   stringr_1.4.0  
##  [5] dplyr_0.8.3     purrr_0.3.2     readr_1.3.1     tidyr_1.0.0    
##  [9] tibble_2.1.3    ggplot2_3.2.1   tidyverse_1.2.1 brms_2.10.0    
## [13] Rcpp_1.0.2      mvtnorm_1.0-11 
## 
## loaded via a namespace (and not attached):
##   [1] colorspace_1.4-1          ellipsis_0.2.0.1         
##   [3] ggridges_0.5.1            rsconnect_0.8.13         
##   [5] ggstance_0.3.2            markdown_1.0             
##   [7] base64enc_0.1-3           rstudioapi_0.10          
##   [9] rstan_2.19.2              svUnit_0.7-12            
##  [11] DT_0.7                    fansi_0.4.0              
##  [13] lubridate_1.7.4           xml2_1.2.0               
##  [15] bridgesampling_0.6-0      codetools_0.2-16         
##  [17] knitr_1.23                shinythemes_1.1.2        
##  [19] zeallot_0.1.0             bayesplot_1.7.0          
##  [21] jsonlite_1.6              broom_0.5.2              
##  [23] shiny_1.3.2               compiler_3.6.0           
##  [25] httr_1.4.0                backports_1.1.4          
##  [27] assertthat_0.2.1          Matrix_1.2-17            
##  [29] lazyeval_0.2.2            cli_1.1.0                
##  [31] later_0.8.0               htmltools_0.3.6          
##  [33] prettyunits_1.0.2         tools_3.6.0              
##  [35] igraph_1.2.4.1            coda_0.19-2              
##  [37] gtable_0.3.0              glue_1.3.1               
##  [39] reshape2_1.4.3            cellranger_1.1.0         
##  [41] vctrs_0.2.0               nlme_3.1-139             
##  [43] blogdown_0.14             crosstalk_1.0.0          
##  [45] xfun_0.8                  ps_1.3.0                 
##  [47] rvest_0.3.4               mime_0.7                 
##  [49] miniUI_0.1.1.1            lifecycle_0.1.0          
##  [51] gtools_3.8.1              zoo_1.8-6                
##  [53] scales_1.0.0              colourpicker_1.0         
##  [55] hms_0.4.2                 promises_1.0.1           
##  [57] Brobdingnag_1.2-6         parallel_3.6.0           
##  [59] inline_0.3.15             shinystan_2.5.0          
##  [61] RColorBrewer_1.1-2        yaml_2.2.0               
##  [63] gridExtra_2.3             loo_2.1.0                
##  [65] StanHeaders_2.18.1-10     reshape_0.8.8            
##  [67] stringi_1.4.3             dygraphs_1.1.1.6         
##  [69] pkgbuild_1.0.3            rlang_0.4.0              
##  [71] pkgconfig_2.0.2           matrixStats_0.54.0       
##  [73] evaluate_0.14             lattice_0.20-38          
##  [75] rstantools_1.5.1          htmlwidgets_1.3          
##  [77] labeling_0.3              processx_3.3.1           
##  [79] tidyselect_0.2.5          plyr_1.8.4               
##  [81] magrittr_1.5              bookdown_0.12            
##  [83] R6_2.4.0                  generics_0.0.2           
##  [85] pillar_1.4.2              haven_2.1.0              
##  [87] withr_2.1.2               xts_0.11-2               
##  [89] abind_1.4-5               modelr_0.1.4             
##  [91] crayon_1.3.4              arrayhelpers_1.0-20160527
##  [93] utf8_1.1.4                rmarkdown_1.13           
##  [95] grid_3.6.0                readxl_1.3.1             
##  [97] callr_3.2.0               threejs_0.3.1            
##  [99] digest_0.6.20             xtable_1.8-4             
## [101] httpuv_1.5.1              stats4_3.6.0             
## [103] munsell_0.5.0             shinyjs_1.0&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Bayesian robust correlations with brms (and why you should love Student’s $t$)</title>
      <link>/post/bayesian-robust-correlations-with-brms-and-why-you-should-love-student-s-t/</link>
      <pubDate>Sun, 10 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/bayesian-robust-correlations-with-brms-and-why-you-should-love-student-s-t/</guid>
      <description>&lt;p&gt;[edited June 18, 2019]&lt;/p&gt;
&lt;p&gt;In this post, we’ll show how Student’s &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;-distribution can produce better correlation estimates when your data have outliers. As is often the case, we’ll do so as Bayesians.&lt;/p&gt;
&lt;p&gt;This post is a direct consequence of Adrian Baez-Ortega’s great blog, “&lt;a href=&#34;https://baezortega.github.io/2018/05/28/robust-correlation/&#34;&gt;Bayesian robust correlation with Stan in R (and why you should use Bayesian methods)&lt;/a&gt;”. Baez-Ortega worked out the approach and code for direct use with &lt;a href=&#34;http://mc-stan.org&#34;&gt;Stan&lt;/a&gt; computational environment. That solution is great because Stan is free, open source, and very flexible. However, Stan’s interface might be prohibitively technical for non-statistician users. Happily, the &lt;a href=&#34;https://github.com/paul-buerkner/brms&#34;&gt;brms&lt;/a&gt; package allows users to access the computational power of Stan through a simpler interface. In this post, we show how to extend Baez-Ortega’s method to brms. To pay respects where they’re due, the synthetic data, priors, and other model settings are largely the same as those Baez-Ortega used in his blog.&lt;/p&gt;
&lt;div id=&#34;i-make-assumptions&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;I make assumptions&lt;/h2&gt;
&lt;p&gt;For this post, I’m presuming you are vaguely familiar with linear regression, know about the basic differences between frequentist and Bayesian approaches to fitting models, and have a sense that the issue of outlier values is a pickle worth contending with. All code in is &lt;a href=&#34;https://www.r-bloggers.com/why-use-r-five-reasons/&#34;&gt;R&lt;/a&gt;, with a heavy use of the &lt;a href=&#34;http://style.tidyverse.org&#34;&gt;tidyverse&lt;/a&gt;–which you might learn a lot about &lt;a href=&#34;http://r4ds.had.co.nzhttp://r4ds.had.co.nz&#34;&gt;here, especially chapter 5&lt;/a&gt;–, and, of course, Bürkner’s &lt;a href=&#34;https://github.com/paul-buerkner/brms&#34;&gt;brms&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If you’d like a warmup, consider checking out my related post, &lt;a href=&#34;https://solomonkurz.netlify.com/post/robust-linear-regression-with-the-robust-student-s-t-distribution/&#34;&gt;Robust Linear Regression with Student’s &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;-Distribution&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;whats-the-deal&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;What’s the deal?&lt;/h2&gt;
&lt;p&gt;Pearson’s correlations are designed to quantify the linear relationship between two normally distributed variables. The normal distribution and its multivariate generalization, the multivariate normal distribution, are sensitive to outliers. When you have well-behaved synthetic data, this isn’t an issue. But if you work real-world data, this can be a problem. One can have data for which the vast majority of cases are well-characterized by a nice liner relationship, but have a few odd cases for which that relationship does not hold. And if those odd cases happen to be overly influential–sometimes called leverage points–the resulting Pearson’s correlation coefficient might look off.&lt;/p&gt;
&lt;p&gt;Recall that the normal distribution is a special case of Student’s &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;-distribution with the &lt;span class=&#34;math inline&#34;&gt;\(\nu\)&lt;/span&gt; parameter (i.e., &lt;em&gt;nu&lt;/em&gt;, degree of freedom) set to infinity. As it turns out, when &lt;span class=&#34;math inline&#34;&gt;\(\nu\)&lt;/span&gt; is small, Student’s &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;-distribution is more robust to multivariate outliers. It’s less influenced by them. I’m not going to cover why in any detail. For that you’ve got &lt;a href=&#34;https://baezortega.github.io/2018/05/28/robust-correlation/&#34;&gt;Baez-Ortega’s blog&lt;/a&gt;, an even earlier blog from &lt;a href=&#34;http://www.sumsar.net/blog/2013/08/bayesian-estimation-of-correlation/&#34;&gt;Rasmus Bååth&lt;/a&gt;, and textbook treatments on the topic by &lt;a href=&#34;http://www.stat.columbia.edu/~gelman/arm/&#34;&gt;Gelman &amp;amp; Hill (2007, chapter 6)&lt;/a&gt; and &lt;a href=&#34;https://sites.google.com/site/doingbayesiandataanalysis/&#34;&gt;Kruschke (2014, chapter 16)&lt;/a&gt;. Here we’ll get a quick sense of how vulnerable Pearson’s correlations–with their reliance on the Gaussian–are to outliers, we’ll demonstrate how fitting correlations within the Bayesian paradigm using the conventional Gaussian likelihood is similarly vulnerable to distortion, and then see how Student’s &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;-distribution can save the day. And importantly, we’ll do the bulk of this with the brms package.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;we-need-data&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;We need data&lt;/h2&gt;
&lt;p&gt;To start off, we’ll make a multivariate normal simulated data set using the same steps Baez-Ortega’s used.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(mvtnorm)
library(tidyverse)

sigma &amp;lt;- c(20, 40)  # the variances
rho   &amp;lt;- -.95       # the desired correlation

# here&amp;#39;s the variance/covariance matrix
cov.mat &amp;lt;- 
  matrix(c(sigma[1] ^ 2,
           sigma[1] * sigma[2] * rho,
           sigma[1] * sigma[2] * rho,
           sigma[2] ^ 2),
         nrow = 2, byrow = T)

# after setting our seed, we&amp;#39;re ready to simulate with `rmvnorm()`
set.seed(210191)
x.clean &amp;lt;- 
  rmvnorm(n = 40, sigma = cov.mat) %&amp;gt;% 
  as_tibble() %&amp;gt;% 
  rename(x = V1,
         y = V2)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here we make our second data set, &lt;code&gt;x.noisy&lt;/code&gt;, which is identical to our well-behaved &lt;code&gt;x.clean&lt;/code&gt; data, but with the first three cases transformed to outlier values.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;x.noisy &amp;lt;- x.clean

x.noisy[1:3,] &amp;lt;-
  matrix(c(-40, -60,
           20, 100,
           40, 40),
         nrow = 3, byrow = T)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, we’ll add an &lt;code&gt;outlier&lt;/code&gt; index to the data sets, which will help us with plotting.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;x.clean &amp;lt;-
  x.clean %&amp;gt;% 
  mutate(outlier = factor(0))

x.noisy &amp;lt;- 
  x.noisy %&amp;gt;% 
  mutate(outlier = c(rep(1, 3), rep(0, 37)) %&amp;gt;% as.factor(.))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The plot below shows what the &lt;code&gt;x.clean&lt;/code&gt; data look like. I’m a fan of &lt;a href=&#34;http://fivethirtyeight.com&#34;&gt;FiveThirtyEight&lt;/a&gt;, so we’ll use a few convenience functions from the handy &lt;a href=&#34;https://github.com/jrnold/ggthemes&#34;&gt;ggthemes package&lt;/a&gt; to give our plots a FiveThirtyEight-like feel.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(ggthemes)

x.clean %&amp;gt;% 
  ggplot(aes(x = x, y = y, color = outlier, fill = outlier)) +
  geom_point() +
  stat_ellipse(geom = &amp;quot;polygon&amp;quot;, alpha = .15, size = .15, level = .5) +
  stat_ellipse(geom = &amp;quot;polygon&amp;quot;, alpha = .15, size = .15, level = .95) +
  scale_color_fivethirtyeight() +
  scale_fill_fivethirtyeight() +
  coord_cartesian(xlim = -50:50,
                  ylim = -100:100) +
  theme_fivethirtyeight() +
  theme(legend.position = &amp;quot;none&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-02-09-bayesian-robust-correlations-with-brms-and-why-you-should-love-student-s-t_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;312&#34; /&gt;&lt;/p&gt;
&lt;p&gt;And here are the &lt;code&gt;x.noisy&lt;/code&gt; data.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;x.noisy %&amp;gt;% 
  ggplot(aes(x = x, y = y, color = outlier, fill = outlier)) +
  geom_point() +
  stat_ellipse(geom = &amp;quot;polygon&amp;quot;, alpha = .15, size = .15, level = .5) +
  stat_ellipse(geom = &amp;quot;polygon&amp;quot;, alpha = .15, size = .15, level = .95) +
  scale_color_fivethirtyeight() +
  scale_fill_fivethirtyeight() +
  coord_cartesian(xlim = -50:50,
                  ylim = -100:100) +
  theme_fivethirtyeight() +
  theme(legend.position = &amp;quot;none&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-02-09-bayesian-robust-correlations-with-brms-and-why-you-should-love-student-s-t_files/figure-html/unnamed-chunk-5-1.png&#34; width=&#34;312&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The three outliers are in red. Even in their presence, the old interocular trauma test suggests there is a pronounced overall trend in the data. I would like a correlation procedure that’s capable of capturing that overall trend. Let’s examine some candidates.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;how-does-old-pearson-hold-up&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;How does old Pearson hold up?&lt;/h2&gt;
&lt;p&gt;A quick way to get a Pearson’s correlation coefficient in R is with the &lt;code&gt;cor()&lt;/code&gt; function, which does a nice job recovering the correlation we simulated the &lt;code&gt;x.clean&lt;/code&gt; data with:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cor(x.clean$x, x.clean$y)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] -0.959702&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, things fall apart if you use &lt;code&gt;cor()&lt;/code&gt; on the &lt;code&gt;x.noisy&lt;/code&gt; data.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cor(x.noisy$x, x.noisy$y)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] -0.6365649&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So even though most of the &lt;code&gt;x.noisy&lt;/code&gt; data continue to show a clear strong relation, three outlier values reduced the Pearson’s correlation a third of the way toward zero. Let’s see what happens when we go Bayesian.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;bayesian-correlations-in-brms&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Bayesian correlations in brms&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://twitter.com/paulbuerkner&#34;&gt;Bürkner&lt;/a&gt;’s brms is a general purpose interface for fitting all manner of Bayesian regression models with &lt;a href=&#34;https://mc-stan.org&#34;&gt;Stan&lt;/a&gt; as the engine under the hood. It has popular &lt;a href=&#34;https://cran.r-project.org/web/packages/lme4/index.html&#34;&gt;lme4&lt;/a&gt;-like syntax and offers a variety of convenience functions for post processing. Let’s load it up.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(brms)&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;first-with-the-gaussian-likelihood.&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;First with the Gaussian likelihood.&lt;/h3&gt;
&lt;p&gt;I’m not going to spend a lot of time walking through the syntax in the main brms function, &lt;code&gt;brm()&lt;/code&gt;. You can learn all about that &lt;a href=&#34;https://github.com/paul-buerkner/brms&#34;&gt;here&lt;/a&gt; or with my project &lt;a href=&#34;https://github.com/ASKurz/Statistical_Rethinking_with_brms_ggplot2_and_the_tidyverse#statistical-rethinking-with-brms-ggplot2-and-the-tidyverse&#34;&gt;&lt;em&gt;Statistical Rethinking with brms, ggplot2, and the tidyverse&lt;/em&gt;&lt;/a&gt;. But our particular use of &lt;code&gt;brm()&lt;/code&gt; requires we make a few fine points.&lt;/p&gt;
&lt;p&gt;One doesn’t always think about bivariate correlations within the regression paradigm. But they work just fine. Within brms, you would typically specify the conventional Gaussian likelihood (i.e., &lt;code&gt;family = gaussian&lt;/code&gt;), use the &lt;code&gt;mvbind()&lt;/code&gt; syntax to set up a &lt;a href=&#34;https://cran.r-project.org/web/packages/brms/vignettes/brms_multivariate.html&#34;&gt;multivariate model&lt;/a&gt;, and fit that model without predictors. For each variable specified in &lt;code&gt;cbind()&lt;/code&gt;, you’ll estimate an intercept (i.e., mean, &lt;span class=&#34;math inline&#34;&gt;\(\mu\)&lt;/span&gt;) and sigma (i.e., &lt;span class=&#34;math inline&#34;&gt;\(\sigma\)&lt;/span&gt;, often called a residual variance). Since there are no predictors in the model, the residual variance is just the variance and the brms default for multivariate models is to allow the residual variances to covary. But since variances are parameterized in the standard deviation metric in brms, the residual variances and their covariance are &lt;em&gt;SD&lt;/em&gt;s and their correlation, respectively.&lt;/p&gt;
&lt;p&gt;Here’s what it looks like in practice.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;f0 &amp;lt;- 
  brm(data = x.clean, 
      family = gaussian,
      mvbind(x, y) ~ 1,
      prior = c(prior(normal(0, 100), class = Intercept),
                prior(normal(0, 100), class = sigma, resp = x),
                prior(normal(0, 100), class = sigma, resp = y),
                prior(lkj(1), class = rescor)),
      iter = 2000, warmup = 500, chains = 4, cores = 4, 
      seed = 210191)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In a typical Bayesian workflow, you’d examine the quality of the chains with trace plots. The easy way to do that in brms is with &lt;code&gt;plot()&lt;/code&gt;. E.g., to get the trace plots for our first model, you’d code &lt;code&gt;plot(f0)&lt;/code&gt;. Happily, the trace plots look fine for all models in this post. For the sake of space, I’ll leave their inspection as exercises for interested readers.&lt;/p&gt;
&lt;p&gt;Our priors and such mirror those in Baez-Ortega’s blog. Here are the results.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;print(f0)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  Family: MV(gaussian, gaussian) 
##   Links: mu = identity; sigma = identity
##          mu = identity; sigma = identity 
## Formula: x ~ 1 
##          y ~ 1 
##    Data: x.clean (Number of observations: 40) 
## Samples: 4 chains, each with iter = 2000; warmup = 500; thin = 1;
##          total post-warmup samples = 6000
## 
## Population-Level Effects: 
##             Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
## x_Intercept    -2.83      3.33    -9.33     3.69 1.00     3000     3111
## y_Intercept     3.55      6.65    -9.45    16.60 1.00     2978     2928
## 
## Family Specific Parameters: 
##         Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
## sigma_x    21.47      2.47    17.29    26.99 1.00     2514     3094
## sigma_y    42.93      4.86    34.55    53.51 1.00     2477     3144
## 
## Residual Correlations: 
##             Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
## rescor(x,y)    -0.95      0.02    -0.98    -0.92 1.00     2686     3218
## 
## Samples were drawn using sampling(NUTS). For each parameter, Eff.Sample 
## is a crude measure of effective sample size, and Rhat is the potential 
## scale reduction factor on split chains (at convergence, Rhat = 1).&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Way down there in the last line in the ‘Family Specific Parameters’ section we have &lt;code&gt;rescor(x,y)&lt;/code&gt;, which is our correlation. And indeed, our Gaussian intercept-only multivariate model did a great job recovering the correlation we used to simulate the &lt;code&gt;x.clean&lt;/code&gt; data with. Look at what happens when we try this approach with &lt;code&gt;x.noisy&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;f1 &amp;lt;-
  update(f0,
         newdata = x.noisy,
         iter = 2000, warmup = 500, chains = 4, cores = 4, seed = 210191)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;print(f1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  Family: MV(gaussian, gaussian) 
##   Links: mu = identity; sigma = identity
##          mu = identity; sigma = identity 
## Formula: x ~ 1 
##          y ~ 1 
##    Data: x.noisy (Number of observations: 40) 
## Samples: 4 chains, each with iter = 2000; warmup = 500; thin = 1;
##          total post-warmup samples = 6000
## 
## Population-Level Effects: 
##             Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
## x_Intercept    -2.95      3.75   -10.39     4.57 1.00     4515     3963
## y_Intercept     6.52      7.45    -8.31    20.98 1.00     4727     4057
## 
## Family Specific Parameters: 
##         Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
## sigma_x    23.65      2.76    18.97    29.83 1.00     4536     4351
## sigma_y    47.20      5.42    37.94    59.03 1.00     4619     4222
## 
## Residual Correlations: 
##             Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
## rescor(x,y)    -0.61      0.10    -0.78    -0.39 1.00     4344     4033
## 
## Samples were drawn using sampling(NUTS). For each parameter, Eff.Sample 
## is a crude measure of effective sample size, and Rhat is the potential 
## scale reduction factor on split chains (at convergence, Rhat = 1).&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the correlation estimate is -.61. As it turns out, &lt;code&gt;data = x.noisy&lt;/code&gt; + &lt;code&gt;family = gaussian&lt;/code&gt; in &lt;code&gt;brm()&lt;/code&gt; failed us just like Pearson’s correlation failed us. Time to leave failure behind.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;now-with-students-t-distribution.&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Now with Student’s &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;-distribution.&lt;/h3&gt;
&lt;p&gt;Before we jump into using &lt;code&gt;family = student&lt;/code&gt;, we should talk a bit about &lt;span class=&#34;math inline&#34;&gt;\(\nu\)&lt;/span&gt;. This is our new parameter which is silently fixed to infinity when we use the Gaussian likelihood. The &lt;span class=&#34;math inline&#34;&gt;\(\nu\)&lt;/span&gt; parameter is bound at zero but, as discussed in Baez-Ortega’s blog, is somewhat nonsensical for values below 1. As it turns out, &lt;span class=&#34;math inline&#34;&gt;\(\nu\)&lt;/span&gt; is constrained to be equal to or greater than 1 in brms. So nothing for us to worry about, there. The &lt;a href=&#34;https://github.com/stan-dev/stan/wiki/Prior-Choice-Recommendations&#34;&gt;Stan team currently recommends the gamma(2, 0.1) prior for &lt;span class=&#34;math inline&#34;&gt;\(\nu\)&lt;/span&gt;&lt;/a&gt;, which is also the current brms default. This is what that distribution looks like.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tibble(x = seq(from = 1, to = 120, by = .5)) %&amp;gt;% 
  ggplot(aes(x = x, fill = factor(0))) +
  geom_ribbon(aes(ymin = 0, 
                  ymax = dgamma(x, 2, 0.1))) +
  scale_y_continuous(NULL, breaks = NULL) +
  scale_fill_fivethirtyeight() +
  coord_cartesian(xlim = 0:100) +
  ggtitle(&amp;quot;gamma(2, 0.1)&amp;quot;) +
  theme_fivethirtyeight() +
  theme(legend.position = &amp;quot;none&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-02-09-bayesian-robust-correlations-with-brms-and-why-you-should-love-student-s-t_files/figure-html/unnamed-chunk-11-1.png&#34; width=&#34;960&#34; /&gt;&lt;/p&gt;
&lt;p&gt;So gamma(2, 0.1) should gently push the &lt;span class=&#34;math inline&#34;&gt;\(\nu\)&lt;/span&gt; posterior toward low values, but it’s slowly-sloping right tail will allow higher values to emerge.&lt;/p&gt;
&lt;p&gt;Following the Stan team’s recommendation, the brms default and Baez-Ortega’s blog, here’s our robust Student’s &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; model for the &lt;code&gt;x.noisy&lt;/code&gt; data.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;f2 &amp;lt;- 
  brm(data = x.noisy, 
      family = student,
      mvbind(x, y) ~ 1,
      prior = c(prior(gamma(2, .1), class = nu),
                prior(normal(0, 100), class = Intercept),
                prior(normal(0, 100), class = sigma, resp = x),
                prior(normal(0, 100), class = sigma, resp = y),
                prior(lkj(1), class = rescor)),
      iter = 2000, warmup = 500, chains = 4, cores = 4, 
      seed = 210191)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;print(f2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  Family: MV(student, student) 
##   Links: mu = identity; sigma = identity; nu = identity
##          mu = identity; sigma = identity; nu = identity 
## Formula: x ~ 1 
##          y ~ 1 
##    Data: x.noisy (Number of observations: 40) 
## Samples: 4 chains, each with iter = 2000; warmup = 500; thin = 1;
##          total post-warmup samples = 6000
## 
## Population-Level Effects: 
##             Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
## x_Intercept    -2.11      3.61    -9.22     4.96 1.00     2964     3421
## y_Intercept     1.93      7.12   -11.74    16.03 1.00     2973     3497
## 
## Family Specific Parameters: 
##         Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
## sigma_x    18.26      2.92    13.06    24.48 1.00     3231     3281
## sigma_y    36.31      5.79    26.08    48.60 1.00     3214     3625
## nu          2.65      1.00     1.36     5.13 1.00     3967     2851
## 
## Residual Correlations: 
##             Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
## rescor(x,y)    -0.93      0.03    -0.97    -0.84 1.00     3896     3625
## 
## Samples were drawn using sampling(NUTS). For each parameter, Eff.Sample 
## is a crude measure of effective sample size, and Rhat is the potential 
## scale reduction factor on split chains (at convergence, Rhat = 1).&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Whoa, look at that correlation, &lt;code&gt;rescore(x,y)&lt;/code&gt;! It’s right about what we’d hope for. Sure, it’s not a perfect -.95, but that’s way better than -.61.&lt;/p&gt;
&lt;p&gt;While we’re at it, we may as well see what happens when we fit a Student’s &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; model when we have perfectly multivariate normal data. Here it is with the &lt;code&gt;x.clean&lt;/code&gt; data.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;f3 &amp;lt;- 
  update(f2,
         newdata = x.clean, 
         iter = 2000, warmup = 500, chains = 4, cores = 4, seed = 210191)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;print(f3)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  Family: MV(student, student) 
##   Links: mu = identity; sigma = identity; nu = identity
##          mu = identity; sigma = identity; nu = identity 
## Formula: x ~ 1 
##          y ~ 1 
##    Data: x.clean (Number of observations: 40) 
## Samples: 4 chains, each with iter = 2000; warmup = 500; thin = 1;
##          total post-warmup samples = 6000
## 
## Population-Level Effects: 
##             Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
## x_Intercept    -2.37      3.50    -9.20     4.39 1.00     2931     3188
## y_Intercept     2.71      6.98   -10.90    16.48 1.00     3067     3363
## 
## Family Specific Parameters: 
##         Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
## sigma_x    20.79      2.60    16.28    26.60 1.00     2427     2778
## sigma_y    41.34      5.17    32.33    52.62 1.00     2459     2863
## nu         22.42     13.78     5.70    57.53 1.00     4146     3881
## 
## Residual Correlations: 
##             Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
## rescor(x,y)    -0.96      0.01    -0.98    -0.92 1.00     3084     3577
## 
## Samples were drawn using sampling(NUTS). For each parameter, Eff.Sample 
## is a crude measure of effective sample size, and Rhat is the potential 
## scale reduction factor on split chains (at convergence, Rhat = 1).&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So when you don’t need Student’s &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;, it yields the right answer anyways. That’s a nice feature.&lt;/p&gt;
&lt;p&gt;We should probably compare the posteriors of the correlations across the four models. First we’ll collect the posterior samples into a tibble.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;posts &amp;lt;-
  tibble(model = str_c(&amp;quot;f&amp;quot;, 0:3)) %&amp;gt;% 
  mutate(fit  = map(model, get)) %&amp;gt;% 
  mutate(post = map(fit, posterior_samples)) %&amp;gt;% 
  unnest(post)

head(posts)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 9
##   model fit   b_x_Intercept b_y_Intercept sigma_x sigma_y rescor__x__y
##   &amp;lt;chr&amp;gt; &amp;lt;lis&amp;gt;         &amp;lt;dbl&amp;gt;         &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt;        &amp;lt;dbl&amp;gt;
## 1 f0    &amp;lt;brm…          1.31        -5.60     18.2    37.8       -0.947
## 2 f0    &amp;lt;brm…         -7.41        10.6      25.2    50.5       -0.941
## 3 f0    &amp;lt;brm…         -4.51         5.65     23.3    49.4       -0.975
## 4 f0    &amp;lt;brm…         -2.65        -0.597    18.3    37.3       -0.929
## 5 f0    &amp;lt;brm…         -2.76        -1.50     18.4    37.5       -0.923
## 6 f0    &amp;lt;brm…         -9.84        15.2      26.3    45.1       -0.953
## # … with 2 more variables: lp__ &amp;lt;dbl&amp;gt;, nu &amp;lt;dbl&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With the posterior draws in hand, we just need to wrangle a bit before showing the correlation posteriors in a coefficient plot. To make things easier, we’ll do so with a couple convenience functions from the &lt;a href=&#34;https://github.com/mjskay/tidybayes&#34;&gt;tidybayes&lt;/a&gt; package.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidybayes)

# wrangle
posts %&amp;gt;% 
  group_by(model) %&amp;gt;% 
  median_qi(rescor__x__y, .width = c(.5, .95)) %&amp;gt;% 
  mutate(key = recode(model, 
                      f0 = &amp;quot;Gaussian likelihood with clean data&amp;quot;,
                      f1 = &amp;quot;Gaussian likelihood with noisy data&amp;quot;,
                      f2 = &amp;quot;Student likelihood with noisy data&amp;quot;,
                      f3 = &amp;quot;Student likelihood with clean data&amp;quot;),
         clean = ifelse(model %in% c(&amp;quot;f0&amp;quot;, &amp;quot;f3&amp;quot;), &amp;quot;0&amp;quot;, &amp;quot;1&amp;quot;)) %&amp;gt;%
  
  # plot
  ggplot(aes(x = rescor__x__y, y = key, color = clean)) +
  geom_pointintervalh() +
  scale_color_fivethirtyeight() +
  coord_cartesian(xlim = -1:0) +
  labs(subtitle = expression(paste(&amp;quot;The posterior for &amp;quot;, rho, &amp;quot; depends on the likelihood. Why not go robust and use Student&amp;#39;s &amp;quot;, italic(t), &amp;quot;?&amp;quot;))) +
  theme_fivethirtyeight() +
  theme(axis.text.y     = element_text(hjust = 0),
        legend.position = &amp;quot;none&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-02-09-bayesian-robust-correlations-with-brms-and-why-you-should-love-student-s-t_files/figure-html/unnamed-chunk-15-1.png&#34; width=&#34;960&#34; /&gt;&lt;/p&gt;
&lt;p&gt;From our &lt;code&gt;tidybayes::median_qi()&lt;/code&gt; code, the dots are the posterior medians, the thick inner lines the 50% intervals, and the thinner outer lines the 95% intervals. The posteriors for the &lt;code&gt;x.noisy&lt;/code&gt; data are in red and those for the &lt;code&gt;x.clean&lt;/code&gt; data are in blue. If the data are clean multivariate normal Gaussian or if they’re dirty but fit with robust Student’s &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;, everything is pretty much alright. But whoa, if you fit a correlation with a combination of &lt;code&gt;family = gaussian&lt;/code&gt; and noisy outlier-laden data, man that’s just a mess.&lt;/p&gt;
&lt;p&gt;Don’t let a few overly-influential outliers make a mess of your analyses. Try the robust Student’s &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sessionInfo()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## R version 3.6.0 (2019-04-26)
## Platform: x86_64-apple-darwin15.6.0 (64-bit)
## Running under: macOS High Sierra 10.13.6
## 
## Matrix products: default
## BLAS:   /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRblas.0.dylib
## LAPACK: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRlapack.dylib
## 
## Random number generation:
##  RNG:     Mersenne-Twister 
##  Normal:  Inversion 
##  Sample:  Rounding 
##  
## locale:
## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
##  [1] tidybayes_1.1.0 brms_2.10.0     Rcpp_1.0.2      ggthemes_4.2.0 
##  [5] forcats_0.4.0   stringr_1.4.0   dplyr_0.8.3     purrr_0.3.2    
##  [9] readr_1.3.1     tidyr_1.0.0     tibble_2.1.3    ggplot2_3.2.1  
## [13] tidyverse_1.2.1 mvtnorm_1.0-11 
## 
## loaded via a namespace (and not attached):
##   [1] readxl_1.3.1              backports_1.1.4          
##   [3] Hmisc_4.2-0               plyr_1.8.4               
##   [5] igraph_1.2.4.1            lazyeval_0.2.2           
##   [7] svUnit_0.7-12             splines_3.6.0            
##   [9] crosstalk_1.0.0           rstantools_1.5.1         
##  [11] inline_0.3.15             digest_0.6.20            
##  [13] htmltools_0.3.6           rsconnect_0.8.13         
##  [15] gdata_2.18.0              fansi_0.4.0              
##  [17] magrittr_1.5              checkmate_1.9.3          
##  [19] cluster_2.0.8             modelr_0.1.4             
##  [21] matrixStats_0.54.0        xts_0.11-2               
##  [23] prettyunits_1.0.2         colorspace_1.4-1         
##  [25] rvest_0.3.4               haven_2.1.0              
##  [27] pan_1.6                   xfun_0.8                 
##  [29] callr_3.2.0               crayon_1.3.4             
##  [31] jsonlite_1.6              lme4_1.1-21              
##  [33] zeallot_0.1.0             survival_2.44-1.1        
##  [35] zoo_1.8-6                 glue_1.3.1               
##  [37] gtable_0.3.0              pkgbuild_1.0.3           
##  [39] weights_1.0               rstan_2.19.2             
##  [41] jomo_2.6-8                abind_1.4-5              
##  [43] scales_1.0.0              miniUI_0.1.1.1           
##  [45] xtable_1.8-4              htmlTable_1.13.1         
##  [47] ggstance_0.3.2            foreign_0.8-71           
##  [49] Formula_1.2-3             stats4_3.6.0             
##  [51] StanHeaders_2.18.1-10     DT_0.7                   
##  [53] htmlwidgets_1.3           httr_1.4.0               
##  [55] threejs_0.3.1             arrayhelpers_1.0-20160527
##  [57] RColorBrewer_1.1-2        acepack_1.4.1            
##  [59] mice_3.5.0                pkgconfig_2.0.2          
##  [61] loo_2.1.0                 nnet_7.3-12              
##  [63] utf8_1.1.4                tidyselect_0.2.5         
##  [65] labeling_0.3              rlang_0.4.0              
##  [67] reshape2_1.4.3            later_0.8.0              
##  [69] munsell_0.5.0             cellranger_1.1.0         
##  [71] tools_3.6.0               cli_1.1.0                
##  [73] generics_0.0.2            broom_0.5.2              
##  [75] ggridges_0.5.1            evaluate_0.14            
##  [77] yaml_2.2.0                processx_3.3.1           
##  [79] knitr_1.23                mitml_0.3-7              
##  [81] nlme_3.1-139              mime_0.7                 
##  [83] xml2_1.2.0                compiler_3.6.0           
##  [85] bayesplot_1.7.0           shinythemes_1.1.2        
##  [87] rstudioapi_0.10           stringi_1.4.3            
##  [89] ps_1.3.0                  blogdown_0.14            
##  [91] Brobdingnag_1.2-6         lattice_0.20-38          
##  [93] Matrix_1.2-17             nloptr_1.2.1             
##  [95] markdown_1.0              shinyjs_1.0              
##  [97] vctrs_0.2.0               pillar_1.4.2             
##  [99] lifecycle_0.1.0           bridgesampling_0.6-0     
## [101] data.table_1.12.2         httpuv_1.5.1             
## [103] R6_2.4.0                  latticeExtra_0.6-28      
## [105] bookdown_0.12             promises_1.0.1           
## [107] gridExtra_2.3             boot_1.3-22              
## [109] colourpicker_1.0          MASS_7.3-51.4            
## [111] gtools_3.8.1              assertthat_0.2.1         
## [113] withr_2.1.2               shinystan_2.5.0          
## [115] parallel_3.6.0            hms_0.4.2                
## [117] grid_3.6.0                rpart_4.1-15             
## [119] coda_0.19-2               minqa_1.2.4              
## [121] rmarkdown_1.13            shiny_1.3.2              
## [123] lubridate_1.7.4           base64enc_0.1-3          
## [125] dygraphs_1.1.1.6&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>&#34;How to Survive a Plague&#34;: Part 1/$n$ of a premature book report</title>
      <link>/post/how-to-survive-a-plague-part-1-n-of-a-premature-book-report/</link>
      <pubDate>Sat, 02 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/how-to-survive-a-plague-part-1-n-of-a-premature-book-report/</guid>
      <description>&lt;p&gt;I’ve been reading &lt;a href=&#34;https://twitter.com/bydavidfrance?lang=en&#34;&gt;David France&lt;/a&gt;’s &lt;a href=&#34;https://surviveaplague.com&#34;&gt;&lt;em&gt;How to Survive a Plague: The Inside Story of How Citizens and Science Tamed AIDS&lt;/em&gt;&lt;/a&gt;. It’s a masterwork. And it’s devastating. Two months in and I haven’t cracked 100 pages. &lt;em&gt;HSP&lt;/em&gt; is the kind of book I can only take 10—20 pages at a time. But like anything soulful and hard and true, it’s worth it.&lt;/p&gt;
&lt;p&gt;For example, what do you know about the first baby on record to have died of AIDS?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In San Francisco [November 1982], Dr. Arthur Ammann was feeling frustrated as he studied the results of a bone marrow test he had ordered on a very sick toddler. As an expert in pediatric immunology who traveled regularly throughout Africa, Ammann thought he’d either seen or read about every immune disorder that cold plague a child… But this little boy baffled him. He was born prematurely on March 3, 1981, with pronounced &lt;a href=&#34;https://www.mayoclinic.org/diseases-conditions/infant-jaundice/symptoms-causes/syc-20373865&#34;&gt;jaundice&lt;/a&gt;, a problem caused by toxins accumulating in the blood. This was not extraordinary, and the standard course of treatment was followed: every ounce of his contaminated blood was replaced with donated supplies. The process was repeated five times over a four-day period, followed by additional infusions of blood products like packed red blood cells and platelets. (p. 71)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Just that alone—fuck.&lt;/p&gt;
&lt;p&gt;After the initial bout of treatment, it looked like he was getting better. Dr. Ammann sent him home with his parents.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;But at four months of age his health began to dive. He suffered an &lt;a href=&#34;https://emedicine.medscape.com/article/958739-overvie&#34;&gt;enlarged spleen&lt;/a&gt; and &lt;a href=&#34;https://www.stlouischildrens.org/conditions-treatments/liver-disease&#34;&gt;liver&lt;/a&gt;. Jaundice returned, followed by &lt;a href=&#34;https://www.stanfordchildrens.org/en/topic/default?id=hepatitis-in-children-90-P02517&#34;&gt;hepatitis&lt;/a&gt; of no known origin, then &lt;a href=&#34;https://www.aafp.org/afp/2016/0215/p270.html&#34;&gt;anemia&lt;/a&gt; and diarrhea. Now the little boy was twenty months old and in intensive care. (p. 71)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;By mid-1982, gay men, Haitians, and intravenous drug users were known to be at risk for AIDS. But it wasn’t yet clear why.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Ammann suspected an infection in the child’s bone marrow, which would be highly unusual. Test results were even more surprising than he’d imagined. The child’s culture was positive for &lt;a href=&#34;https://rarediseases.info.nih.gov/diseases/7123/mycobacterium-avium-complex-infections&#34;&gt;&lt;em&gt;Mycobacterium avium-intracellulare&lt;/em&gt;&lt;/a&gt;, the dreaded cause of &lt;a href=&#34;http://www.aidsinfonet.org/fact_sheets/view/519pml.htm&#34;&gt;wasting syndrome&lt;/a&gt; in adults with AIDS. Recently there had been a number of reports of babies who seemed to inherit the disease at birth from their sick mothers, but that was not the case here. Ammann wrote in his case notes that both parents of his patient were “heterosexual non-Haitians and do not have a history of intravenous drug abuse.” He submitted both [parents] to extensive testing, and found no signs of immune deficiency.&lt;/p&gt;
&lt;p&gt;All he could think was: The blood supply is contaminated. (p. 71, &lt;em&gt;emphasis&lt;/em&gt; in the original)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;As is turned out, gay men were particularly generous blood donors at that time.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Gay men, he learned, were extremely avid blood donors. In fact, in recent months an unnoticed and massive blood drive had been under way in LA’s gay neighborhoods in response to the mounting GRID [i.e., gay-related immune deficiency, as AIDS was known by in the early days] crisis, there. Week after week long lines of men rolled up their sleeves to donate blood, dutifully offering up pint after pint of harm they never dreamed of. (p. 59)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This was the precursor to a 30-year ban on gay men donating blood—which was &lt;a href=&#34;https://www.cnn.com/2015/12/21/health/fda-gay-men-blood-donation-changes/index.html&#34;&gt;overturned in 2015 based on advances in the relevant scientific literature&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;“Pulling the boy’s hospital records, he saw that blood donations from twenty-one separate people had been transfused into the child. Their identities were masked” (p. 71). After some efforts, Ammann and his team determined the relevant donor.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A man in his late forties… He had donated blood in early 1981. His health had remained unremarkable until that October, when he complained of fatigue, swollen lymph glands, and clouded vision in one eye—classic AIDS symptoms. Doctors diagnosed PCP [i.e., &lt;a href=&#34;https://www.webmd.com/hiv-aids/guide/aids-hiv-opportunistic-infections-pneumocystis-pcp-pneumonia#1&#34;&gt;&lt;em&gt;pneumocystis carinii&lt;/em&gt;&lt;/a&gt; pneumonia, an inflammation and fluid buildup in the lungs most of us conquer in early childhood] in December, and he was dead nine months later.&lt;/p&gt;
&lt;p&gt;This was the first irrefutable evidence of transmission through the blood supply. (p. 72)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Shortly after, Ammann and notified the medical community via the CDC’s widely-read &lt;a href=&#34;https://www.cdc.gov/mmwr/index.html&#34;&gt;&lt;em&gt;Morbidity and Mortality Weekly Report&lt;/em&gt;&lt;/a&gt; platform. His publication choice was crucial. Had he tried to get published at a more prestigious outlet, such as the &lt;em&gt;New England Journal of Medicine&lt;/em&gt;, the peer-review process could have held up the message for months or more. Ammann needed to get the message out to practitioners as soon as possible. The publication lag for the &lt;em&gt;MMWR&lt;/em&gt; was trivial. &lt;a href=&#34;https://www.cdc.gov/mmwr/preview/mmwrhtml/00001203.htm&#34;&gt;Here’s the report&lt;/a&gt;. In an editorial note at the end of the report, we read&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Of the 788 definite AIDS cases among adults reported thus far to CDC, 42 (5.3%) belong to no known risk group (i.e., they are not known to be homosexually active men, intravenous drug abusers, Haitians, or hemophiliacs). Two cases received blood products within 2 years of the onset of their illnesses and are currently under investigation.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Seven hundred and seventy-eight.&lt;/p&gt;
&lt;p&gt;According to the World Health Organization, about &lt;a href=&#34;https://www.who.int/gho/hiv/en/&#34;&gt;37 million people were living with AIDS in 2017&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Shortly after Ammann’s piece was published,&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;a scrum of journalists burst through the CDC’s door for the first time, including correspondents from countless television networks and affiliates. The attention was long overdue. But with images of bouncing toddlers, the reporters warned America that the gay disease was now killing children. It unleashed a &lt;a href=&#34;https://www.nytimes.com/1986/11/23/us/violence-against-homosexuals-rising-groups-seeking-wider-protection-say.html&#34;&gt;torrent of anti-gay violence&lt;/a&gt; the likes of which the community had never seen before. (p. 73)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;If you find this topic sad and compelling and worth the heartbreak, there’s more to come.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Robust Linear Regression with Student’s $t$-Distribution</title>
      <link>/post/robust-linear-regression-with-the-robust-student-s-t-distribution/</link>
      <pubDate>Sat, 02 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/robust-linear-regression-with-the-robust-student-s-t-distribution/</guid>
      <description>&lt;p&gt;[edited Feb 3, 2019]&lt;/p&gt;
&lt;p&gt;The purpose of this post is to demonstrate the advantages of the Student’s &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;-distribution for regression with outliers, particularly within a &lt;a href=&#34;https://www.youtube.com/channel/UCNJK6_DZvcMqNSzQdEkzvzA/playlists&#34;&gt;Bayesian framework&lt;/a&gt;.&lt;/p&gt;
&lt;div id=&#34;i-make-assumptions&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;I make assumptions&lt;/h2&gt;
&lt;p&gt;I’m presuming you are familiar with linear regression, familiar with the basic differences between frequentist and Bayesian approaches to fitting regression models, and have a sense that the issue of outlier values is a pickle worth contending with. All code in is &lt;a href=&#34;https://www.r-bloggers.com/why-use-r-five-reasons/&#34;&gt;R&lt;/a&gt;, with a heavy use of the &lt;a href=&#34;http://style.tidyverse.org&#34;&gt;tidyverse&lt;/a&gt;–which you might learn a lot about &lt;a href=&#34;http://r4ds.had.co.nzhttp://r4ds.had.co.nz&#34;&gt;here, especially chapter 5&lt;/a&gt;– and &lt;a href=&#34;https://twitter.com/paulbuerkner&#34;&gt;Paul Bürkner&lt;/a&gt;’s &lt;a href=&#34;https://github.com/paul-buerkner/brms&#34;&gt;brms&lt;/a&gt; package.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;the-problem&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;The problem&lt;/h2&gt;
&lt;p&gt;Simple regression models typically use the Gaussian likelihood. Say you have some criterion variable &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt;, which you can reasonably describe with a mean &lt;span class=&#34;math inline&#34;&gt;\(\mu\)&lt;/span&gt; and standard deviation &lt;span class=&#34;math inline&#34;&gt;\(\sigma\)&lt;/span&gt;. Further, you’d like to describe &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt; with a predictor &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;. Using the Gaussian likelihood, we can describe the model as&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{eqnarray}
y_i &amp;amp; \sim &amp;amp; \text{Normal}(\mu_i, \sigma) \\
\mu_i &amp;amp; = &amp;amp; \beta_0 + \beta_1 x_i
\end{eqnarray}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;With this formulation, we use &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; to model the mean of &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt;. The &lt;span class=&#34;math inline&#34;&gt;\(\beta_0\)&lt;/span&gt; parameter is the intercept of the regression model and &lt;span class=&#34;math inline&#34;&gt;\(\beta_1\)&lt;/span&gt; is its slope with respect to &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;. After accounting for &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt;’s relation with &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;, the leftover variability in &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt; is described by &lt;span class=&#34;math inline&#34;&gt;\(\sigma\)&lt;/span&gt;, often called error or residual variance. The reason we describe the model in terms of &lt;span class=&#34;math inline&#34;&gt;\(\mu\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(\sigma\)&lt;/span&gt; is because those are the two parameters by which we define the Normal distribution, the Gaussian likelihood.&lt;/p&gt;
&lt;p&gt;The Gaussian is a sensible default choice for many data types. You might say it works unreasonably well. Unfortunately, the normal (i.e., Gaussian) distribution is sensitive to outliers.&lt;/p&gt;
&lt;p&gt;The normal distribution is a special case of Student’s &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;-distribution with the &lt;span class=&#34;math inline&#34;&gt;\(\nu\)&lt;/span&gt; parameter (i.e., the degree of freedom) set to infinity. However, when &lt;span class=&#34;math inline&#34;&gt;\(\nu\)&lt;/span&gt; is small, Student’s &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;-distribution is more robust to multivariate outliers. See &lt;a href=&#34;http://www.stat.columbia.edu/~gelman/arm/&#34;&gt;Gelman &amp;amp; Hill (2007, chapter 6)&lt;/a&gt; or &lt;a href=&#34;https://sites.google.com/site/doingbayesiandataanalysis/&#34;&gt;Kruschke (2014, chapter 16)&lt;/a&gt; for textbook treatments on the topic.&lt;/p&gt;
&lt;p&gt;In this post, we demonstrate how vulnerable the Gaussian likelihood is to outliers and then compare it to different ways of using Student’s &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;-likelihood for the same data.&lt;/p&gt;
&lt;p&gt;First, we’ll get a sense of the distributions with a plot.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidyverse)

tibble(x = seq(from = -6, to = 6, by = .01)) %&amp;gt;% 
  expand(x, nu = c(1, 2.5, 5, 10, Inf)) %&amp;gt;% 
  mutate(density = dt(x = x, df = nu),
         nu      = factor(nu, levels = c(&amp;quot;Inf&amp;quot;, &amp;quot;10&amp;quot;, &amp;quot;5&amp;quot;, &amp;quot;2.5&amp;quot;, &amp;quot;1&amp;quot;))) %&amp;gt;% 
  
  ggplot(aes(x = x, y = density, group = nu, color = nu)) +
  geom_line() +
  scale_color_viridis_d(expression(nu),
                        direction = 1, option = &amp;quot;C&amp;quot;, end = .85) +
  scale_y_continuous(NULL, breaks = NULL) +
  coord_cartesian(xlim = -5:5) +
  xlab(NULL) +
  theme(panel.grid = element_blank())&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-02-02-robust-linear-regression-with-the-robust-student-s-t-distribution_files/figure-html/unnamed-chunk-1-1.png&#34; width=&#34;528&#34; /&gt;&lt;/p&gt;
&lt;p&gt;So the difference is that a Student’s &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;-distribution with a low &lt;span class=&#34;math inline&#34;&gt;\(\nu\)&lt;/span&gt; will have notably heavier tails than the conventional Gaussian distribution. It’s easiest to see the difference when &lt;span class=&#34;math inline&#34;&gt;\(\nu\)&lt;/span&gt; approaches 1. Even then, the difference can be subtle when looking at a plot. Another way is to compare how probable relatively extreme values are in a Student’s &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;-distribution relative to the Gaussian. For the sake of demonstration, here we’ll compare Gauss with Student’s &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; with a &lt;span class=&#34;math inline&#34;&gt;\(\nu\)&lt;/span&gt; of 5. In the plot above, they are clearly different, but not shockingly so. However, that difference is very notable in the tails.&lt;/p&gt;
&lt;p&gt;Let’s look more closely with a table. Below, we compare the probability of a given z-score or lower within the Gaussian and a &lt;span class=&#34;math inline&#34;&gt;\(\nu = 5\)&lt;/span&gt; Student’s &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;. In the rightmost column, we compare the probabilities in a ratio.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Here we pic our nu
nu &amp;lt;- 5

tibble(z_score               = 0:-5,
       p_Gauss               = pnorm(z_score, mean = 0, sd = 1),
       p_Student_t           = pt(z_score, df = nu),
       `Student/Gauss ratio` = p_Student_t/p_Gauss) %&amp;gt;%
  mutate_if(is.double, round, digits = 5) %&amp;gt;% 
  knitr::kable()&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;right&#34;&gt;z_score&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;p_Gauss&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;p_Student_t&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Student/Gauss ratio&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.50000&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.50000&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.00000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;right&#34;&gt;-1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.15866&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.18161&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.14468&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;right&#34;&gt;-2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.02275&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.05097&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2.24042&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;right&#34;&gt;-3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.00135&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.01505&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;11.14871&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;right&#34;&gt;-4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.00003&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.00516&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;162.97775&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;right&#34;&gt;-5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.00000&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.00205&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7159.76534&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Note how low z-scores are more probable in this Student’s &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; than in the Gaussian. This is most apparent in the &lt;code&gt;Student/Gauss ratio&lt;/code&gt; column on the right. A consequence of this is that extreme scores are less influential to your solutions when you use a small-&lt;span class=&#34;math inline&#34;&gt;\(\nu\)&lt;/span&gt; Student’s &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;-distribution in place of the Gaussian. That is, the small-&lt;span class=&#34;math inline&#34;&gt;\(\nu\)&lt;/span&gt; Student’s &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; is more robust than the Gaussian to unusual and otherwise influential observations.&lt;/p&gt;
&lt;p&gt;In order to demonstrate, let’s simulate our own. We’ll start by creating multivariate normal data.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;lets-create-our-initial-tibble-of-well-behaved-data-d&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Let’s create our initial &lt;a href=&#34;https://cran.r-project.org/web/packages/tibble/vignettes/tibble.html&#34;&gt;tibble&lt;/a&gt; of well-behaved data, &lt;code&gt;d&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;First, we’ll need to define our variance/covariance matrix.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;s &amp;lt;- matrix(c(1, .6, 
              .6, 1), 
             nrow = 2, ncol = 2)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By the two &lt;code&gt;.6&lt;/code&gt;s on the off-diagonal positions, we indicated we’d like our two variables to have a correlation of .6.&lt;/p&gt;
&lt;p&gt;Second, our variables also need means, which we’ll define with a mean vector.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;m &amp;lt;- c(0, 0)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With means of &lt;code&gt;0&lt;/code&gt; and variances of &lt;code&gt;1&lt;/code&gt;, our data are in a standardized metric.&lt;/p&gt;
&lt;p&gt;Third, we’ll use the &lt;code&gt;mvrnorm()&lt;/code&gt; function from the &lt;a href=&#34;https://cran.r-project.org/web/packages/MASS/index.html&#34;&gt;MASS package&lt;/a&gt; to simulate our data.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(3)

d &amp;lt;- MASS::mvrnorm(n = 100, mu = m, Sigma = s) %&amp;gt;%
  as_tibble() %&amp;gt;%
  rename(y = V1, x = V2)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first few rows look like so:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;head(d)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 2
##         y      x
##     &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
## 1 -1.14   -0.584
## 2 -0.0805 -0.443
## 3 -0.239   0.702
## 4 -1.30   -0.761
## 5 -0.280   0.630
## 6 -0.245   0.299&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As an aside, check out &lt;a href=&#34;https://www.r-bloggers.com/creating-sample-datasets-exercises/&#34;&gt;this nice r-bloggers post&lt;/a&gt; for more information on simulating data with this method.&lt;/p&gt;
&lt;p&gt;Anyway, this line reorders our data by &lt;code&gt;x&lt;/code&gt;, placing the smallest values on top.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;d &amp;lt;-
  d %&amp;gt;%
  arrange(x)

head(d)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 2
##        y     x
##    &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
## 1 -2.21  -1.84
## 2 -1.27  -1.71
## 3 -0.168 -1.60
## 4 -0.292 -1.46
## 5 -0.785 -1.40
## 6 -0.157 -1.37&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;lets-create-our-outlier-tibble-o&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Let’s create our outlier tibble, &lt;code&gt;o&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Here we’ll make two outlying and unduly influential values.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;o &amp;lt;- d
o[c(1:2), 1] &amp;lt;- c(5, 4)

head(o)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 2
##        y     x
##    &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
## 1  5     -1.84
## 2  4     -1.71
## 3 -0.168 -1.60
## 4 -0.292 -1.46
## 5 -0.785 -1.40
## 6 -0.157 -1.37&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With the code, above, we replaced the first two values of our first variable, &lt;code&gt;y&lt;/code&gt;. They both started out quite negative. Now they are positive values of a large magnitude within the standardized metric.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;frequentist-ols-models&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Frequentist &lt;a href=&#34;https://en.wikipedia.org/wiki/Ordinary_least_squares&#34;&gt;OLS&lt;/a&gt; models&lt;/h2&gt;
&lt;p&gt;To get a quick sense of what we’ve done, we’ll first fit two models with OLS regression via the &lt;code&gt;lm()&lt;/code&gt; function. The first model, &lt;code&gt;ols0&lt;/code&gt;, is of the multivariate normal data, &lt;code&gt;d&lt;/code&gt;. The second model, &lt;code&gt;ols1&lt;/code&gt;, is on the otherwise identical data with the two odd and influential values, &lt;code&gt;o&lt;/code&gt;. Here is our model code.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ols0 &amp;lt;- lm(data = d, y ~ 1 + x)
ols1 &amp;lt;- lm(data = o, y ~ 1 + x)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We’ll use the &lt;a href=&#34;https://cran.r-project.org/web/packages/broom/index.html&#34;&gt;broom package&lt;/a&gt; to assist with model summaries and other things.&lt;/p&gt;
&lt;p&gt;Here are the parameter estimates for the first model.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(broom)

tidy(ols0) %&amp;gt;% mutate_if(is.double, round, digits = 2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 2 x 5
##   term        estimate std.error statistic p.value
##   &amp;lt;chr&amp;gt;          &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt;
## 1 (Intercept)    -0.01      0.09     -0.08    0.94
## 2 x               0.45      0.1       4.55    0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And now the parameters for the second model, the one based on the &lt;code&gt;o&lt;/code&gt; outlier data.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tidy(ols1) %&amp;gt;% mutate_if(is.double, round, digits = 2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 2 x 5
##   term        estimate std.error statistic p.value
##   &amp;lt;chr&amp;gt;          &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt;
## 1 (Intercept)     0.12      0.11      1.12    0.26
## 2 x               0.15      0.13      1.21    0.23&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Just two odd and influential values dramatically changed the model parameters, particularly the slope. Let’s plot the data and the models to get a visual sense of what happened.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# The well-behaived data
p1 &amp;lt;-
  ggplot(data = d, aes(x = x, y = y)) +
  stat_smooth(method = &amp;quot;lm&amp;quot;, color = &amp;quot;grey92&amp;quot;, fill = &amp;quot;grey67&amp;quot;, alpha = 1, fullrange = T) +
  geom_point(size = 1, alpha = 3/4) +
  scale_x_continuous(limits = c(-4, 4)) +
  coord_cartesian(xlim = -3:3, 
                  ylim = -3:5) +
  labs(title = &amp;quot;No Outliers&amp;quot;) +
  theme(panel.grid = element_blank())

# The data with two outliers
p2 &amp;lt;-
  ggplot(data = o, aes(x = x, y = y, color = y &amp;gt; 3)) +
  stat_smooth(method = &amp;quot;lm&amp;quot;, color = &amp;quot;grey92&amp;quot;, fill = &amp;quot;grey67&amp;quot;, alpha = 1, fullrange = T) +
  geom_point(size = 1, alpha = 3/4) +
  scale_color_viridis_d(option = &amp;quot;A&amp;quot;, end = 4/7) +
  scale_x_continuous(limits = c(-4, 4)) +
  coord_cartesian(xlim = -3:3, 
                  ylim = -3:5) +
  labs(title = &amp;quot;Two Outliers&amp;quot;) +
  theme(panel.grid = element_blank(),
        legend.position = &amp;quot;none&amp;quot;)

library(gridExtra)

grid.arrange(p1, p2, ncol = 2)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-02-02-robust-linear-regression-with-the-robust-student-s-t-distribution_files/figure-html/unnamed-chunk-12-1.png&#34; width=&#34;648&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The two outliers were quite influential on the slope. It went from a nice clear diagonal to almost horizontal. You’ll also note how the 95% intervals (i.e., the bowtie shapes) were a bit wider when based on the &lt;code&gt;o&lt;/code&gt; data.&lt;/p&gt;
&lt;p&gt;One of the popular ways to quantify outlier status is with Mahalanobis’ distance. However, the Mahalanobis distance is primarilly valid for multivariate normal data. Though the data in this example are indeed multivariate normal–or at least they were before we injected two outlying values into them–I am going to resist relying on Mahalanobis’ distance. There are other more general approaches that will be of greater use when you need to explore other variants of the generalized linear model. The &lt;code&gt;broom::augment()&lt;/code&gt; function will give us access to one.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;aug0 &amp;lt;- augment(ols0)
aug1 &amp;lt;- augment(ols1)

glimpse(aug1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Observations: 100
## Variables: 9
## $ y          &amp;lt;dbl&amp;gt; 5.00000000, 4.00000000, -0.16783167, -0.29164105, -0.…
## $ x          &amp;lt;dbl&amp;gt; -1.8439208, -1.7071418, -1.5996509, -1.4601550, -1.39…
## $ .fitted    &amp;lt;dbl&amp;gt; -0.155937416, -0.135213012, -0.118926273, -0.09779020…
## $ .se.fit    &amp;lt;dbl&amp;gt; 0.2581834, 0.2427649, 0.2308204, 0.2155907, 0.2086463…
## $ .resid     &amp;lt;dbl&amp;gt; 5.15593742, 4.13521301, -0.04890540, -0.19385084, -0.…
## $ .hat       &amp;lt;dbl&amp;gt; 0.05521164, 0.04881414, 0.04412882, 0.03849763, 0.036…
## $ .sigma     &amp;lt;dbl&amp;gt; 0.964211, 1.017075, 1.104423, 1.104253, 1.102081, 1.1…
## $ .cooksd    &amp;lt;dbl&amp;gt; 6.809587e-01, 3.820802e-01, 4.783890e-05, 6.480561e-0…
## $ .std.resid &amp;lt;dbl&amp;gt; 4.82755612, 3.85879897, -0.04552439, -0.17992001, -0.…&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here we can compare the observations with Cook’s distance, &lt;span class=&#34;math inline&#34;&gt;\(D_i\)&lt;/span&gt; (i.e., &lt;code&gt;.cooksd&lt;/code&gt;). Cook’s &lt;span class=&#34;math inline&#34;&gt;\(D_i\)&lt;/span&gt; is a measure of the influence of a given observation on the model. To compute &lt;span class=&#34;math inline&#34;&gt;\(D_i\)&lt;/span&gt;, the model is fit once for each &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; case, after first dropping that case. Then the difference in the model with all observations and the model with all observations but the &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;th observation, as defined by the Euclidian distance between the estimators. &lt;a href=&#34;http://www.springer.com/us/book/9783642343322#aboutBook&#34;&gt;Fahrmeir et al (2013, p. 166)&lt;/a&gt; suggest that within the OLS framework “as a rule of thumb, observations with &lt;span class=&#34;math inline&#34;&gt;\(D_i\)&lt;/span&gt; &amp;gt; 0.5 are worthy of attention, and observations with &lt;span class=&#34;math inline&#34;&gt;\(D_i\)&lt;/span&gt; &amp;gt; 1 should always be examined.” Here we plot &lt;span class=&#34;math inline&#34;&gt;\(D_i\)&lt;/span&gt; against our observation index, &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;, for both models.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;aug0 %&amp;gt;%  # The well-behaived data
  mutate(i = 1:n()) %&amp;gt;%
  bind_rows(  # The data with two outliers
    aug1 %&amp;gt;%
      mutate(i = 1:n())
    ) %&amp;gt;%
  mutate(fit = rep(c(&amp;quot;fit b0&amp;quot;, &amp;quot;fit b1&amp;quot;), each = n()/2)) %&amp;gt;%
  ggplot(aes(x = i, y = .cooksd)) +
  geom_hline(yintercept = .5, color = &amp;quot;white&amp;quot;) +
  geom_point(alpha = .5) +
  geom_text(data = tibble(i = 46, 
                          .cooksd = .53,
                          fit = &amp;quot;fit b0&amp;quot;),
            label = &amp;quot;Fahrmeir et al said we might worry around here&amp;quot;,
            color = &amp;quot;grey50&amp;quot;) +
  coord_cartesian(ylim = c(0, .7)) +
  theme(panel.grid = element_blank(),
        axis.title.x = element_text(face = &amp;quot;italic&amp;quot;, family = &amp;quot;Times&amp;quot;)) +
    facet_wrap(~fit)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-02-02-robust-linear-regression-with-the-robust-student-s-t-distribution_files/figure-html/unnamed-chunk-14-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;p&gt;For the model of the well-behaved data, &lt;code&gt;ols0&lt;/code&gt;, we have &lt;span class=&#34;math inline&#34;&gt;\(D_i\)&lt;/span&gt; values all hovering near zero. However, the plot for &lt;code&gt;ols1&lt;/code&gt; shows one &lt;span class=&#34;math inline&#34;&gt;\(D_i\)&lt;/span&gt; value well above the 0.5 level and another not quite that high but deviant relative to the rest. Our two outlier values look quite influential for the results of &lt;code&gt;ols1&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;switch-to-a-bayesian-framework&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Switch to a Bayesian framework&lt;/h2&gt;
&lt;p&gt;In this project, we’ll use the &lt;a href=&#34;https://cran.r-project.org/web/packages/brms/index.html&#34;&gt;brms package&lt;/a&gt; to fit our Bayesian regression models. You can learn a lot about brms &lt;a href=&#34;https://cran.r-project.org/web/packages/brms/vignettes/brms_overview.pdf&#34;&gt;here&lt;/a&gt; and &lt;a href=&#34;https://github.com/paul-buerkner/brms&#34;&gt;here&lt;/a&gt;. Bayesian models, of course, require us to use priors. To keep things simple, we’ll use &lt;a href=&#34;https://github.com/stan-dev/stan/wiki/Prior-Choice-Recommendations&#34;&gt;weakly-regularizing priors&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(brms)&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;stick-with-gauss.&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Stick with Gauss.&lt;/h3&gt;
&lt;p&gt;For our first two Bayesian models, &lt;code&gt;b0&lt;/code&gt; and &lt;code&gt;b1&lt;/code&gt;, we’ll use the conventional Gaussian likelihood (i.e., &lt;code&gt;family = gaussian&lt;/code&gt; in the &lt;code&gt;brm()&lt;/code&gt; function). Like with &lt;code&gt;ols0&lt;/code&gt;, above, the first model is based on the nice &lt;code&gt;d&lt;/code&gt; data. The second, &lt;code&gt;b1&lt;/code&gt;, is based on the more-difficult &lt;code&gt;o&lt;/code&gt; data.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;b0 &amp;lt;- 
  brm(data = d, family = gaussian,
      y ~ 1 + x,
      prior = c(prior(normal(0, 10), class = Intercept),
                prior(normal(0, 10), class = b),
                prior(cauchy(0, 1),  class = sigma)),
      seed = 1)
b1 &amp;lt;- 
  update(b0, 
         newdata = o)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here are the model summaries.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tidy(b0) %&amp;gt;% slice(1:3) %&amp;gt;% mutate_if(is.double, round, digits = 2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##          term estimate std.error lower upper
## 1 b_Intercept    -0.01      0.09 -0.15  0.13
## 2         b_x     0.44      0.10  0.29  0.61
## 3       sigma     0.87      0.07  0.77  0.98&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tidy(b1) %&amp;gt;% slice(1:3) %&amp;gt;% mutate_if(is.double, round, digits = 2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##          term estimate std.error lower upper
## 1 b_Intercept     0.12      0.11 -0.05  0.30
## 2         b_x     0.15      0.13 -0.05  0.36
## 3       sigma     1.10      0.08  0.99  1.24&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;These should look familiar. They’re very much like the results from the OLS models. Hopefully this isn’t surprising. Our priors were quite weak, so there’s no reason to suspect the results would differ much.&lt;/p&gt;
&lt;div id=&#34;the-loo-and-other-goodies-help-with-diagnostics.&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;The LOO and other goodies help with diagnostics.&lt;/h4&gt;
&lt;p&gt;With the &lt;code&gt;loo()&lt;/code&gt; function, we’ll extract loo objects, which contain some handy output.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;loo_b0 &amp;lt;- loo(b0)
loo_b1 &amp;lt;- loo(b1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: Found 1 observations with a pareto_k &amp;gt; 0.7 in model &amp;#39;b1&amp;#39;. It is
## recommended to set &amp;#39;reloo = TRUE&amp;#39; in order to calculate the ELPD without
## the assumption that these observations are negligible. This will refit
## the model 1 times to compute the ELPDs for the problematic observations
## directly.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We’ll use &lt;code&gt;str()&lt;/code&gt; to get a sense of what’s all in there, using &lt;code&gt;loo_b1&lt;/code&gt; as an example.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str(loo_b1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## List of 11
##  $ estimates  : num [1:3, 1:2] -155.63 6.64 311.26 15.54 3.91 ...
##   ..- attr(*, &amp;quot;dimnames&amp;quot;)=List of 2
##   .. ..$ : chr [1:3] &amp;quot;elpd_loo&amp;quot; &amp;quot;p_loo&amp;quot; &amp;quot;looic&amp;quot;
##   .. ..$ : chr [1:2] &amp;quot;Estimate&amp;quot; &amp;quot;SE&amp;quot;
##  $ pointwise  : num [1:100, 1:4] -14.29 -9.09 -1.04 -1.05 -1.24 ...
##   ..- attr(*, &amp;quot;dimnames&amp;quot;)=List of 2
##   .. ..$ : NULL
##   .. ..$ : chr [1:4] &amp;quot;elpd_loo&amp;quot; &amp;quot;mcse_elpd_loo&amp;quot; &amp;quot;p_loo&amp;quot; &amp;quot;looic&amp;quot;
##  $ diagnostics:List of 2
##   ..$ pareto_k: num [1:100] 0.8286 0.5899 -0.0669 -0.1036 -0.1012 ...
##   ..$ n_eff   : num [1:100] 40.5 348 3976.3 3973.3 3927.6 ...
##  $ psis_object: NULL
##  $ elpd_loo   : num -156
##  $ p_loo      : num 6.64
##  $ looic      : num 311
##  $ se_elpd_loo: num 15.5
##  $ se_p_loo   : num 3.91
##  $ se_looic   : num 31.1
##  $ model_name : chr &amp;quot;b1&amp;quot;
##  - attr(*, &amp;quot;dims&amp;quot;)= int [1:2] 4000 100
##  - attr(*, &amp;quot;class&amp;quot;)= chr [1:3] &amp;quot;ic&amp;quot; &amp;quot;psis_loo&amp;quot; &amp;quot;loo&amp;quot;
##  - attr(*, &amp;quot;yhash&amp;quot;)= chr &amp;quot;5cdc17bb2cb41f3e3f0a617f418fff3fbb8e1ebf&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For a detailed explanation of all those elements, see the &lt;a href=&#34;https://cran.r-project.org/web/packages/loo/loo.pdf&#34;&gt;reference manual&lt;/a&gt;. For our purposes, we’ll focus on the &lt;code&gt;pareto_k&lt;/code&gt;. Here’s a glimpse of what it contains for the &lt;code&gt;b1&lt;/code&gt; model.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;loo_b1$diagnostics$pareto_k %&amp;gt;% as_tibble()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: Calling `as_tibble()` on a vector is discouraged, because the behavior is likely to change in the future. Use `tibble::enframe(name = NULL)` instead.
## This warning is displayed once per session.&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 100 x 1
##      value
##      &amp;lt;dbl&amp;gt;
##  1  0.829 
##  2  0.590 
##  3 -0.0669
##  4 -0.104 
##  5 -0.101 
##  6 -0.0321
##  7  0.0498
##  8 -0.114 
##  9  0.179 
## 10 -0.0736
## # … with 90 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We’ve got us a numeric vector of as many values as our data had observations–100 in this case. The &lt;code&gt;pareto_k&lt;/code&gt; values can be used to examine overly-influential cases. See, for example &lt;a href=&#34;https://stackoverflow.com/questions/39578834/linear-model-diagnostics-for-bayesian-models-using-rstan/39595436&#34;&gt;this discussion on stackoverflow.com&lt;/a&gt; in which several members of the &lt;a href=&#34;http://mc-stan.org&#34;&gt;Stan team&lt;/a&gt; weighed in. The issue is also discussed in &lt;a href=&#34;https://arxiv.org/abs/1507.04544&#34;&gt;this paper&lt;/a&gt;, in the &lt;a href=&#34;https://cran.r-project.org/web/packages/loo/loo.pdf&#34;&gt;loo reference manual&lt;/a&gt;, and in &lt;a href=&#34;https://www.youtube.com/watch?v=FUROJM3u5HQ&amp;amp;feature=youtu.be&amp;amp;a=&#34;&gt;this presentation by Aki Vehtari&lt;/a&gt;. If we explicitly open the &lt;a href=&#34;https://cran.r-project.org/web/packages/loo/index.html&#34;&gt;loo package&lt;/a&gt;, we can use a few convenience functions to leverage &lt;code&gt;pareto_k&lt;/code&gt; for diagnostic purposes. The &lt;code&gt;pareto_k_table()&lt;/code&gt; function will categorize the &lt;code&gt;pareto_k&lt;/code&gt; values and give us a sense of how many values are in problematic ranges.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(loo)

pareto_k_table(loo_b1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Pareto k diagnostic values:
##                          Count Pct.    Min. n_eff
## (-Inf, 0.5]   (good)     98    98.0%   3563      
##  (0.5, 0.7]   (ok)        1     1.0%   348       
##    (0.7, 1]   (bad)       1     1.0%   41        
##    (1, Inf)   (very bad)  0     0.0%   &amp;lt;NA&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Happily, most of our cases were in the “good” range. One pesky case was in the “bad” range [can you guess which one?] and another case was only “ok” [and can you guess that one, too?]. The &lt;code&gt;pareto_k_ids()&lt;/code&gt; function will tell exactly us which cases we’ll want to look at.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pareto_k_ids(loo_b1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1 2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Those numbers correspond to the row numbers in the data, &lt;code&gt;o&lt;/code&gt;. These are exactly the cases that plagued our second OLS model, &lt;code&gt;fit1&lt;/code&gt;, and are also the ones we hand coded to be outliers.&lt;/p&gt;
&lt;p&gt;With the simple &lt;code&gt;plot()&lt;/code&gt; function, we can get a diagnostic plot for the &lt;code&gt;pareto_k&lt;/code&gt; values.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot(loo_b1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-02-02-robust-linear-regression-with-the-robust-student-s-t-distribution_files/figure-html/unnamed-chunk-21-1.png&#34; width=&#34;480&#34; /&gt;&lt;/p&gt;
&lt;p&gt;There they are, cases 1 and 2, lurking in the “bad” and “[just] ok” ranges. We can also make a similar plot with ggplot2. Though it takes a little more work, ggplot2 makes it easy to compare &lt;code&gt;pareto_k&lt;/code&gt; plots across models with a little faceting.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;loo_b0$diagnostics$pareto_k %&amp;gt;%  # The well-behaived data
  as_tibble() %&amp;gt;%
  mutate(i = 1:n()) %&amp;gt;%
  bind_rows(  # The data with two outliers
    loo_b1$diagnostics$pareto_k %&amp;gt;% 
      as_tibble() %&amp;gt;%
      mutate(i = 1:n()) 
  ) %&amp;gt;%
  rename(pareto_k = value) %&amp;gt;%
  mutate(fit = rep(c(&amp;quot;fit b0&amp;quot;, &amp;quot;fit b1&amp;quot;), each = n()/2)) %&amp;gt;%
  ggplot(aes(x = i, y = pareto_k)) +
  geom_hline(yintercept = c(.5, .7, 1), color = &amp;quot;white&amp;quot;) +
  geom_point(alpha = .5) +
  geom_text(data = tibble(i = c(3, 6, 2), 
                          pareto_k = c(.45, .65, .95),
                          label = c(&amp;quot;good&amp;quot;, &amp;quot;[just] ok&amp;quot;, &amp;quot;bad&amp;quot;),
                          fit = &amp;quot;fit b0&amp;quot;),
            aes(label = label),
            color = &amp;quot;grey50&amp;quot;) +
  theme(panel.grid = element_blank(),
        axis.title.x = element_text(face = &amp;quot;italic&amp;quot;, family = &amp;quot;Times&amp;quot;)) +
  facet_wrap(~fit)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-02-02-robust-linear-regression-with-the-robust-student-s-t-distribution_files/figure-html/unnamed-chunk-22-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;p&gt;So with &lt;code&gt;b0&lt;/code&gt;–the model based on the well-behaved multivariate normal data, &lt;code&gt;d&lt;/code&gt;–, all the &lt;code&gt;pareto_k&lt;/code&gt; values hovered around zero in the “good” range. Things got concerning with model &lt;code&gt;b1&lt;/code&gt;. But we know all that. Let’s move forward.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;what-do-we-do-with-those-overly-influential-outlying-values&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;What do we do with those overly-influential outlying values?&lt;/h4&gt;
&lt;p&gt;A typical way to handle outlying values is to delete them based on some criterion, such as the Mahalanobis distance, Cook’s &lt;span class=&#34;math inline&#34;&gt;\(D_i\)&lt;/span&gt;, or our new friend the &lt;code&gt;pareto_k&lt;/code&gt;. In our next two models, we’ll do that. In our &lt;code&gt;data&lt;/code&gt; arguments, we can use the &lt;code&gt;slice()&lt;/code&gt; function to omit cases. In model &lt;code&gt;b1.1&lt;/code&gt;, we simply omit the first and most influential case. In model &lt;code&gt;b1.2&lt;/code&gt;, we omitted both unduly-influential cases, the values from rows 1 and 2.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;b1.1 &amp;lt;- 
  update(b1, 
         newdata = o %&amp;gt;% slice(2:100))
b1.2 &amp;lt;- 
  update(b1, 
         newdata = o %&amp;gt;% slice(3:100))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here are the summaries for our models based on the &lt;code&gt;slice[d]&lt;/code&gt; data.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tidy(b1.1) %&amp;gt;% slice(1:3) %&amp;gt;% mutate_if(is.double, round, digits = 2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##          term estimate std.error lower upper
## 1 b_Intercept     0.07      0.10 -0.09  0.23
## 2         b_x     0.28      0.12  0.09  0.47
## 3       sigma     0.97      0.07  0.87  1.09&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tidy(b1.2) %&amp;gt;% slice(1:3) %&amp;gt;% mutate_if(is.double, round, digits = 2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##          term estimate std.error lower upper
## 1 b_Intercept     0.02      0.09 -0.12  0.16
## 2         b_x     0.40      0.10  0.23  0.56
## 3       sigma     0.86      0.06  0.76  0.97&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;They are closer to the true data generating model (i.e., the code we used to make &lt;code&gt;d&lt;/code&gt;), especially &lt;code&gt;b1.2&lt;/code&gt;. However, there are other ways to handle the influential cases without dropping them. Finally, we’re ready to switch to Student’s &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;time-to-leave-gauss-for-the-more-general-students-t&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Time to leave Gauss for the more general Student’s &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Recall that the normal distribution is equivalent to a Student’s &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; with the degrees of freedom parameter, &lt;span class=&#34;math inline&#34;&gt;\(\nu\)&lt;/span&gt;, set to infinity. That is, &lt;span class=&#34;math inline&#34;&gt;\(\nu\)&lt;/span&gt; is fixed. Here we’ll relax that assumption and estimate &lt;span class=&#34;math inline&#34;&gt;\(\nu\)&lt;/span&gt; from the data just like we estimate &lt;span class=&#34;math inline&#34;&gt;\(\mu\)&lt;/span&gt; with the linear model and &lt;span class=&#34;math inline&#34;&gt;\(\sigma\)&lt;/span&gt; as the residual spread. Since &lt;span class=&#34;math inline&#34;&gt;\(\nu\)&lt;/span&gt;’s now a parameter, we’ll have to give it a prior. For our first Student’s &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; model, we’ll estimate &lt;span class=&#34;math inline&#34;&gt;\(\nu\)&lt;/span&gt; with the brms default gamma(2, 0.1) prior.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;b2 &amp;lt;- 
  brm(data = o, family = student,
      y ~ 1 + x,
      prior = c(prior(normal(0, 10), class = Intercept),
                prior(normal(0, 10), class = b),
                prior(gamma(2, 0.1), class = nu),
                prior(cauchy(0, 1),  class = sigma)),
      seed = 1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For the next model, we’ll switch out that weak gamma(2, 0.1) for a stronger gamma(4, 1). In some disciplines, the gamma distribution is something of an exotic bird. So before fitting the model, it might be useful to take a peek at what these gamma priors looks like. In the plot, below, the orange density in the background is the default gamma(2, 0.1) and the purple density in the foreground is the stronger gamma(4, 1).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# data
tibble(x = seq(from = 0, to = 60, by = .1)) %&amp;gt;% 
  expand(x, nesting(alpha = c(2, 4), 
                    beta  = c(0.1, 1))) %&amp;gt;% 
  mutate(density = dgamma(x, alpha, beta),
         group   = rep(letters[1:2], times = n() / 2)) %&amp;gt;% 
  
  # plot
  ggplot(aes(x = x, ymin = 0, ymax = density, 
             group = group, fill = group)) +
  geom_ribbon(size = 0, alpha = 3/4) +
  scale_fill_viridis_d(option = &amp;quot;B&amp;quot;, direction = -1, 
                       begin = 1/3, end = 2/3) +
  scale_y_continuous(NULL, breaks = NULL) +
  coord_cartesian(xlim = 0:50) +
  theme(panel.grid      = element_blank(),
        legend.position = &amp;quot;none&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-02-02-robust-linear-regression-with-the-robust-student-s-t-distribution_files/figure-html/unnamed-chunk-24-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;p&gt;So the default prior is centered around values in the 2 to 30 range, but has a long gentle-sloping tail, allowing the model to yield much larger values for &lt;span class=&#34;math inline&#34;&gt;\(\nu\)&lt;/span&gt;, as needed. The prior we use below is almost entirely concentrated in the single-digit range. In this case, that will preference Student’s &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; likelihoods with very small &lt;span class=&#34;math inline&#34;&gt;\(\nu\)&lt;/span&gt; parameters and correspondingly thick tails–easily allowing for extreme values.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;b3 &amp;lt;- 
  update(b2,
         prior = c(prior(normal(0, 10), class = Intercept),
                   prior(normal(0, 10), class = b),
                   prior(gamma(4, 1),   class = nu),
                   prior(cauchy(0, 1),  class = sigma)),
         seed = 1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For our final model, we’ll fix the &lt;span class=&#34;math inline&#34;&gt;\(\nu\)&lt;/span&gt; parameter in a &lt;code&gt;bf()&lt;/code&gt; statement.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;b4 &amp;lt;-
  brm(data = o, family = student,
      bf(y ~ 1 + x, nu = 4),
      prior = c(prior(normal(0, 100), class = Intercept),
                prior(normal(0, 10),  class = b),
                prior(cauchy(0, 1),   class = sigma)),
         seed = 1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we’ve got all those models, we can gather their results into a sole tibble.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;b_estimates &amp;lt;-
  tibble(model = c(&amp;quot;b0&amp;quot;, &amp;quot;b1&amp;quot;, &amp;quot;b1.1&amp;quot;, &amp;quot;b1.2&amp;quot;, &amp;quot;b2&amp;quot;, &amp;quot;b3&amp;quot;, &amp;quot;b4&amp;quot;)) %&amp;gt;% 
  mutate(fit   = map(model, get)) %&amp;gt;% 
  mutate(tidy  = map(fit, tidy)) %&amp;gt;% 
  unnest(tidy) %&amp;gt;% 
  filter(term %in% c(&amp;quot;b_Intercept&amp;quot;, &amp;quot;b_x&amp;quot;)) %&amp;gt;%
  arrange(term)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To get a sense of what we’ve done, let’s take a peek at our models tibble.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;b_estimates %&amp;gt;%
  mutate_if(is.double, round, digits = 2)  # This is just to round the numbers&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 14 x 7
##    model fit       term        estimate std.error  lower upper
##    &amp;lt;chr&amp;gt; &amp;lt;list&amp;gt;    &amp;lt;chr&amp;gt;          &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
##  1 b0    &amp;lt;brmsfit&amp;gt; b_Intercept    -0.01      0.09 -0.15   0.13
##  2 b1    &amp;lt;brmsfit&amp;gt; b_Intercept     0.12      0.11 -0.05   0.3 
##  3 b1.1  &amp;lt;brmsfit&amp;gt; b_Intercept     0.07      0.1  -0.09   0.23
##  4 b1.2  &amp;lt;brmsfit&amp;gt; b_Intercept     0.02      0.09 -0.12   0.16
##  5 b2    &amp;lt;brmsfit&amp;gt; b_Intercept     0.04      0.09 -0.11   0.2 
##  6 b3    &amp;lt;brmsfit&amp;gt; b_Intercept     0.04      0.09 -0.11   0.19
##  7 b4    &amp;lt;brmsfit&amp;gt; b_Intercept     0.04      0.09 -0.11   0.19
##  8 b0    &amp;lt;brmsfit&amp;gt; b_x             0.44      0.1   0.290  0.61
##  9 b1    &amp;lt;brmsfit&amp;gt; b_x             0.15      0.13 -0.05   0.36
## 10 b1.1  &amp;lt;brmsfit&amp;gt; b_x             0.28      0.12  0.09   0.47
## 11 b1.2  &amp;lt;brmsfit&amp;gt; b_x             0.4       0.1   0.23   0.56
## 12 b2    &amp;lt;brmsfit&amp;gt; b_x             0.35      0.11  0.17   0.53
## 13 b3    &amp;lt;brmsfit&amp;gt; b_x             0.36      0.1   0.19   0.53
## 14 b4    &amp;lt;brmsfit&amp;gt; b_x             0.37      0.1   0.2    0.54&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The models differ by their intercepts, slopes, sigmas, and &lt;span class=&#34;math inline&#34;&gt;\(\nu\)&lt;/span&gt;s. For the sake of this post, we’ll focus on the slopes. Here we compare the different Bayesian models’ slopes by their posterior means and 95% intervals in a coefficient plot.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;b_estimates %&amp;gt;%
  filter(term == &amp;quot;b_x&amp;quot;) %&amp;gt;% # b_Intercept b_x
  
  ggplot(aes(x = model)) +
  geom_pointrange(aes(y    = estimate,
                      ymin = lower,
                      ymax = upper),
                  shape = 20) +
  coord_flip(ylim = c(-.2, 1)) +
  labs(title    = &amp;quot;The x slope, varying by model&amp;quot;,
       subtitle = &amp;quot;The dots are the posterior means and the lines the percentile-based 95% intervals.&amp;quot;,
       x        = NULL,
       y        = NULL) +
  theme(panel.grid   = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.y  = element_text(hjust = 0))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-02-02-robust-linear-regression-with-the-robust-student-s-t-distribution_files/figure-html/unnamed-chunk-27-1.png&#34; width=&#34;576&#34; /&gt;&lt;/p&gt;
&lt;p&gt;You might think of the &lt;code&gt;b0&lt;/code&gt; slope as the “true” slope. That’s the one estimated from the well-behaved multivariate normal data, &lt;code&gt;d&lt;/code&gt;. That estimate’s just where we’d want it to be. The &lt;code&gt;b1&lt;/code&gt; slope is a disaster–way lower than the others. The slopes for &lt;code&gt;b1.1&lt;/code&gt; and &lt;code&gt;b1.2&lt;/code&gt; get better, but at the expense of deleting data. All three of our Student’s &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; models produced slopes that were pretty close to the &lt;code&gt;b0&lt;/code&gt; slope. They weren’t perfect, but, all in all, Student’s &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;-distribution did pretty okay.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;we-need-more-loo-and-more-pareto_k.&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;We need more LOO and more &lt;code&gt;pareto_k&lt;/code&gt;.&lt;/h3&gt;
&lt;p&gt;We already have loo objects for our first two models, &lt;code&gt;b0&lt;/code&gt; and &lt;code&gt;b1&lt;/code&gt;. Let’s get some for models &lt;code&gt;b2&lt;/code&gt; through &lt;code&gt;b4&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;loo_b2 &amp;lt;- loo(b2)
loo_b3 &amp;lt;- loo(b3)
loo_b4 &amp;lt;- loo(b4)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With a little data wrangling, we can compare our models by how they look in our custom &lt;code&gt;pareto_k&lt;/code&gt; diagnostic plots.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# make a custom function to work with the loo objects in bulk
get_pareto_k &amp;lt;- function(l) {
  l$diagnostics$pareto_k %&amp;gt;% 
    as_tibble() %&amp;gt;%
    mutate(i = 1:n()) %&amp;gt;% 
    rename(pareto_k = value)
}

# wrangle
tibble(name = str_c(&amp;quot;loo_b&amp;quot;, 1:4)) %&amp;gt;% 
  mutate(loo_object = map(name, get)) %&amp;gt;% 
  mutate(pareto_k = map(loo_object, get_pareto_k)) %&amp;gt;% 
  unnest(pareto_k) %&amp;gt;% 
  mutate(fit = rep(c(&amp;quot;fit b1&amp;quot;, &amp;quot;fit b2&amp;quot;, &amp;quot;fit b3&amp;quot;, &amp;quot;fit b4&amp;quot;), each = n() / 4)) %&amp;gt;%
  
  # plot
  ggplot(aes(x = i, y = pareto_k)) +
  geom_hline(yintercept = c(.5, .7),
             color = &amp;quot;white&amp;quot;) +
  geom_point(alpha = .5) +
  scale_y_continuous(breaks = c(0, .5, .7)) +
  theme(panel.grid   = element_blank(),
        axis.title.x = element_text(face = &amp;quot;italic&amp;quot;, family = &amp;quot;Times&amp;quot;)) +
    facet_wrap(~fit)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-02-02-robust-linear-regression-with-the-robust-student-s-t-distribution_files/figure-html/unnamed-chunk-28-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Oh man, those Student’s &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; models worked sweet! In a succession from &lt;code&gt;b2&lt;/code&gt; through &lt;code&gt;b4&lt;/code&gt;, each model looked better by &lt;code&gt;pareto_k&lt;/code&gt;. All were way better than the typical Gaussian model, &lt;code&gt;b1&lt;/code&gt;. While we’re at it, we might compare those by their LOO values.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;compare_ic(loo_b1, loo_b2, loo_b3, loo_b4)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: &amp;#39;compare_ic&amp;#39; is deprecated and will be removed in the future.
## Please use &amp;#39;loo_compare&amp;#39; instead.&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##          LOOIC    SE
## b1      311.26 31.09
## b2      289.97 23.07
## b3      287.64 20.83
## b4      285.95 20.19
## b1 - b2  21.29 11.68
## b1 - b3  23.62 14.58
## b1 - b4  25.31 15.46
## b2 - b3   2.33  3.03
## b2 - b4   4.02  3.95
## b3 - b4   1.69  0.92&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In terms of the LOO, &lt;code&gt;b2&lt;/code&gt; through &lt;code&gt;b4&lt;/code&gt; were about the same, but all looked better than &lt;code&gt;b1&lt;/code&gt;. In fairness, though, the standard errors for the difference scores were a bit on the wide side.
If you’re new to using information criteria to compare models, you might sit down and soak in &lt;a href=&#34;https://www.youtube.com/watch?v=t0pRuy1_190&amp;amp;list=PLDcUM9US4XdM9_N6XUUFrhghGJ4K25bFc&amp;amp;index=8&#34;&gt;this lecture on the topic&lt;/a&gt; and &lt;a href=&#34;https://cran.r-project.org/web/packages/loo/vignettes/loo-example.html&#34;&gt;this vignette&lt;/a&gt; on the LOO in particular. For a more technical introduction, you might check out the references in the loo package’s &lt;a href=&#34;https://cran.r-project.org/web/packages/loo/loo.pdf&#34;&gt;reference manual&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;For one final LOO-related comparison, we can use the &lt;code&gt;brms::model_weights()&lt;/code&gt; function to see how much relative weight we might put on each of those four models if we were to use a model averaging approach. Here we use the default method, which is model averaging via posterior predictive stacking.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;model_weights(b1, b2, b3, b4)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##           b1           b2           b3           b4 
## 3.361150e-06 8.798859e-08 4.484138e-06 9.999921e-01&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you’re not a fan of scientific notation, just tack on &lt;code&gt;round(digits = 2)&lt;/code&gt;. The stacking method suggests that we should place virtually all the weight on &lt;code&gt;b4&lt;/code&gt;, the model in which we fixed our Student-&lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; &lt;span class=&#34;math inline&#34;&gt;\(\nu\)&lt;/span&gt; parameter at 4. To learn more about model stacking, check out Yao, Vehtari, Simpson, and Gelman’s (2018) paper, &lt;a href=&#34;https://projecteuclid.org/euclid.ba/1516093227&#34;&gt;&lt;em&gt;Using stacking to average Bayesian predictive distributions&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;lets-compare-a-few-bayesian-models.&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Let’s compare a few Bayesian models.&lt;/h3&gt;
&lt;p&gt;That’s enough with coefficients, &lt;code&gt;pareto_k&lt;/code&gt;, and the LOO. Let’s get a sense of the implications of the models by comparing a few in plots. Here we use convenience functions from &lt;a href=&#34;https://twitter.com/mjskay&#34;&gt;Matthew Kay&lt;/a&gt;’s &lt;a href=&#34;https://github.com/mjskay/tidybayes&#34;&gt;tidybayes&lt;/a&gt; package to streamline the data wrangling and plotting. [The method came from a &lt;a href=&#34;https://twitter.com/mjskay/status/1091926564101599232&#34;&gt;kind twitter suggesion from Kay&lt;/a&gt;.]&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidybayes)

# These are the values of x we&amp;#39;d like model-implied summaries for
nd &amp;lt;- tibble(x = seq(from = -4, to = 4, length.out = 50))

# here&amp;#39;s another way to arrange the models
list(b0 = b0, b1 = b1, b3 = b3) %&amp;gt;% 
  # with help from 1tidybayes::add_fitted_draws()`, here we use `fitted()` in bulk
  map_dfr(add_fitted_draws, newdata = nd, .id = &amp;quot;model&amp;quot;) %&amp;gt;% 
  
  # plot
  ggplot(aes(x = x)) +
  stat_lineribbon(aes(y = .value),
                  .width = .95,
                  color = &amp;quot;grey92&amp;quot;, fill = &amp;quot;grey67&amp;quot;) +
  geom_point(data = d %&amp;gt;%
               bind_rows(o, o) %&amp;gt;%
               mutate(model = rep(c(&amp;quot;b0&amp;quot;, &amp;quot;b1&amp;quot;, &amp;quot;b3&amp;quot;), each = 100)), 
             aes(y = y, color = y &amp;gt; 3),
             size = 1, alpha = 3/4) +
  scale_color_viridis_d(option = &amp;quot;A&amp;quot;, end = 4/7) +
  coord_cartesian(xlim = -3:3, 
                  ylim = -3:5) +
  ylab(NULL) +
  theme(panel.grid      = element_blank(),
        legend.position = &amp;quot;none&amp;quot;) +
  facet_wrap(~model)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-02-02-robust-linear-regression-with-the-robust-student-s-t-distribution_files/figure-html/unnamed-chunk-31-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;p&gt;For each subplot, the gray band is the 95% interval band and the overlapping light gray line is the posterior mean. Model &lt;code&gt;b0&lt;/code&gt;, recall, is our baseline comparison model. This is of the well-behaved no-outlier data, &lt;code&gt;d&lt;/code&gt;, using the good old Gaussian likelihood. Model &lt;code&gt;b1&lt;/code&gt; is of the outlier data, &lt;code&gt;o&lt;/code&gt;, but still using the non-robust Gaussian likelihood. Model &lt;code&gt;b3&lt;/code&gt; uses a robust Student’s &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; likelihood with &lt;span class=&#34;math inline&#34;&gt;\(\nu\)&lt;/span&gt; estimated with the fairly narrow gamma(4, 1) prior. For my money, &lt;code&gt;b3&lt;/code&gt; did a pretty good job.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sessionInfo()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## R version 3.6.0 (2019-04-26)
## Platform: x86_64-apple-darwin15.6.0 (64-bit)
## Running under: macOS High Sierra 10.13.6
## 
## Matrix products: default
## BLAS:   /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRblas.0.dylib
## LAPACK: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRlapack.dylib
## 
## Random number generation:
##  RNG:     Mersenne-Twister 
##  Normal:  Inversion 
##  Sample:  Rounding 
##  
## locale:
## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
##  [1] tidybayes_1.1.0 loo_2.1.0       brms_2.10.0     Rcpp_1.0.2     
##  [5] gridExtra_2.3   broom_0.5.2     forcats_0.4.0   stringr_1.4.0  
##  [9] dplyr_0.8.3     purrr_0.3.2     readr_1.3.1     tidyr_1.0.0    
## [13] tibble_2.1.3    ggplot2_3.2.1   tidyverse_1.2.1
## 
## loaded via a namespace (and not attached):
##   [1] colorspace_1.4-1          ggridges_0.5.1           
##   [3] rsconnect_0.8.13          ggstance_0.3.2           
##   [5] markdown_1.0              base64enc_0.1-3          
##   [7] rstudioapi_0.10           rstan_2.19.2             
##   [9] svUnit_0.7-12             DT_0.7                   
##  [11] fansi_0.4.0               mvtnorm_1.0-11           
##  [13] lubridate_1.7.4           xml2_1.2.0               
##  [15] bridgesampling_0.6-0      knitr_1.23               
##  [17] shinythemes_1.1.2         zeallot_0.1.0            
##  [19] bayesplot_1.7.0           jsonlite_1.6             
##  [21] shiny_1.3.2               compiler_3.6.0           
##  [23] httr_1.4.0                backports_1.1.4          
##  [25] assertthat_0.2.1          Matrix_1.2-17            
##  [27] lazyeval_0.2.2            cli_1.1.0                
##  [29] later_0.8.0               htmltools_0.3.6          
##  [31] prettyunits_1.0.2         tools_3.6.0              
##  [33] igraph_1.2.4.1            coda_0.19-2              
##  [35] gtable_0.3.0              glue_1.3.1               
##  [37] reshape2_1.4.3            cellranger_1.1.0         
##  [39] vctrs_0.2.0               nlme_3.1-139             
##  [41] blogdown_0.14             crosstalk_1.0.0          
##  [43] xfun_0.8                  ps_1.3.0                 
##  [45] rvest_0.3.4               mime_0.7                 
##  [47] miniUI_0.1.1.1            lifecycle_0.1.0          
##  [49] gtools_3.8.1              MASS_7.3-51.4            
##  [51] zoo_1.8-6                 scales_1.0.0             
##  [53] colourpicker_1.0          hms_0.4.2                
##  [55] promises_1.0.1            Brobdingnag_1.2-6        
##  [57] parallel_3.6.0            inline_0.3.15            
##  [59] shinystan_2.5.0           yaml_2.2.0               
##  [61] StanHeaders_2.18.1-10     stringi_1.4.3            
##  [63] highr_0.8                 dygraphs_1.1.1.6         
##  [65] pkgbuild_1.0.3            rlang_0.4.0              
##  [67] pkgconfig_2.0.2           matrixStats_0.54.0       
##  [69] evaluate_0.14             lattice_0.20-38          
##  [71] rstantools_1.5.1          htmlwidgets_1.3          
##  [73] labeling_0.3              tidyselect_0.2.5         
##  [75] processx_3.3.1            plyr_1.8.4               
##  [77] magrittr_1.5              bookdown_0.12            
##  [79] R6_2.4.0                  generics_0.0.2           
##  [81] pillar_1.4.2              haven_2.1.0              
##  [83] withr_2.1.2               xts_0.11-2               
##  [85] abind_1.4-5               modelr_0.1.4             
##  [87] crayon_1.3.4              arrayhelpers_1.0-20160527
##  [89] utf8_1.1.4                rmarkdown_1.13           
##  [91] grid_3.6.0                readxl_1.3.1             
##  [93] callr_3.2.0               threejs_0.3.1            
##  [95] digest_0.6.20             xtable_1.8-4             
##  [97] httpuv_1.5.1              stats4_3.6.0             
##  [99] munsell_0.5.0             viridisLite_0.3.0        
## [101] shinyjs_1.0&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Make rotated Gaussians, Kruschke style</title>
      <link>/post/make-rotated-gaussians-kruschke-style/</link>
      <pubDate>Thu, 20 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/make-rotated-gaussians-kruschke-style/</guid>
      <description>&lt;p&gt;[edited Dec 23, 2018]&lt;/p&gt;
&lt;div id=&#34;tldr&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;tl;dr&lt;/h2&gt;
&lt;p&gt;You too can make sideways Gaussian density curves within the tidyverse. Here’s how.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;heres-the-deal-i-like-making-pictures.&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Here’s the deal: I like making pictures.&lt;/h2&gt;
&lt;p&gt;Over the past several months, I’ve been slowly chipping away at John Kruschke’s &lt;a href=&#34;https://sites.google.com/site/doingbayesiandataanalysis/&#34;&gt;&lt;em&gt;Doing Bayesian data analysis, Second Edition: A tutorial with R, JAGS, and Stan&lt;/em&gt;&lt;/a&gt;. Kruschke has a unique plotting style. One of the quirks is once in a while he likes to express the results of his analyses in plots where he shows the data alongside density curves of the model-implied data-generating distributions. Here’s an example from chapter 19 (p. 563).&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/Kruschke_sideways_Gaussians.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;In this example, he has lifespan data (i.e., &lt;code&gt;Longevity&lt;/code&gt;) for fruit flies from five experimental conditions (i.e., &lt;code&gt;CompanionNumber&lt;/code&gt;). Those are the black circles. In this section of the chapter, he used a Gaussian multilevel model in which the mean value for &lt;code&gt;Longevity&lt;/code&gt; had a grand mean in addition to random effects for the five experimental conditions. Those sideways-turned blue Gaussians are his attempt to express the model-implied data generating distributions for each group.&lt;/p&gt;
&lt;p&gt;If you haven’t gone through Kruschke’s text, you should know he relies on base R and all its &lt;a href=&#34;https://bookdown.org/rdpeng/rprogdatascience/control-structures.html#for-loops&#34;&gt;loop&lt;/a&gt;y glory. If you carefully go through his code, you can reproduce his plots in that fashion. I’m a &lt;a href=&#34;https://www.tidyverse.org&#34;&gt;tidyverse&lt;/a&gt; man and prefer to avoid writing a &lt;code&gt;for()&lt;/code&gt; loop at all costs. At first, I tried to work with convenience functions within ggplot2 and friends, but only had limited success. After staring long and hard at Kruschke’s base code, I came up with a robust solution, which I’d like to share here.&lt;/p&gt;
&lt;p&gt;In this post, we’ll practice making sideways Gaussians in the Kruschke style. We’ll do so with a simple intercept-only single-level model and then expand our approach to an intercept-only multilevel model like the one in the picture, above.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;my-assumptions&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;My assumptions&lt;/h2&gt;
&lt;p&gt;For the sake of this post, I’m presuming you’re familiar with &lt;a href=&#34;https://bookdown.org/rdpeng/rprogdatascience/history-and-overview-of-r.html&#34;&gt;R&lt;/a&gt;, aware of the &lt;a href=&#34;https://www.rstudio.com/resources/videos/data-science-in-the-tidyverse/&#34;&gt;tidyverse&lt;/a&gt;, and have fit a &lt;a href=&#34;https://www.youtube.com/watch?v=4WVelCswXo4&#34;&gt;Bayesian model&lt;/a&gt; or two. Yes. I admit that’s a narrow crowd. Sometimes the target’s a small one.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;we-need-data.&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;We need data.&lt;/h2&gt;
&lt;p&gt;First, we need data. Here we’ll borrow code from Matthew Kay’s nice &lt;a href=&#34;https://mjskay.github.io/tidybayes/articles/tidy-brms.html&#34;&gt;tutorial&lt;/a&gt; on how to use his great &lt;a href=&#34;https://github.com/mjskay/tidybayes&#34;&gt;tidybayes package&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidyverse)

set.seed(5)
n           &amp;lt;- 10
n_condition &amp;lt;- 5

abc &amp;lt;-
  tibble(condition = rep(letters[1:5], times = n),
         response  = rnorm(n * 5, mean = c(0, 1, 2, 1, -1), sd = 0.5))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The data structure looks like so.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str(abc)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Classes &amp;#39;tbl_df&amp;#39;, &amp;#39;tbl&amp;#39; and &amp;#39;data.frame&amp;#39;:    50 obs. of  2 variables:
##  $ condition: chr  &amp;quot;a&amp;quot; &amp;quot;b&amp;quot; &amp;quot;c&amp;quot; &amp;quot;d&amp;quot; ...
##  $ response : num  -0.42 1.692 1.372 1.035 -0.144 ...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With Kay’s code, we have &lt;code&gt;response&lt;/code&gt; values for five &lt;code&gt;condition&lt;/code&gt;s. All follow the normal distribution and share a common standard deviation. However, they differ in their group means.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;abc %&amp;gt;% 
  group_by(condition) %&amp;gt;% 
  summarise(mean = mean(response) %&amp;gt;% round(digits = 2))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 5 x 2
##   condition  mean
##   &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt;
## 1 a          0.18
## 2 b          1.01
## 3 c          1.87
## 4 d          1.03
## 5 e         -0.94&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Altogether, the data look like this.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;theme_set(theme_grey() + 
            theme(panel.grid = element_blank()))

abc %&amp;gt;%
  ggplot(aes(y = condition, x = response)) +
  geom_point(shape = 1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-12-20-make-rotated-gaussians-kruschke-style_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;576&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Let’s get ready to model.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;just-one-intercept&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Just one intercept&lt;/h2&gt;
&lt;p&gt;If you’ve read this far, you know we’re going Bayesian. Let’s open up our favorite Bayesian modeling package, Bürkner’s &lt;a href=&#34;https://github.com/paul-buerkner/brms&#34;&gt;brms&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(brms)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For our first model, we’ll ignore the groups and just estimate a grand mean and a standard deviation. Relative to the scale of the &lt;code&gt;abc&lt;/code&gt; data, our priors are modestly &lt;a href=&#34;https://github.com/stan-dev/stan/wiki/Prior-Choice-Recommendations&#34;&gt;regularizing&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fit1 &amp;lt;- 
  brm(data = abc,
      response ~ 1,
      prior = c(prior(normal(0, 1), class = Intercept),
                prior(student_t(3, 0, 1), class = sigma)))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Extract the posterior draws and save them as a data frame we’ll call &lt;code&gt;post&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;post &amp;lt;- posterior_samples(fit1)

glimpse(post)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Observations: 4,000
## Variables: 3
## $ b_Intercept &amp;lt;dbl&amp;gt; 0.5987480, 0.5987480, 0.7314609, 0.6445826, 0.5576265, 0.7100258, 0.5000373, …
## $ sigma       &amp;lt;dbl&amp;gt; 1.1177155, 1.1177155, 1.0092032, 1.0192299, 1.1700033, 1.0615338, 1.0849874, …
## $ lp__        &amp;lt;dbl&amp;gt; -76.96158, -76.96158, -77.46269, -77.09759, -77.26516, -77.10602, -77.20185, …&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If all you want is a quick and dirty way to plot a few of the model-implied Gaussians from the simple model, you can just nest &lt;code&gt;stat_function()&lt;/code&gt; within &lt;code&gt;mapply()&lt;/code&gt; and tack on the original data in a &lt;code&gt;geom_jitter()&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# How many Gaussians would you like?
n_iter &amp;lt;- 20

tibble(response = c(-4, 4)) %&amp;gt;%
  ggplot(aes(x = response)) +
  mapply(function(mean, sd) {
    stat_function(fun   = dnorm, 
                  args  = list(mean = mean, sd = sd), 
                  alpha = 1/2, 
                  color = &amp;quot;steelblue&amp;quot;)
    }, 
    # Enter means and standard deviations here
    mean = post[1:n_iter, &amp;quot;b_Intercept&amp;quot;],
    sd   = post[1:n_iter, &amp;quot;sigma&amp;quot;]
    ) +
  geom_jitter(data = abc, aes(y = -0.02),
              height = .025, shape = 1, alpha = 2/3) +
  scale_y_continuous(NULL, breaks = NULL)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-12-20-make-rotated-gaussians-kruschke-style_files/figure-html/unnamed-chunk-7-1.png&#34; width=&#34;384&#34; /&gt;&lt;/p&gt;
&lt;p&gt;This works pretty okay. But notice the orientation is the usual horizontal. Kruschke’s Gaussians were on their sides. If we switch out our &lt;code&gt;scale_y_continuous()&lt;/code&gt; line with &lt;code&gt;scale_y_reverse()&lt;/code&gt; and add in &lt;code&gt;coord_flip()&lt;/code&gt;, we’ll have it.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tibble(response = c(-4, 4)) %&amp;gt;%
  ggplot(aes(x = response)) +
  mapply(function(mean, sd) {
    stat_function(fun   = dnorm, 
                  args  = list(mean = mean, sd = sd), 
                  alpha = 1/2, 
                  color = &amp;quot;steelblue&amp;quot;)
    }, 
    mean = post[1:n_iter, &amp;quot;b_Intercept&amp;quot;],
    sd   = post[1:n_iter, &amp;quot;sigma&amp;quot;]
    ) +
  geom_jitter(data = abc, aes(y = -0.02),
              height = .025, shape = 1, alpha = 2/3) +
  scale_y_reverse(NULL, breaks = NULL) +
  coord_flip() &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-12-20-make-rotated-gaussians-kruschke-style_files/figure-html/unnamed-chunk-8-1.png&#34; width=&#34;288&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Boom. It won’t always be this easy, though.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;multiple-intercepts&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Multiple intercepts&lt;/h2&gt;
&lt;p&gt;Since the &lt;code&gt;response&lt;/code&gt; values are from a combination of five &lt;code&gt;condition&lt;/code&gt; groups, we can fit a multilevel model to compute both the grand mean and the group-level deviations from the grand mean.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fit2 &amp;lt;- 
  brm(data = abc,
      response ~ 1 + (1 | condition),
      prior = c(prior(normal(0, 1), class = Intercept),
                prior(student_t(3, 0, 1), class = sigma),
                prior(student_t(3, 0, 1), class = sd)),
      cores = 4)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;“Wait. Whoa. I’m so confused”—you say. “What’s a multilevel model, again?” Read this &lt;a href=&#34;https://xcelab.net/rm/statistical-rethinking/&#34;&gt;book&lt;/a&gt;, or this &lt;a href=&#34;https://sites.google.com/site/doingbayesiandataanalysis/&#34;&gt;book&lt;/a&gt;; start &lt;a href=&#34;https://www.youtube.com/watch?v=2sTQ7TG_85Q&#34;&gt;here&lt;/a&gt; on this lecture series; or even check out &lt;a href=&#34;https://bookdown.org/connect/#/apps/1850/access&#34;&gt;my project&lt;/a&gt;, starting with chapter 12.&lt;/p&gt;
&lt;p&gt;Once again, extract the posterior draws and save them as a data frame, &lt;code&gt;post&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;post &amp;lt;- posterior_samples(fit2)

str(post)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## &amp;#39;data.frame&amp;#39;:    4000 obs. of  9 variables:
##  $ b_Intercept             : num  0.0379 0.102 -0.048 -1.0037 0.0231 ...
##  $ sd_condition__Intercept : num  2.08 2.13 1.94 1.99 2.21 ...
##  $ sigma                   : num  0.473 0.468 0.475 0.648 0.527 ...
##  $ r_condition[a,Intercept]: num  -0.01062 0.00219 0.23764 1.40189 0.08825 ...
##  $ r_condition[b,Intercept]: num  0.877 0.911 0.781 1.944 1.233 ...
##  $ r_condition[c,Intercept]: num  1.46 1.62 2.03 3.15 1.74 ...
##  $ r_condition[d,Intercept]: num  0.995 1.096 1.014 2.217 0.876 ...
##  $ r_condition[e,Intercept]: num  -1.111 -1.144 -1.005 0.234 -0.906 ...
##  $ lp__                    : num  -51.8 -49.2 -50 -53.5 -48.7 ...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is where our task becomes difficult. Now each level of &lt;code&gt;condition&lt;/code&gt; has its own mean estimate, which is a combination of the grand mean &lt;code&gt;b_Intercept&lt;/code&gt; and the group-specific deviation, &lt;code&gt;r_condition[a,Intercept]&lt;/code&gt; through &lt;code&gt;r_condition[e,Intercept]&lt;/code&gt;. If all we wanted to do was show the model-implied Gaussians for, say, &lt;code&gt;condition == a&lt;/code&gt;, that’d be a small extension of our last approach.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tibble(response = c(-4, 4)) %&amp;gt;%
  ggplot(aes(x = response)) +
  mapply(function(mean, sd) {
    stat_function(fun   = dnorm, 
                  args  = list(mean = mean, sd = sd), 
                  alpha = 1/2, 
                  color = &amp;quot;steelblue&amp;quot;)
    }, 
    # Here&amp;#39;s the small extension, part a
    mean = post[1:n_iter, &amp;quot;b_Intercept&amp;quot;] + post[1:n_iter, &amp;quot;r_condition[a,Intercept]&amp;quot;],
    sd   = post[1:n_iter, &amp;quot;sigma&amp;quot;]
    ) +
  # The small extension, part b:
  geom_jitter(data = abc %&amp;gt;% filter(condition == &amp;quot;a&amp;quot;), aes(y = 0),
              height = .025, shape = 1, alpha = 2/3) +
  scale_y_reverse(NULL, breaks = NULL) +
  coord_flip() +
  labs(subtitle = &amp;quot;This is just for condition a&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-12-20-make-rotated-gaussians-kruschke-style_files/figure-html/unnamed-chunk-10-1.png&#34; width=&#34;288&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The main thing we did was add to the definition of the &lt;code&gt;mean&lt;/code&gt; within &lt;code&gt;mapply()&lt;/code&gt;: &lt;code&gt;mean = post[1:n_iter, &amp;quot;b_Intercept&amp;quot;] + post[1:n_iter, &amp;quot;r_condition[a,Intercept]&amp;quot;]&lt;/code&gt;. Within &lt;code&gt;geom_jitter()&lt;/code&gt;, we also isolated the &lt;code&gt;condition == &amp;quot;a&amp;quot;&lt;/code&gt; cases with &lt;code&gt;filter()&lt;/code&gt;. Simple. However, it’s more of a pickle if we want multiple densities stacked atop/next to one another within the same plot.&lt;/p&gt;
&lt;p&gt;Unfortunately, we can’t extend our &lt;code&gt;mapply(stat_function())&lt;/code&gt; method to the group-level estimates–at least not that I’m aware. But there are other ways. We’ll need a little help from &lt;code&gt;tidybayes::spread_draws()&lt;/code&gt;, about which you can learn more &lt;a href=&#34;https://mjskay.github.io/tidybayes/articles/tidy-brms.html&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidybayes)

sd &amp;lt;-
  fit2 %&amp;gt;% 
  spread_draws(b_Intercept, sigma, r_condition[condition,])
  
head(sd)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 7
## # Groups:   condition [5]
##   .chain .iteration .draw b_Intercept sigma condition r_condition
##    &amp;lt;int&amp;gt;      &amp;lt;int&amp;gt; &amp;lt;int&amp;gt;       &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;           &amp;lt;dbl&amp;gt;
## 1      1          1     1      0.0379 0.473 a            -0.0106 
## 2      1          1     1      0.0379 0.473 b             0.877  
## 3      1          1     1      0.0379 0.473 c             1.46   
## 4      1          1     1      0.0379 0.473 d             0.995  
## 5      1          1     1      0.0379 0.473 e            -1.11   
## 6      1          2     2      0.102  0.468 a             0.00219&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In our &lt;code&gt;sp&lt;/code&gt; &lt;a href=&#34;https://cran.r-project.org/web/packages/tibble/vignettes/tibble.html&#34;&gt;tibble&lt;/a&gt;, we have much of the same information we’d get from &lt;code&gt;brms::posterior_samples()&lt;/code&gt;, but in the long format with respect to the random effects for &lt;code&gt;condition&lt;/code&gt;. Also notice that each row is indexed by the chain, iteration, and draw number. Among those, &lt;code&gt;.draw&lt;/code&gt; is the column that corresponds to a unique row like what we’d get from &lt;code&gt;brms::posterior_samples()&lt;/code&gt;. This is the index that ranges from 1 to the number of chains multiplied by the number of post-warmup iterations (i.e., default 4000 in our case).&lt;/p&gt;
&lt;p&gt;But we need to wrangle a bit. Within the &lt;code&gt;expand()&lt;/code&gt; function, we’ll select the columns we’d like to keep within the &lt;code&gt;nesting()&lt;/code&gt; function and then expand the tibble by adding a sequence of &lt;code&gt;response&lt;/code&gt; values ranging from -4 to 4, for each. This sets us up to use the &lt;code&gt;dnorm()&lt;/code&gt; function in the next line to compute the density for each of those &lt;code&gt;response&lt;/code&gt; values based on 20 unique normal distributions for each of the five &lt;code&gt;condition&lt;/code&gt; groups. “Why 20?” Because we need some reasonably small number and 20’s the one Kruschke tended to use in his text and because, well, we set &lt;code&gt;filter(.draw &amp;lt; 21)&lt;/code&gt;. But choose whatever number you like.&lt;/p&gt;
&lt;p&gt;The difficulty, however, is that all of these densities will have a minimum value of around 0 and all will be on the same basic scale. So we need a way to serially shift the density values up the y-axis in such a way that they’ll be sensibly separated by group. As far as I can figure, this’ll take us a couple steps. For the first step, we’ll create an intermediary variable, &lt;code&gt;g&lt;/code&gt;, with which we’ll arbitrarily assign each of our five groups an integer index ranging from 0 to 4.&lt;/p&gt;
&lt;p&gt;The second step is tricky. There we use our &lt;code&gt;g&lt;/code&gt; integers to sequentially shift the density values up. Since our &lt;code&gt;g&lt;/code&gt; value for &lt;code&gt;a == 0&lt;/code&gt;, those we’ll keep 0 as their baseline. As our &lt;code&gt;g&lt;/code&gt; value for &lt;code&gt;b == 1&lt;/code&gt;, the baseline for those will now increase by 1. And so on for the other groups. But we still need to do a little more fiddling. What we want is for the maximum values of the density estimates to be a little lower than the baselines of the ones one grouping variable up. That is, we want the maximum values for the &lt;code&gt;a&lt;/code&gt; densities to fall a little bit below 1 on the y-axis. It’s with the &lt;code&gt;* .75 / max(density)&lt;/code&gt; part of the code that we accomplish that task. If you want to experiment with more or less room between the top and bottom of each density, play around with increasing/decreasing that .75 value.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sd &amp;lt;-
  sd %&amp;gt;% 
  filter(.draw &amp;lt; 21) %&amp;gt;% 
  expand(nesting(.draw, b_Intercept, sigma, condition, r_condition), 
         response = seq(from = -4, to = 4, length.out = 200)) %&amp;gt;%
  mutate(density = dnorm(response, mean = b_Intercept + r_condition, sd = sigma),
         g       = recode(condition,
                          a = 0,
                          b = 1,
                          c = 2,
                          d = 3,
                          e = 4)) %&amp;gt;% 
  mutate(density = g + density * .75 / max(density))

glimpse(sd)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Observations: 20,000
## Variables: 8
## Groups: condition [5]
## $ .draw       &amp;lt;int&amp;gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,…
## $ b_Intercept &amp;lt;dbl&amp;gt; 0.03787325, 0.03787325, 0.03787325, 0.03787325, 0.03787325, 0.03787325, 0.037…
## $ sigma       &amp;lt;dbl&amp;gt; 0.4734374, 0.4734374, 0.4734374, 0.4734374, 0.4734374, 0.4734374, 0.4734374, …
## $ condition   &amp;lt;chr&amp;gt; &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a…
## $ r_condition &amp;lt;dbl&amp;gt; -0.0106207, -0.0106207, -0.0106207, -0.0106207, -0.0106207, -0.0106207, -0.01…
## $ response    &amp;lt;dbl&amp;gt; -4.000000, -3.959799, -3.919598, -3.879397, -3.839196, -3.798995, -3.758794, …
## $ density     &amp;lt;dbl&amp;gt; 1.435677e-16, 2.945670e-16, 6.000399e-16, 1.213514e-15, 2.436566e-15, 4.85713…
## $ g           &amp;lt;dbl&amp;gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since we’ll now be using the same axis for both the densities and the five &lt;code&gt;condition&lt;/code&gt; groups, we’ll need to add a &lt;code&gt;density&lt;/code&gt; column to our &lt;code&gt;abc&lt;/code&gt; data.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;abc &amp;lt;-
  abc %&amp;gt;% 
  mutate(density = recode(condition,
                          a = 0,
                          b = 1,
                          c = 2,
                          d = 3,
                          e = 4))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Time to plot.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sd %&amp;gt;% 
  ggplot(aes(x = response, y = density)) +
  # here we make our density lines
  geom_line(aes(group = interaction(.draw, g)),
            alpha = 1/2, size = 1/3, color = &amp;quot;steelblue&amp;quot;) +
  # use the original data for the jittered points
  geom_jitter(data = abc,
              height = .05, shape = 1, alpha = 2/3) +
  scale_y_continuous(&amp;quot;condition&amp;quot;,
                     breaks = 0:4,
                     labels = letters[1:5])&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-12-20-make-rotated-gaussians-kruschke-style_files/figure-html/unnamed-chunk-14-1.png&#34; width=&#34;384&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Now we’re rolling. Let’s make a cosmetic adjustment. Recall that the full range of the normal distribution spans from &lt;span class=&#34;math inline&#34;&gt;\(-\infty\)&lt;/span&gt; to &lt;span class=&#34;math inline&#34;&gt;\(\infty\)&lt;/span&gt;. At a certain point, it’s just not informative to show the left and right tails. If you look back up at our motivating example, you’ll note Kruschke’s densities stopped well before trailing off into the tails. If you look closely to the code from his text, you’ll see he’s just showing the inner 95-percentile range for each. To follow suit, we can compute those ranges with &lt;code&gt;qnorm()&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sd &amp;lt;-
  sd %&amp;gt;% 
  mutate(ll = qnorm(.025, mean = b_Intercept + r_condition, sd = sigma),
         ul = qnorm(.975, mean = b_Intercept + r_condition, sd = sigma))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we have our lower- and upper-level points for each iteration, we can limit the ranges of our Gaussians with &lt;code&gt;filter()&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sd %&amp;gt;% 
  filter(response &amp;gt; ll,
         response &amp;lt; ul) %&amp;gt;% 
  
  ggplot(aes(x = response, y = density)) +
  geom_line(aes(group = interaction(.draw, g)),
            alpha = 1/2, size = 1/3, color = &amp;quot;steelblue&amp;quot;) +
  geom_jitter(data = abc,
              height = .05, shape = 1, alpha = 2/3) +
  scale_y_continuous(&amp;quot;condition&amp;quot;,
                     breaks = 0:4,
                     labels = letters[1:5])&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-12-20-make-rotated-gaussians-kruschke-style_files/figure-html/unnamed-chunk-16-1.png&#34; width=&#34;384&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Oh man, just look how sweet that is. Although I prefer our current method, another difference between it and Kruschke’s example is all of his densities are the same relative height. In all our plots so far, though, the densities differ by their heights. We’ll need a slight adjustment in our &lt;code&gt;sd&lt;/code&gt; workflow for that. All we need to do is insert a &lt;code&gt;group_by()&lt;/code&gt; statement between the two &lt;code&gt;mutate()&lt;/code&gt; lines.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sd &amp;lt;-
  sd %&amp;gt;% 
  mutate(density = dnorm(response, mean = b_Intercept + r_condition, sd = sigma),
         g       = recode(condition,
                          a = 0,
                          b = 1,
                          c = 2,
                          d = 3,
                          e = 4)) %&amp;gt;% 
  # here&amp;#39;s the new line
  group_by(.draw) %&amp;gt;% 
  mutate(density = g + density * .75 / max(density))

# now plot
sd %&amp;gt;% 
  filter(response &amp;gt; ll,
         response &amp;lt; ul) %&amp;gt;% 
  ggplot(aes(x = response, y = density)) +
  geom_line(aes(group = interaction(.draw, g)),
            alpha = 1/2, size = 1/3, color = &amp;quot;steelblue&amp;quot;) +
  geom_jitter(data = abc,
              height = .05, shape = 1, alpha = 2/3) +
  scale_y_continuous(&amp;quot;condition&amp;quot;,
                     breaks = 0:4,
                     labels = letters[1:5])&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-12-20-make-rotated-gaussians-kruschke-style_files/figure-html/unnamed-chunk-17-1.png&#34; width=&#34;384&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Nice. “But wait!”, you say. “We wanted our Gaussians to be on their sides.” We can do that in at least two ways. At this point, the quickest way is to use our &lt;code&gt;scale_y_reverse() + coord_flip()&lt;/code&gt; combo from before.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sd %&amp;gt;% 
  filter(response &amp;gt; ll,
         response &amp;lt; ul) %&amp;gt;% 
  
  ggplot(aes(x = response, y = density)) +
  geom_line(aes(group = interaction(.draw, g)),
            alpha = 1/2, size = 1/3, color = &amp;quot;steelblue&amp;quot;) +
  geom_jitter(data = abc,
              height = .05, shape = 1, alpha = 2/3) +
  scale_y_reverse(&amp;quot;condition&amp;quot;,
                  breaks = 0:4,
                  labels = letters[1:5]) +
  coord_flip()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-12-20-make-rotated-gaussians-kruschke-style_files/figure-html/unnamed-chunk-18-1.png&#34; width=&#34;384&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Another way to get those sideways Gaussians is to alter our &lt;code&gt;sd&lt;/code&gt; data workflow. The main differene is this time we change the original &lt;code&gt;mutate(density = g + density * .75 / max(density))&lt;/code&gt; line to &lt;code&gt;mutate(density = g - density * .75 / max(density))&lt;/code&gt;. In case you missed it, the only difference is we changed the &lt;code&gt;+&lt;/code&gt; to a &lt;code&gt;-&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sd &amp;lt;-
  sd %&amp;gt;% 
  # step one: starting fresh
  mutate(density = dnorm(response, mean = b_Intercept + r_condition, sd = sigma)) %&amp;gt;% 
  group_by(.draw) %&amp;gt;% 
  # step two: now SUBTRACTING density from g within the equation
  mutate(density = g - density * .75 / max(density))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now in our global &lt;code&gt;aes()&lt;/code&gt; statement in the plot, we put &lt;code&gt;density&lt;/code&gt; on the x and &lt;code&gt;response&lt;/code&gt; on the y. We need to take a few other subtle steps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Switch out &lt;code&gt;geom_line()&lt;/code&gt; for &lt;code&gt;geom_path()&lt;/code&gt; (see &lt;a href=&#34;https://ggplot2.tidyverse.org/reference/geom_path.html&#34;&gt;here&lt;/a&gt;).&lt;/li&gt;
&lt;li&gt;Drop the &lt;code&gt;height&lt;/code&gt; argument within &lt;code&gt;geom_jitter()&lt;/code&gt; for &lt;code&gt;width&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Switch out &lt;code&gt;scale_y_continuous()&lt;/code&gt; for &lt;code&gt;scale_x_continuous()&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Though totally not necessary, we’ll add a little something extra by coloring the Gaussians by their means.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sd %&amp;gt;% 
  filter(response &amp;gt; ll,
         response &amp;lt; ul) %&amp;gt;% 
  
  ggplot(aes(x = density, y = response)) +
  geom_path(aes(group = interaction(.draw, g), 
                color = b_Intercept + r_condition),
            alpha = 1/2, size = 1/3, show.legend = F) +
  geom_jitter(data = abc,
              width = .05, shape = 1, alpha = 2/3) +
  scale_x_continuous(&amp;quot;condition&amp;quot;,
                     breaks = 0:4,
                     labels = letters[1:5]) +
  scale_color_viridis_c(option = &amp;quot;A&amp;quot;, end = .92)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-12-20-make-rotated-gaussians-kruschke-style_files/figure-html/unnamed-chunk-20-1.png&#34; width=&#34;384&#34; /&gt;&lt;/p&gt;
&lt;p&gt;There you have it–Kruschke-style sideways Gaussians for your model plots.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;afterward&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Afterward&lt;/h2&gt;
&lt;p&gt;After releasing the initial version of this post, some of us had a lively twitter discussion on how to improve the code.&lt;/p&gt;
&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;Ah, hrm. Took some digging, but it looks like negative density + setting `min_height = NA` (otherwise negative values are cut off) might work &lt;a href=&#34;https://t.co/gmF9kpo2T7&#34;&gt;pic.twitter.com/gmF9kpo2T7&lt;/a&gt;&lt;/p&gt;&amp;mdash; Matthew Kay (@mjskay) &lt;a href=&#34;https://twitter.com/mjskay/status/1076395687020056576?ref_src=twsrc%5Etfw&#34;&gt;December 22, 2018&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;

&lt;p&gt;Part of that discussion had to do with the possibility of using functions from &lt;a href=&#34;https://twitter.com/ClausWilke/&#34;&gt;Claus Wilke&lt;/a&gt;’s great &lt;a href=&#34;https://github.com/clauswilke/ggridges&#34;&gt;ggridges package&lt;/a&gt;. After some great efforts, especially from &lt;a href=&#34;https://twitter.com/mjskay/&#34;&gt;Matthew Kay&lt;/a&gt;, we came up with solutions. In this section, we’ll cover them in some detail.&lt;/p&gt;
&lt;p&gt;First, here’s a more compact way to prepare the data for the plot.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;abc %&amp;gt;%
  distinct(condition) %&amp;gt;%
  add_fitted_draws(fit2, n = 20, dpar = c(&amp;quot;mu&amp;quot;, &amp;quot;sigma&amp;quot;)) %&amp;gt;% 
  mutate(lower    = qnorm(.025, mean = mu, sd = sigma),
         upper    = qnorm(.975, mean = mu, sd = sigma)) %&amp;gt;% 
  mutate(response = map2(lower, upper, seq, length.out = 200)) %&amp;gt;% 
  mutate(density  = pmap(list(response, mu, sigma), dnorm)) %&amp;gt;% 
  unnest() %&amp;gt;% 
  group_by(.draw) %&amp;gt;% 
  mutate(density  = density * .75 / max(density)) %&amp;gt;% 
  
  glimpse()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: `cols` is now required.
## Please use `cols = c(response, density)`&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Observations: 20,000
## Variables: 12
## Groups: .draw [20]
## $ condition  &amp;lt;chr&amp;gt; &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;…
## $ .row       &amp;lt;int&amp;gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, …
## $ .chain     &amp;lt;int&amp;gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…
## $ .iteration &amp;lt;int&amp;gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…
## $ .draw      &amp;lt;int&amp;gt; 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24…
## $ .value     &amp;lt;dbl&amp;gt; 0.2041854, 0.2041854, 0.2041854, 0.2041854, 0.2041854, 0.2041854, 0.2041854, 0…
## $ mu         &amp;lt;dbl&amp;gt; 0.2041854, 0.2041854, 0.2041854, 0.2041854, 0.2041854, 0.2041854, 0.2041854, 0…
## $ sigma      &amp;lt;dbl&amp;gt; 0.5729852, 0.5729852, 0.5729852, 0.5729852, 0.5729852, 0.5729852, 0.5729852, 0…
## $ lower      &amp;lt;dbl&amp;gt; -0.918845, -0.918845, -0.918845, -0.918845, -0.918845, -0.918845, -0.918845, -…
## $ upper      &amp;lt;dbl&amp;gt; 1.327216, 1.327216, 1.327216, 1.327216, 1.327216, 1.327216, 1.327216, 1.327216…
## $ response   &amp;lt;dbl&amp;gt; -0.9188450, -0.9075582, -0.8962715, -0.8849847, -0.8736980, -0.8624113, -0.851…
## $ density    &amp;lt;dbl&amp;gt; 0.1098804, 0.1141834, 0.1186089, 0.1231581, 0.1278322, 0.1326322, 0.1375591, 0…&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This could use some walking out. With the first two lines, we made a &lt;span class=&#34;math inline&#34;&gt;\(5 \times 1\)&lt;/span&gt; tibble containing the five levels of &lt;code&gt;condition&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; through &lt;code&gt;f&lt;/code&gt;. The &lt;code&gt;add_fitted_draws()&lt;/code&gt; function comes from tidybayes. The first argument took our brms model fit, &lt;code&gt;fit2&lt;/code&gt;. With the &lt;code&gt;n&lt;/code&gt; argument, we indicated we just wanted &lt;code&gt;20&lt;/code&gt; draws. With &lt;code&gt;dpar&lt;/code&gt;, we requested distributional regression parameters in the output. In our case, those were the &lt;span class=&#34;math inline&#34;&gt;\(\mu\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(\sigma\)&lt;/span&gt; values for each level of &lt;code&gt;condition&lt;/code&gt;. Here’s what that looks like.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;abc %&amp;gt;%
  distinct(condition) %&amp;gt;%
  add_fitted_draws(fit2, n = 20, dpar = c(&amp;quot;mu&amp;quot;, &amp;quot;sigma&amp;quot;)) %&amp;gt;% 
  
  head()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 8
## # Groups:   condition, .row [1]
##   condition  .row .chain .iteration .draw .value    mu sigma
##   &amp;lt;chr&amp;gt;     &amp;lt;int&amp;gt;  &amp;lt;int&amp;gt;      &amp;lt;int&amp;gt; &amp;lt;int&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
## 1 a             1     NA         NA    55  0.163 0.163 0.458
## 2 a             1     NA         NA   126  0.509 0.509 0.513
## 3 a             1     NA         NA   404  0.472 0.472 0.717
## 4 a             1     NA         NA   813  0.387 0.387 0.537
## 5 a             1     NA         NA  1111  0.154 0.154 0.515
## 6 a             1     NA         NA  1218  0.204 0.204 0.495&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next, we established the lower- and upper-bounds bounds for the density lines, which were 95% intervals in this example. Within the second &lt;code&gt;mutate()&lt;/code&gt; function, we used the &lt;a href=&#34;https://purrr.tidyverse.org/reference/map2.html&#34;&gt;&lt;code&gt;purrr::map2()&lt;/code&gt;&lt;/a&gt; function to feed those two values into the first two arguments of the &lt;code&gt;seq()&lt;/code&gt; function. Those arguments, recall, are &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt;. We then hard coded &lt;code&gt;200&lt;/code&gt; into the &lt;code&gt;length.out&lt;/code&gt; argument. As a result, we turned our regular old tibble into a &lt;a href=&#34;https://tidyr.tidyverse.org/reference/nest.html&#34;&gt;nested tibble&lt;/a&gt;. In each row of our new &lt;code&gt;response&lt;/code&gt; column, we now have a &lt;span class=&#34;math inline&#34;&gt;\(200 \times 1\)&lt;/span&gt; data frame containing the &lt;code&gt;seq()&lt;/code&gt; output. If you’re new to nested data structures, I recommend checking out Hadley Wickham’s &lt;a href=&#34;https://www.youtube.com/watch?v=rz3_FDVt9eg&#34;&gt;&lt;em&gt;Managing many models with R&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;abc %&amp;gt;%
  distinct(condition) %&amp;gt;%
  add_fitted_draws(fit2, n = 20, dpar = c(&amp;quot;mu&amp;quot;, &amp;quot;sigma&amp;quot;)) %&amp;gt;% 
  mutate(lower    = qnorm(.025, mean = mu, sd = sigma),
         upper    = qnorm(.975, mean = mu, sd = sigma)) %&amp;gt;% 
  mutate(response = map2(lower, upper, seq, length.out = 200)) %&amp;gt;% 
  
  head()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 11
## # Groups:   condition, .row [1]
##   condition  .row .chain .iteration .draw .value     mu sigma  lower upper response   
##   &amp;lt;chr&amp;gt;     &amp;lt;int&amp;gt;  &amp;lt;int&amp;gt;      &amp;lt;int&amp;gt; &amp;lt;int&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;list&amp;gt;     
## 1 a             1     NA         NA   346 0.278  0.278  0.521 -0.743  1.30 &amp;lt;dbl [200]&amp;gt;
## 2 a             1     NA         NA   696 0.193  0.193  0.498 -0.783  1.17 &amp;lt;dbl [200]&amp;gt;
## 3 a             1     NA         NA   734 0.320  0.320  0.709 -1.07   1.71 &amp;lt;dbl [200]&amp;gt;
## 4 a             1     NA         NA  1214 0.0686 0.0686 0.559 -1.03   1.16 &amp;lt;dbl [200]&amp;gt;
## 5 a             1     NA         NA  1313 0.229  0.229  0.539 -0.828  1.29 &amp;lt;dbl [200]&amp;gt;
## 6 a             1     NA         NA  1348 0.329  0.329  0.589 -0.826  1.48 &amp;lt;dbl [200]&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Much as the &lt;code&gt;purrr::map2()&lt;/code&gt; function allowed us to iterate over two arguments, the &lt;code&gt;purrr::pmap()&lt;/code&gt; function will allow us to iterate over an arbitrary number of arguments. In the case of our third &lt;code&gt;mutate()&lt;/code&gt; function, we’ll iterate over the first three arguments of the &lt;code&gt;dnorm()&lt;/code&gt; function. In case you forgot, those arguments are &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;mean&lt;/code&gt;, and &lt;code&gt;sd&lt;/code&gt;, respectively. Within our &lt;code&gt;list()&lt;/code&gt;, we indicated we wanted to insert into them the &lt;code&gt;response&lt;/code&gt;, &lt;code&gt;mu&lt;/code&gt;, and &lt;code&gt;sigma&lt;/code&gt; values. This returns the desired &lt;code&gt;density&lt;/code&gt; values. Since our &lt;code&gt;map2()&lt;/code&gt; and &lt;code&gt;pmap()&lt;/code&gt; operations returned a nested tibble, we then followed them up with the &lt;code&gt;unnest()&lt;/code&gt; function to make it easier to access the results.&lt;/p&gt;
&lt;p&gt;Before &lt;code&gt;unnest&lt;/code&gt;ing, our nested tibble had 100 observations. After &lt;code&gt;unnest()&lt;/code&gt;, we converted it to the long format, resulting in &lt;span class=&#34;math inline&#34;&gt;\(100 \times 200 = 20,000\)&lt;/span&gt; observations.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;abc %&amp;gt;%
  distinct(condition) %&amp;gt;%
  add_fitted_draws(fit2, n = 20, dpar = c(&amp;quot;mu&amp;quot;, &amp;quot;sigma&amp;quot;)) %&amp;gt;% 
  mutate(lower    = qnorm(.025, mean = mu, sd = sigma),
         upper    = qnorm(.975, mean = mu, sd = sigma)) %&amp;gt;% 
  mutate(response = map2(lower, upper, seq, length.out = 200)) %&amp;gt;% 
  mutate(density  = pmap(list(response, mu, sigma), dnorm)) %&amp;gt;% 
  unnest() %&amp;gt;% 
  
  glimpse()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: `cols` is now required.
## Please use `cols = c(response, density)`&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Observations: 20,000
## Variables: 12
## Groups: condition, .row [5]
## $ condition  &amp;lt;chr&amp;gt; &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;…
## $ .row       &amp;lt;int&amp;gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, …
## $ .chain     &amp;lt;int&amp;gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…
## $ .iteration &amp;lt;int&amp;gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…
## $ .draw      &amp;lt;int&amp;gt; 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79…
## $ .value     &amp;lt;dbl&amp;gt; -0.05142892, -0.05142892, -0.05142892, -0.05142892, -0.05142892, -0.05142892, …
## $ mu         &amp;lt;dbl&amp;gt; -0.05142892, -0.05142892, -0.05142892, -0.05142892, -0.05142892, -0.05142892, …
## $ sigma      &amp;lt;dbl&amp;gt; 0.5490717, 0.5490717, 0.5490717, 0.5490717, 0.5490717, 0.5490717, 0.5490717, 0…
## $ lower      &amp;lt;dbl&amp;gt; -1.12759, -1.12759, -1.12759, -1.12759, -1.12759, -1.12759, -1.12759, -1.12759…
## $ upper      &amp;lt;dbl&amp;gt; 1.024732, 1.024732, 1.024732, 1.024732, 1.024732, 1.024732, 1.024732, 1.024732…
## $ response   &amp;lt;dbl&amp;gt; -1.1275896, -1.1167739, -1.1059582, -1.0951425, -1.0843269, -1.0735112, -1.062…
## $ density    &amp;lt;dbl&amp;gt; 0.1064434, 0.1106119, 0.1148989, 0.1193059, 0.1238338, 0.1284836, 0.1332564, 0…&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Hopefully, our last two lines look familiar. We &lt;code&gt;group_by(.draw)&lt;/code&gt; just like in previous examples. However, our final &lt;code&gt;mutate()&lt;/code&gt; line is a little simpler than in previous versions. Before we had to make that intermediary variable, &lt;code&gt;g&lt;/code&gt;. Because we intend to plot these data with help from ggridges, we no longer have need for &lt;code&gt;g&lt;/code&gt;. You’ll see. But the upshot is the only reason we’re adding this last &lt;code&gt;mutate()&lt;/code&gt; line is to scale all the Gaussians to have the same maximum height the way Kruschke did.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;afd &amp;lt;-
  abc %&amp;gt;%
  distinct(condition) %&amp;gt;%
  add_fitted_draws(fit2, n = 20, dpar = c(&amp;quot;mu&amp;quot;, &amp;quot;sigma&amp;quot;)) %&amp;gt;% 
  mutate(lower    = qnorm(.025, mean = mu, sd = sigma),
         upper    = qnorm(.975, mean = mu, sd = sigma)) %&amp;gt;% 
  mutate(response = map2(lower, upper, seq, length.out = 200)) %&amp;gt;% 
  mutate(density  = pmap(list(response, mu, sigma), dnorm)) %&amp;gt;% 
  unnest() %&amp;gt;% 
  group_by(.draw) %&amp;gt;% 
  mutate(density  = density * .75 / max(density))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: `cols` is now required.
## Please use `cols = c(response, density)`&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;glimpse(afd)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Observations: 20,000
## Variables: 12
## Groups: .draw [20]
## $ condition  &amp;lt;chr&amp;gt; &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;…
## $ .row       &amp;lt;int&amp;gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, …
## $ .chain     &amp;lt;int&amp;gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…
## $ .iteration &amp;lt;int&amp;gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…
## $ .draw      &amp;lt;int&amp;gt; 292, 292, 292, 292, 292, 292, 292, 292, 292, 292, 292, 292, 292, 292, 292, 292…
## $ .value     &amp;lt;dbl&amp;gt; -0.302783, -0.302783, -0.302783, -0.302783, -0.302783, -0.302783, -0.302783, -…
## $ mu         &amp;lt;dbl&amp;gt; -0.302783, -0.302783, -0.302783, -0.302783, -0.302783, -0.302783, -0.302783, -…
## $ sigma      &amp;lt;dbl&amp;gt; 0.5187913, 0.5187913, 0.5187913, 0.5187913, 0.5187913, 0.5187913, 0.5187913, 0…
## $ lower      &amp;lt;dbl&amp;gt; -1.319595, -1.319595, -1.319595, -1.319595, -1.319595, -1.319595, -1.319595, -…
## $ upper      &amp;lt;dbl&amp;gt; 0.7140294, 0.7140294, 0.7140294, 0.7140294, 0.7140294, 0.7140294, 0.7140294, 0…
## $ response   &amp;lt;dbl&amp;gt; -1.3195953, -1.3093761, -1.2991569, -1.2889377, -1.2787185, -1.2684993, -1.258…
## $ density    &amp;lt;dbl&amp;gt; 0.1098804, 0.1141834, 0.1186089, 0.1231581, 0.1278322, 0.1326322, 0.1375591, 0…&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let’s open &lt;a href=&#34;https://github.com/clauswilke/ggridges&#34;&gt;ggridges&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(ggridges)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note how contrary to before, we set the global y axis to our &lt;code&gt;condition&lt;/code&gt; grouping variable. It’s within the &lt;code&gt;geom_ridgeline()&lt;/code&gt; function that we now specify &lt;code&gt;height = density&lt;/code&gt;. Other than that, the main thing to point out is you might want to adjust the &lt;code&gt;ylim&lt;/code&gt; parameters. Otherwise the margins aren’t the best.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;afd %&amp;gt;%
  
  ggplot(aes(x = response, y = condition)) +
  geom_ridgeline(aes(height = density, group = interaction(condition, .draw)),
                 fill = NA, size = 1/3, color = adjustcolor(&amp;quot;steelblue&amp;quot;, alpha.f = 1/2)) +
  geom_jitter(data = abc,
              height = .05, shape = 1, alpha = 2/3) +
  coord_cartesian(ylim = c(1.25, 5.5))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-12-20-make-rotated-gaussians-kruschke-style_files/figure-html/unnamed-chunk-28-1.png&#34; width=&#34;384&#34; /&gt;&lt;/p&gt;
&lt;p&gt;“But I wanted my Gaussians tipped to the left!”, you say. Yep, we can do that, too. Three things: First, we’ll want to adjust the &lt;code&gt;height&lt;/code&gt; parameter to &lt;code&gt;-density&lt;/code&gt;. We want our Gaussians to extend under their baselines. Along with that, we need to include &lt;code&gt;min_height = NA&lt;/code&gt;. Finally, we’ll switch out &lt;code&gt;coord_cartesian()&lt;/code&gt; for good old &lt;code&gt;coord_flip()&lt;/code&gt;. And you can adjust your &lt;code&gt;ylim&lt;/code&gt; parameters as desired.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;afd %&amp;gt;%
  
  ggplot(aes(x = response, y = condition)) +
  geom_ridgeline(aes(height = -density, group = interaction(condition, .draw)),
                 fill = NA, size = 1/3, color = adjustcolor(&amp;quot;steelblue&amp;quot;, alpha.f = 1/2),
                 min_height = NA) +
  geom_jitter(data = abc,
              height = .05, shape = 1, alpha = 2/3) +
  coord_flip(ylim = c(0.5, 4.75))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-12-20-make-rotated-gaussians-kruschke-style_files/figure-html/unnamed-chunk-29-1.png&#34; width=&#34;384&#34; /&gt;&lt;/p&gt;
&lt;p&gt;I think it’s important to note that I’ve never met any of the people who helped me with this project. Academic twitter, man–it’s a good place to be.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;session-info&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Session info&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sessionInfo()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## R version 3.6.0 (2019-04-26)
## Platform: x86_64-apple-darwin15.6.0 (64-bit)
## Running under: macOS High Sierra 10.13.6
## 
## Matrix products: default
## BLAS:   /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRblas.0.dylib
## LAPACK: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRlapack.dylib
## 
## Random number generation:
##  RNG:     Mersenne-Twister 
##  Normal:  Inversion 
##  Sample:  Rounding 
##  
## locale:
## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
##  [1] ggridges_0.5.1  tidybayes_1.1.0 brms_2.10.0     Rcpp_1.0.2      forcats_0.4.0   stringr_1.4.0  
##  [7] dplyr_0.8.3     purrr_0.3.2     readr_1.3.1     tidyr_1.0.0     tibble_2.1.3    ggplot2_3.2.1  
## [13] tidyverse_1.2.1
## 
## loaded via a namespace (and not attached):
##   [1] colorspace_1.4-1          ellipsis_0.2.0.1          rsconnect_0.8.13         
##   [4] ggstance_0.3.2            markdown_1.0              base64enc_0.1-3          
##   [7] rstudioapi_0.10           rstan_2.19.2              svUnit_0.7-12            
##  [10] DT_0.7                    fansi_0.4.0               mvtnorm_1.0-11           
##  [13] lubridate_1.7.4           xml2_1.2.0                bridgesampling_0.6-0     
##  [16] knitr_1.23                shinythemes_1.1.2         zeallot_0.1.0            
##  [19] bayesplot_1.7.0           jsonlite_1.6              broom_0.5.2              
##  [22] shiny_1.3.2               compiler_3.6.0            httr_1.4.0               
##  [25] backports_1.1.4           assertthat_0.2.1          Matrix_1.2-17            
##  [28] lazyeval_0.2.2            cli_1.1.0                 later_0.8.0              
##  [31] htmltools_0.3.6           prettyunits_1.0.2         tools_3.6.0              
##  [34] igraph_1.2.4.1            coda_0.19-2               gtable_0.3.0             
##  [37] glue_1.3.1                reshape2_1.4.3            cellranger_1.1.0         
##  [40] vctrs_0.2.0               nlme_3.1-139              blogdown_0.14            
##  [43] crosstalk_1.0.0           xfun_0.8                  ps_1.3.0                 
##  [46] rvest_0.3.4               mime_0.7                  miniUI_0.1.1.1           
##  [49] lifecycle_0.1.0           gtools_3.8.1              zoo_1.8-6                
##  [52] scales_1.0.0              colourpicker_1.0          hms_0.4.2                
##  [55] promises_1.0.1            Brobdingnag_1.2-6         parallel_3.6.0           
##  [58] inline_0.3.15             shinystan_2.5.0           yaml_2.2.0               
##  [61] gridExtra_2.3             loo_2.1.0                 StanHeaders_2.18.1-10    
##  [64] stringi_1.4.3             dygraphs_1.1.1.6          pkgbuild_1.0.3           
##  [67] rlang_0.4.0               pkgconfig_2.0.2           matrixStats_0.54.0       
##  [70] evaluate_0.14             lattice_0.20-38           rstantools_1.5.1         
##  [73] htmlwidgets_1.3           labeling_0.3              tidyselect_0.2.5         
##  [76] processx_3.3.1            plyr_1.8.4                magrittr_1.5             
##  [79] bookdown_0.12             R6_2.4.0                  generics_0.0.2           
##  [82] pillar_1.4.2              haven_2.1.0               withr_2.1.2              
##  [85] xts_0.11-2                abind_1.4-5               modelr_0.1.4             
##  [88] crayon_1.3.4              arrayhelpers_1.0-20160527 utf8_1.1.4               
##  [91] rmarkdown_1.13            grid_3.6.0                readxl_1.3.1             
##  [94] callr_3.2.0               threejs_0.3.1             digest_0.6.20            
##  [97] xtable_1.8-4              httpuv_1.5.1              stats4_3.6.0             
## [100] munsell_0.5.0             viridisLite_0.3.0         shinyjs_1.0&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Bayesian meta-analysis in brms</title>
      <link>/post/bayesian-meta-analysis/</link>
      <pubDate>Sun, 14 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/bayesian-meta-analysis/</guid>
      <description>&lt;p&gt;[edited Feb 27, 2019]&lt;/p&gt;
&lt;div id=&#34;preamble&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Preamble&lt;/h2&gt;
&lt;p&gt;I released the first &lt;a href=&#34;https://bookdown.org&#34;&gt;bookdown&lt;/a&gt; version of my &lt;a href=&#34;https://bookdown.org/connect/#/apps/1850/access&#34;&gt;&lt;em&gt;Statistical Rethinking&lt;/em&gt; with brms, ggplot2, and the tidyverse&lt;/a&gt; project a couple weeks ago. I consider it the 0.9.0 version. I wanted a little time to step back from the project before giving it a final edit for the first major edition. I also wanted to give others a little time to take a look and suggest edits, which some thankfully have.&lt;/p&gt;
&lt;p&gt;Now some time has passed, it’s become clear I’d like to add a bonus section on Bayesian meta-analysis. IMO, this is a natural extension of the hierarchical models McElreath introduced in chapter’s 12 and 13 of &lt;a href=&#34;https://xcelab.net/rm/statistical-rethinking/&#34;&gt;his text&lt;/a&gt; and of the measurement-error models he introduced in chapter 14. So the purpose of this post is to present a rough draft of how I’d like to introduce fitting meta-analyses with Bürkner’s great brms package.&lt;/p&gt;
&lt;p&gt;I intend to tack this section onto the end of chapter 14. If you have any &lt;a href=&#34;https://github.com/ASKurz/Statistical_Rethinking_with_brms_ggplot2_and_the_tidyverse/issues&#34;&gt;constrictive criticisms, please pass them along&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Here’s the rough draft (which I updated on 2018-11-12):&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;rough-draft-meta-analysis&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Rough draft: Meta-analysis&lt;/h2&gt;
&lt;p&gt;If your mind isn’t fully blown by those measurement-error and missing-data models, let’s keep building. As it turns out, meta-analyses are often just special kinds of multilevel measurement-error models. Thus, you can use &lt;code&gt;brms::brm()&lt;/code&gt; to fit Bayesian meta-analyses, too.&lt;/p&gt;
&lt;p&gt;Before we proceed, I should acknowledge that this section is heavily influenced by Matti Vourre’s great blog post, &lt;a href=&#34;https://vuorre.netlify.com/post/2016/2016-09-29-bayesian-meta-analysis/&#34;&gt;&lt;em&gt;Meta-analysis is a special case of Bayesian multilevel modeling&lt;/em&gt;&lt;/a&gt;. And since McElreath’s text doesn’t directly address meta-analyses, we’ll take further inspiration from Gelman, Carlin, Stern, Dunson, Vehtari, and Rubin’s &lt;a href=&#34;http://www.stat.columbia.edu/~gelman/book/&#34;&gt;&lt;em&gt;Bayesian data analysis, Third edition&lt;/em&gt;&lt;/a&gt;. We’ll let Gelman and colleagues introduce the topic:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Discussions of meta-analysis are sometimes imprecise about the estimands of interest in the analysis, especially when the primary focus is on testing the null hypothesis of no effect in any of the studies to be combined. Our focus is on estimating meaningful parameters, and for this objective there appear to be three possibilities, accepting the overarching assumption that the studies are comparable in some broad sense. The first possibility is that we view the studies as identical replications of each other, in the sense we regard the individuals in all the studies as independent samples from a common population, with the same outcome measures and so on. A second possibility is that the studies are so different that the results of any one study provide no information about the results of any of the others. A third, more general, possibility is that we regard the studies as exchangeable but not necessarily either identical or completely unrelated; in other words we allow differences from study to study, but such that the differences are not expected &lt;em&gt;a priori&lt;/em&gt; to have predictable effects favoring one study over another.… This third possibility represents a continuum between the two extremes, and it is this exchangeable model (with unknown hyperparameters characterizing the population distribution) that forms the basis of our Bayesian analysis…&lt;/p&gt;
&lt;p&gt;The first potential estimand of a meta-analysis, or a hierarchically structured problem in general, is the mean of the distribution of effect sizes, since this represents the overall ‘average’ effect across all studies that could be regarded as exchangeable with the observed studies. Other possible estimands are the effect size in any of the observed studies and the effect size in another, comparable (exchangeable) unobserved study. (pp. 125—126, &lt;em&gt;emphasis&lt;/em&gt; in the original)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The basic version of a Bayesian meta-analysis follows the form&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[y_i \sim \text{Normal}(\theta_i, \sigma_i)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;where &lt;span class=&#34;math inline&#34;&gt;\(y_i\)&lt;/span&gt; = the point estimate for the effect size of a single study, &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;, which is presumed to have been a draw from a Normal distribution centered on &lt;span class=&#34;math inline&#34;&gt;\(\theta_i\)&lt;/span&gt;. The data in meta-analyses are typically statistical summaries from individual studies. The one clear lesson from this chapter is that those estimates themselves come with error and those errors should be fully expressed in the meta-analytic model. Which we do. The standard error from study &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; is specified &lt;span class=&#34;math inline&#34;&gt;\(\sigma_i\)&lt;/span&gt;, which is also a stand-in for the standard deviation of the Normal distribution from which the point estimate was drawn. Do note, we’re not estimating &lt;span class=&#34;math inline&#34;&gt;\(\sigma_i\)&lt;/span&gt;, here. Those values we take directly from the original studies.&lt;/p&gt;
&lt;p&gt;Building on the model, we further presume that study &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; is itself just one draw from a population of related studies, each of which have their own effect sizes. As such. we presume &lt;span class=&#34;math inline&#34;&gt;\(\theta_i\)&lt;/span&gt; itself has a distribution following the form&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\theta_i \sim \text{Normal} (\mu, \tau)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;where &lt;span class=&#34;math inline&#34;&gt;\(\mu\)&lt;/span&gt; is the meta-analytic effect (i.e., the population mean) and &lt;span class=&#34;math inline&#34;&gt;\(\tau\)&lt;/span&gt; is the variation around that mean, what you might also think of as &lt;span class=&#34;math inline&#34;&gt;\(\sigma_\tau\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Since there’s no example of a meta-analysis in the text, we’ll have to look elsewhere. We’ll focus on Gershoff and Grogan-Kaylor’s (2016) paper, &lt;a href=&#34;https://pdfs.semanticscholar.org/0d03/a2e9f085f0a268b4c0a52f5ac31c17a3e5f3.pdf&#34;&gt;&lt;em&gt;Spanking and Child Outcomes: Old Controversies and New Meta-Analyses&lt;/em&gt;&lt;/a&gt;. From their introduction, we read:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Around the world, most children (80%) are spanked or otherwise physically punished by their parents (&lt;a href=&#34;https://www.unicef.org/publications/index_74865.html&#34;&gt;UNICEF, 2014&lt;/a&gt;). The question of whether parents should spank their children to correct misbehaviors sits at a nexus of arguments from ethical, religious, and human rights perspectives both in the U.S. and around the world (&lt;a href=&#34;https://onlinelibrary.wiley.com/doi/abs/10.1111/cdep.12038&#34;&gt;Gershoff, 2013&lt;/a&gt;). Several hundred studies have been conducted on the associations between parents’ use of spanking or physical punishment and children’s behavioral, emotional, cognitive, and physical outcomes, making spanking one of the most studied aspects of parenting. What has been learned from these hundreds of studies? (p. 453)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Our goal will be to learn Bayesian meta-analysis by answering part of that question. I’ve transcribed the values directly from Gershoff and Grogan-Kaylor’s paper and saved them as a file called &lt;code&gt;spank.xlsx&lt;/code&gt;.
You can find the data in &lt;a href=&#34;https://github.com/ASKurz/Statistical_Rethinking_with_brms_ggplot2_and_the_tidyverse&#34;&gt;this project’s GitHub repository&lt;/a&gt;. Let’s load them and &lt;code&gt;glimpse()&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;spank &amp;lt;- readxl::read_excel(&amp;quot;spank.xlsx&amp;quot;)

library(tidyverse)
glimpse(spank)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Observations: 111
## Variables: 8
## $ study   &amp;lt;chr&amp;gt; &amp;quot;Bean and Roberts (1981)&amp;quot;, &amp;quot;Day and Roberts (1983)&amp;quot;, &amp;quot;Mi…
## $ year    &amp;lt;dbl&amp;gt; 1981, 1983, 1971, 1988, 1990, 1961, 1962, 1990, 2002, 20…
## $ outcome &amp;lt;chr&amp;gt; &amp;quot;Immediate defiance&amp;quot;, &amp;quot;Immediate defiance&amp;quot;, &amp;quot;Immediate d…
## $ between &amp;lt;dbl&amp;gt; 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0,…
## $ within  &amp;lt;dbl&amp;gt; 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1,…
## $ d       &amp;lt;dbl&amp;gt; -0.74, 0.36, 0.34, -0.08, 0.10, 0.63, 0.19, 0.47, 0.14, …
## $ ll      &amp;lt;dbl&amp;gt; -1.76, -1.04, -0.09, -1.01, -0.82, 0.16, -0.14, 0.20, -0…
## $ ul      &amp;lt;dbl&amp;gt; 0.28, 1.77, 0.76, 0.84, 1.03, 1.10, 0.53, 0.74, 0.70, 0.…&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this paper, the effect size of interest is a &lt;em&gt;Cohen’s d&lt;/em&gt;, derived from the formula&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[d = \frac{\mu_\text{treatment} - \mu_\text{comparison}}{\sigma_{pooled}}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;where&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\sigma_{pooled} = \sqrt{\frac{((n_1 - 1) \sigma_1^2) + ((n_2 - 1) \sigma_2^2)}{n_1 + n_2 -2}}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;To help make the equation for &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt; clearer for our example, we might re-express it as&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[d = \frac{\mu_\text{spanked} - \mu_\text{not spanked}}{\sigma_{pooled}}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;McElreath didn’t really focus on effect sizes in his text. If you need a refresher, you might check out Kelley and Preacher’s &lt;a href=&#34;https://www.researchgate.net/profile/Ken_Kelley/publication/270757972_On_Effect_Size/links/0046351b0cd48217ce000000/On-Effect-Size.pdf&#34;&gt;&lt;em&gt;On effect size&lt;/em&gt;&lt;/a&gt;. But in words, &lt;em&gt;Cohen’s d&lt;/em&gt; is a standardized mean difference between two groups.&lt;/p&gt;
&lt;p&gt;So if you look back up at the results of &lt;code&gt;glimpse(spank)&lt;/code&gt;, you’ll notice the column &lt;code&gt;d&lt;/code&gt;, which is indeed a vector of &lt;em&gt;Cohen’s d&lt;/em&gt; effect sizes. The last two columns, &lt;code&gt;ll&lt;/code&gt; and &lt;code&gt;ul&lt;/code&gt; are the lower and upper limits of the associated 95% frequentist confidence intervals. But we don’t want confidence intervals for our &lt;code&gt;d&lt;/code&gt;-values; we want their standard errors. Fortunately, we can compute those with the following formula&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[SE = \frac{\text{upper limit } – \text{lower limit}}{3.92}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Here it is in code.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;spank &amp;lt;-
  spank %&amp;gt;% 
  mutate(se = (ul - ll) / 3.92)

glimpse(spank)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Observations: 111
## Variables: 9
## $ study   &amp;lt;chr&amp;gt; &amp;quot;Bean and Roberts (1981)&amp;quot;, &amp;quot;Day and Roberts (1983)&amp;quot;, &amp;quot;Mi…
## $ year    &amp;lt;dbl&amp;gt; 1981, 1983, 1971, 1988, 1990, 1961, 1962, 1990, 2002, 20…
## $ outcome &amp;lt;chr&amp;gt; &amp;quot;Immediate defiance&amp;quot;, &amp;quot;Immediate defiance&amp;quot;, &amp;quot;Immediate d…
## $ between &amp;lt;dbl&amp;gt; 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0,…
## $ within  &amp;lt;dbl&amp;gt; 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1,…
## $ d       &amp;lt;dbl&amp;gt; -0.74, 0.36, 0.34, -0.08, 0.10, 0.63, 0.19, 0.47, 0.14, …
## $ ll      &amp;lt;dbl&amp;gt; -1.76, -1.04, -0.09, -1.01, -0.82, 0.16, -0.14, 0.20, -0…
## $ ul      &amp;lt;dbl&amp;gt; 0.28, 1.77, 0.76, 0.84, 1.03, 1.10, 0.53, 0.74, 0.70, 0.…
## $ se      &amp;lt;dbl&amp;gt; 0.52040816, 0.71683673, 0.21683673, 0.47193878, 0.471938…&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now our data are ready, we can express our first Bayesian meta-analysis with the formula&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{eqnarray}
\text{d}_i &amp;amp; \sim &amp;amp; \text{Normal}(\theta_i, \sigma_i = \text{se}_i) \\
\theta_i &amp;amp; \sim &amp;amp; \text{Normal} (\mu, \tau) \\
\mu &amp;amp; \sim &amp;amp; \text{Normal} (0, 1) \\
\tau &amp;amp; \sim &amp;amp; \text{HalfCauchy} (0, 1)
\end{eqnarray}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The last two lines, of course, spell out our priors. In psychology, it’s pretty rare to see &lt;em&gt;Cohen’s d&lt;/em&gt;-values greater than the absolute value of &lt;span class=&#34;math inline&#34;&gt;\(\pm 1\)&lt;/span&gt;. So in the absence of more specific domain knowledge–which I don’t have–, it seems like &lt;span class=&#34;math inline&#34;&gt;\(\text{Normal} (0, 1)\)&lt;/span&gt; is a reasonable place to start. And just like McElreath used &lt;span class=&#34;math inline&#34;&gt;\(\text{HalfCauchy} (0, 1)\)&lt;/span&gt; as the default prior for the group-level standard deviations, &lt;a href=&#34;https://psyarxiv.com/7tbrm/&#34;&gt;it makes sense to use it here&lt;/a&gt; for our meta-analytic &lt;span class=&#34;math inline&#34;&gt;\(\tau\)&lt;/span&gt; parameter.&lt;/p&gt;
&lt;p&gt;Let’s load brms.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(brms)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here’s the code for the first model.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;b14.5 &amp;lt;- 
  brm(data = spank, family = gaussian,
      d | se(se) ~ 1 + (1 | study),
      prior = c(prior(normal(0, 1), class = Intercept),
                prior(cauchy(0, 1), class = sd)),
      iter = 2000, warmup = 1000, cores = 4, chains = 4,
      seed = 14)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;One thing you might notice is our &lt;code&gt;se(se)&lt;/code&gt; function excluded the &lt;code&gt;sigma&lt;/code&gt; argument. If you recall from section 14.1, we specified &lt;code&gt;sigma = T&lt;/code&gt; in our measurement-error models. The brms default is that within &lt;code&gt;se()&lt;/code&gt;, &lt;code&gt;sigma = FALSE&lt;/code&gt;. As such, we have no estimate for sigma the way we would if we were doing this analysis with the raw data from the studies. Hopefully this makes sense. The uncertainty around the &lt;code&gt;d&lt;/code&gt;-value for each study &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; has already been encoded in the data as &lt;code&gt;se&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This brings us to another point. We typically perform meta-analyses on data summaries. In my field and perhaps in yours, this is due to the historical accident that it has not been the norm among researchers to make their data publically available. So effect size summaries were the best we typically had. However, times are changing (e.g., &lt;a href=&#34;https://www.apa.org/monitor/2017/11/trends-open-science.aspx&#34;&gt;here&lt;/a&gt;, &lt;a href=&#34;https://www.blog.google/products/search/making-it-easier-discover-datasets/&#34;&gt;here&lt;/a&gt;). If the raw data from all the studies for your meta-analysis are available, you can just fit a multilevel model in which the data are nested in the studies. Heck, you could even allow the studies to vary by &lt;span class=&#34;math inline&#34;&gt;\(\sigma\)&lt;/span&gt; by taking the &lt;a href=&#34;https://cran.r-project.org/web/packages/brms/vignettes/brms_distreg.html#a-simple-distributional-model&#34;&gt;distributional modeling approach&lt;/a&gt; and specify something like &lt;code&gt;sigma ~ 0 + study&lt;/code&gt; or even &lt;code&gt;sigma ~ 1 + (1 | study)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;But enough technical talk. Let’s look at the model results.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;print(b14.5)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  Family: gaussian 
##   Links: mu = identity; sigma = identity 
## Formula: d | se(se) ~ 1 + (1 | study) 
##    Data: spank (Number of observations: 111) 
## Samples: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;
##          total post-warmup samples = 4000
## 
## Group-Level Effects: 
## ~study (Number of levels: 76) 
##               Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
## sd(Intercept)     0.26      0.03     0.21     0.33 1.00      726      972
## 
## Population-Level Effects: 
##           Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
## Intercept     0.37      0.04     0.30     0.44 1.01      419      843
## 
## Samples were drawn using sampling(NUTS). For each parameter, Eff.Sample 
## is a crude measure of effective sample size, and Rhat is the potential 
## scale reduction factor on split chains (at convergence, Rhat = 1).&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Thus, in our simple Bayesian meta-analysis, we have a population &lt;em&gt;Cohen’s d&lt;/em&gt; of about 0.37. Our estimate for &lt;span class=&#34;math inline&#34;&gt;\(\tau\)&lt;/span&gt;, 0.26, suggests we have quite a bit of between-study variability. One question you might ask is: &lt;em&gt;What exactly are these&lt;/em&gt; Cohen’s d&lt;em&gt;s measuring, anyways?&lt;/em&gt; We’ve encoded that in the &lt;code&gt;outcome&lt;/code&gt; vector of the &lt;code&gt;spank&lt;/code&gt; data.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;spank %&amp;gt;% 
  distinct(outcome) %&amp;gt;% 
  knitr::kable()&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;left&#34;&gt;outcome&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;Immediate defiance&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;Low moral internalization&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;Child aggression&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;Child antisocial behavior&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;Child externalizing behavior problems&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;Child internalizing behavior problems&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;Child mental health problems&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;Child alcohol or substance abuse&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;Negative parent–child relationship&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;Impaired cognitive ability&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;Low self-esteem&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;Low self-regulation&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;Victim of physical abuse&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;Adult antisocial behavior&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;Adult mental health problems&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;Adult alcohol or substance abuse&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;Adult support for physical punishment&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;There are a few things to note. First, with the possible exception of &lt;code&gt;Adult support for physical punishment&lt;/code&gt;, all of the outcomes are negative. We prefer conditions associated with lower values for things like &lt;code&gt;Child aggression&lt;/code&gt; and &lt;code&gt;Adult mental health problems&lt;/code&gt;. Second, the way the data are coded, larger effect sizes are interpreted as more negative outcomes associated with children having been spanked. That is, our analysis suggests spanking children is associated with worse outcomes. What might not be immediately apparent is that even though there are 111 cases in the data, there are only 76 distinct studies.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;spank %&amp;gt;% 
  distinct(study) %&amp;gt;% 
  count()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1 x 1
##       n
##   &amp;lt;int&amp;gt;
## 1    76&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In other words, some studies have multiple outcomes. In order to better accommodate the &lt;code&gt;study&lt;/code&gt;- and &lt;code&gt;outcome&lt;/code&gt;-level variances, let’s fit a cross-classified Bayesian meta-analysis reminiscent of the cross-classified chimp model from Chapter 13.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;b14.6 &amp;lt;- 
  brm(data = spank, family = gaussian,
      d | se(se) ~ 1 + (1 | study) + (1 | outcome),
      prior = c(prior(normal(0, 1), class = Intercept),
                prior(cauchy(0, 1), class = sd)),
      iter = 2000, warmup = 1000, cores = 4, chains = 4,
      seed = 14)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;print(b14.6)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  Family: gaussian 
##   Links: mu = identity; sigma = identity 
## Formula: d | se(se) ~ 1 + (1 | study) + (1 | outcome) 
##    Data: spank (Number of observations: 111) 
## Samples: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;
##          total post-warmup samples = 4000
## 
## Group-Level Effects: 
## ~outcome (Number of levels: 17) 
##               Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
## sd(Intercept)     0.08      0.03     0.04     0.14 1.00      938     1642
## 
## ~study (Number of levels: 76) 
##               Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
## sd(Intercept)     0.25      0.03     0.20     0.32 1.01      818     1458
## 
## Population-Level Effects: 
##           Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
## Intercept     0.35      0.04     0.27     0.44 1.01      672     1128
## 
## Samples were drawn using sampling(NUTS). For each parameter, Eff.Sample 
## is a crude measure of effective sample size, and Rhat is the potential 
## scale reduction factor on split chains (at convergence, Rhat = 1).&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we have two &lt;span class=&#34;math inline&#34;&gt;\(\tau\)&lt;/span&gt; parameters. We might plot them to get a sense of where the variance is at.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;posterior_samples(b14.6) %&amp;gt;% 
  select(starts_with(&amp;quot;sd&amp;quot;)) %&amp;gt;% 
  gather(key, tau) %&amp;gt;% 
  mutate(key = str_remove(key, &amp;quot;sd_&amp;quot;) %&amp;gt;% str_remove(., &amp;quot;__Intercept&amp;quot;)) %&amp;gt;% 
  
  ggplot(aes(x = tau, fill = key)) +
  geom_density(color = &amp;quot;transparent&amp;quot;, alpha = 2/3) +
  scale_fill_viridis_d(NULL, end = .85) +
  scale_y_continuous(NULL, breaks = NULL) +
  xlab(expression(tau)) +
  theme(panel.grid = element_blank())&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-10-14-bayesian-meta-analysis_files/figure-html/unnamed-chunk-8-1.png&#34; width=&#34;480&#34; /&gt;&lt;/p&gt;
&lt;p&gt;So at this point, the big story is there’s more variability between the studies than there is the outcomes. But I still want to get a sense of the individual outcomes. Here we’ll use &lt;code&gt;tidybayes::geom_halfeyeh()&lt;/code&gt; to help us make our version of a &lt;a href=&#34;https://cran.r-project.org/web/packages/forestplot/vignettes/forestplot.html&#34;&gt;forest plot&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# load tidybayes
library(tidybayes)

b14.6 %&amp;gt;%
  spread_draws(b_Intercept, r_outcome[outcome,]) %&amp;gt;%
  # add the grand mean to the group-specific deviations
  mutate(mu = b_Intercept + r_outcome) %&amp;gt;%
  ungroup() %&amp;gt;%
  mutate(outcome = str_replace_all(outcome, &amp;quot;[.]&amp;quot;, &amp;quot; &amp;quot;)) %&amp;gt;% 

  # plot
  ggplot(aes(x = mu, y = reorder(outcome, mu))) +
  geom_vline(xintercept = fixef(b14.6)[1, 1], color = &amp;quot;white&amp;quot;, size = 1) +
  geom_vline(xintercept = fixef(b14.6)[1, 3:4], color = &amp;quot;white&amp;quot;, linetype = 2) +
  geom_halfeyeh(.width = .95, size = 2/3) +
  labs(x = expression(italic(&amp;quot;Cohen&amp;#39;s d&amp;quot;)),
       y = NULL) +
  theme(panel.grid   = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.y  = element_text(hjust = 0))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-10-14-bayesian-meta-analysis_files/figure-html/unnamed-chunk-9-1.png&#34; width=&#34;480&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The solid and dashed vertical white lines in the background mark off the grand mean (i.e., the meta-analytic effect) and its 95% intervals. But anyway, there’s not a lot of variability across the outcomes. Let’s go one step further with the model. Doubling back to Gelman and colleagues, we read:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;When assuming exchangeability we assume there are no important covariates that might form the basis of a more complex model, and this assumption (perhaps misguidedly) is widely adopted in meta-analysis. What if other information (in addition to the data &lt;span class=&#34;math inline&#34;&gt;\((n, y)\)&lt;/span&gt;) is available to distinguish among the &lt;span class=&#34;math inline&#34;&gt;\(J\)&lt;/span&gt; studies in a meta-analysis, so that an exchangeable model is inappropriate? In this situation, we can expand the framework of the model to be exchangeable in the observed data and covariates, for example using a hierarchical regression model. (p. 126)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;One important covariate Gershoff and Grogan-Kaylor addressed in their meta-analysis was the type of study. The 76 papers they based their meta-analysis on contained both between- and within-participants designs. In the &lt;code&gt;spank&lt;/code&gt; data, we’ve dummy coded that information with the &lt;code&gt;between&lt;/code&gt; and &lt;code&gt;within&lt;/code&gt; vectors. Both are dummy variables and &lt;code&gt;within&lt;/code&gt; = 1 - &lt;code&gt;between&lt;/code&gt;. Here are the counts.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;spank %&amp;gt;% 
  count(between)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 2 x 2
##   between     n
##     &amp;lt;dbl&amp;gt; &amp;lt;int&amp;gt;
## 1       0    71
## 2       1    40&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When I use dummies in my models, I prefer to have the majority group stand as the reference category. As such, I typically name those variables by the minority group. In this case, most occasions are based on within-participant designs. Thus, we’ll go ahead and add the &lt;code&gt;between&lt;/code&gt; variable to the model. While we’re at it, we’ll practice using the &lt;code&gt;0 + intercept&lt;/code&gt; syntax.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;b14.7 &amp;lt;- 
  brm(data = spank, family = gaussian,
      d | se(se) ~ 0 + intercept + between + (1 | study) + (1 | outcome),
      prior = c(prior(normal(0, 1), class = b),
                prior(cauchy(0, 1), class = sd)),
      iter = 2000, warmup = 1000, cores = 4, chains = 4,
      seed = 14)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;print(b14.7)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  Family: gaussian 
##   Links: mu = identity; sigma = identity 
## Formula: d | se(se) ~ 0 + intercept + between + (1 | study) + (1 | outcome) 
##    Data: spank (Number of observations: 111) 
## Samples: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;
##          total post-warmup samples = 4000
## 
## Group-Level Effects: 
## ~outcome (Number of levels: 17) 
##               Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
## sd(Intercept)     0.08      0.02     0.04     0.14 1.00     1589     2516
## 
## ~study (Number of levels: 76) 
##               Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
## sd(Intercept)     0.25      0.03     0.20     0.32 1.00     1200     1875
## 
## Population-Level Effects: 
##           Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
## intercept     0.38      0.05     0.28     0.48 1.00     1050     1621
## between      -0.08      0.07    -0.22     0.07 1.00      986     1449
## 
## Samples were drawn using sampling(NUTS). For each parameter, Eff.Sample 
## is a crude measure of effective sample size, and Rhat is the potential 
## scale reduction factor on split chains (at convergence, Rhat = 1).&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let’s take a closer look at &lt;code&gt;b_between&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;posterior_samples(b14.7) %&amp;gt;% 
  
  ggplot(aes(x = b_between, y = 0)) +
  geom_halfeyeh(point_interval = median_qi, .width = c(.5, .95)) +
  labs(x = &amp;quot;Overall difference for between- vs within-participant designs&amp;quot;,
       y = NULL) +
  scale_y_continuous(NULL, breaks = NULL) +
  theme(panel.grid   = element_blank())&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-10-14-bayesian-meta-analysis_files/figure-html/unnamed-chunk-12-1.png&#34; width=&#34;432&#34; /&gt;&lt;/p&gt;
&lt;p&gt;That difference isn’t as large I’d expect it to be. But then again, I’m no spanking researcher. So what do I know?&lt;/p&gt;
&lt;p&gt;There are other things you might do with these data. For example, you might check for trends by year or, as the authors did in their manuscript, distinguish among different severities of corporal punishment. But I think we’ve gone far enough to get you started.&lt;/p&gt;
&lt;p&gt;If you’d like to learn more about these methods, do check out Vourre’s &lt;a href=&#34;https://vuorre.netlify.com/post/2016/2016-09-29-bayesian-meta-analysis/&#34;&gt;&lt;em&gt;Meta-analysis is a special case of Bayesian multilevel modeling&lt;/em&gt;&lt;/a&gt;. From his blog, you’ll learn additional tricks, like making a more traditional-looking forest plot with the &lt;code&gt;brmstools::forest()&lt;/code&gt; function and how our Bayesian brms method compares with Frequentist meta-analyses via the &lt;a href=&#34;http://www.metafor-project.org/doku.php/metafor&#34;&gt;metafor package&lt;/a&gt;. You might also check out Williams, Rast, and Bürkner’s manuscript, &lt;a href=&#34;https://psyarxiv.com/7tbrm/&#34;&gt;&lt;em&gt;Bayesian Meta-Analysis with Weakly Informative Prior Distributions&lt;/em&gt;&lt;/a&gt; to give you an empirical justification for using a half-Cauchy prior for your meta-analysis &lt;span class=&#34;math inline&#34;&gt;\(\tau\)&lt;/span&gt; parameters.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;session-info&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Session info&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sessionInfo()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## R version 3.6.0 (2019-04-26)
## Platform: x86_64-apple-darwin15.6.0 (64-bit)
## Running under: macOS High Sierra 10.13.6
## 
## Matrix products: default
## BLAS:   /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRblas.0.dylib
## LAPACK: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRlapack.dylib
## 
## Random number generation:
##  RNG:     Mersenne-Twister 
##  Normal:  Inversion 
##  Sample:  Rounding 
##  
## locale:
## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
##  [1] tidybayes_1.1.0 brms_2.10.0     Rcpp_1.0.2      forcats_0.4.0  
##  [5] stringr_1.4.0   dplyr_0.8.3     purrr_0.3.2     readr_1.3.1    
##  [9] tidyr_1.0.0     tibble_2.1.3    ggplot2_3.2.1   tidyverse_1.2.1
## 
## loaded via a namespace (and not attached):
##   [1] colorspace_1.4-1          ellipsis_0.2.0.1         
##   [3] ggridges_0.5.1            rsconnect_0.8.13         
##   [5] ggstance_0.3.2            markdown_1.0             
##   [7] base64enc_0.1-3           rstudioapi_0.10          
##   [9] rstan_2.19.2              svUnit_0.7-12            
##  [11] DT_0.7                    fansi_0.4.0              
##  [13] mvtnorm_1.0-11            lubridate_1.7.4          
##  [15] xml2_1.2.0                bridgesampling_0.6-0     
##  [17] knitr_1.23                shinythemes_1.1.2        
##  [19] zeallot_0.1.0             bayesplot_1.7.0          
##  [21] jsonlite_1.6              broom_0.5.2              
##  [23] shiny_1.3.2               compiler_3.6.0           
##  [25] httr_1.4.0                backports_1.1.4          
##  [27] assertthat_0.2.1          Matrix_1.2-17            
##  [29] lazyeval_0.2.2            cli_1.1.0                
##  [31] later_0.8.0               htmltools_0.3.6          
##  [33] prettyunits_1.0.2         tools_3.6.0              
##  [35] igraph_1.2.4.1            coda_0.19-2              
##  [37] gtable_0.3.0              glue_1.3.1               
##  [39] reshape2_1.4.3            cellranger_1.1.0         
##  [41] vctrs_0.2.0               nlme_3.1-139             
##  [43] blogdown_0.14             crosstalk_1.0.0          
##  [45] xfun_0.8                  ps_1.3.0                 
##  [47] rvest_0.3.4               mime_0.7                 
##  [49] miniUI_0.1.1.1            lifecycle_0.1.0          
##  [51] gtools_3.8.1              zoo_1.8-6                
##  [53] scales_1.0.0              colourpicker_1.0         
##  [55] hms_0.4.2                 promises_1.0.1           
##  [57] Brobdingnag_1.2-6         parallel_3.6.0           
##  [59] inline_0.3.15             shinystan_2.5.0          
##  [61] yaml_2.2.0                gridExtra_2.3            
##  [63] loo_2.1.0                 StanHeaders_2.18.1-10    
##  [65] stringi_1.4.3             highr_0.8                
##  [67] dygraphs_1.1.1.6          pkgbuild_1.0.3           
##  [69] rlang_0.4.0               pkgconfig_2.0.2          
##  [71] matrixStats_0.54.0        evaluate_0.14            
##  [73] lattice_0.20-38           rstantools_1.5.1         
##  [75] htmlwidgets_1.3           labeling_0.3             
##  [77] tidyselect_0.2.5          processx_3.3.1           
##  [79] plyr_1.8.4                magrittr_1.5             
##  [81] bookdown_0.12             R6_2.4.0                 
##  [83] generics_0.0.2            pillar_1.4.2             
##  [85] haven_2.1.0               withr_2.1.2              
##  [87] xts_0.11-2                abind_1.4-5              
##  [89] modelr_0.1.4              crayon_1.3.4             
##  [91] arrayhelpers_1.0-20160527 utf8_1.1.4               
##  [93] rmarkdown_1.13            grid_3.6.0               
##  [95] readxl_1.3.1              callr_3.2.0              
##  [97] threejs_0.3.1             digest_0.6.20            
##  [99] xtable_1.8-4              httpuv_1.5.1             
## [101] stats4_3.6.0              munsell_0.5.0            
## [103] viridisLite_0.3.0         shinyjs_1.0&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Don&#39;t pay to meditate</title>
      <link>/post/dont-pay-to-meditate/</link>
      <pubDate>Sun, 07 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/dont-pay-to-meditate/</guid>
      <description>&lt;p&gt;The other day, my Twitter feed informed me Penn Jillette just clocked in 1000 consecutive days of meditation using the Headspace app. Now he’s considering checking out Sam Harris’s new Waking Up meditation app. Sam left a congratulatory comment on Penn’s tweet.&lt;/p&gt;
&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;Well done, Penn! &lt;a href=&#34;https://t.co/SZkKocIPEH&#34;&gt;https://t.co/SZkKocIPEH&lt;/a&gt;&lt;/p&gt;&amp;mdash; Sam Harris (@SamHarrisOrg) &lt;a href=&#34;https://twitter.com/SamHarrisOrg/status/1048730683940646914?ref_src=twsrc%5Etfw&#34;&gt;October 7, 2018&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;

&lt;p&gt;The whole thing was rainbows and kittens. And it reminded me to pass on some advice: &lt;strong&gt;Stop using fee-based meditation apps!&lt;/strong&gt;&lt;/p&gt;
&lt;div id=&#34;what&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;What?&lt;/h2&gt;
&lt;p&gt;The &lt;a href=&#34;https://www.headspace.com/headspace-meditation-app&#34;&gt;Headspace app&lt;/a&gt; is popular and highly-rated. It’s free to download and has some nice features, like reminders to meditate. However, if you want full access to its library of guided meditation audio recordings, you’ll need to pay a fee at a monthly, yearly, or lifetime rate.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-10-07-dont-pay-to-meditate_files/HS_subscription.PNG&#34; style=&#34;width:33.0%&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Sam Harris’s &lt;a href=&#34;https://wakingup.com/home-reviews/?_ga=2.267492553.617729158.1538952176-2137086923.1448849490&amp;amp;utm_expid=.4j5YZcqhSKSYqCMuOBBY-A.1&amp;amp;utm_referrer=https%3A%2F%2Fsamharris.org%2F&#34;&gt;Waking Up app&lt;/a&gt; app is also free to download. It’s new and, in fairness, we’ll have to wait and see how its format will unfold. But at present it has more of a course-type format. The free version gives you access to five guided meditations and three lessons. But if you want full access to the app’s content, you also have to subscribe.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-10-07-dont-pay-to-meditate_files/WU_subscribe.jpg&#34; style=&#34;width:33.0%&#34; /&gt;&lt;/p&gt;
&lt;p&gt;I have no problem with the Headspace and Waking Up apps. They have many fine features. And I’m even a fan of a lot Harris’s work. But we have a cheaper, high-quality option:&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;consider-insight-timer&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Consider &lt;a href=&#34;https://insighttimer.com&#34;&gt;Insight Timer&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-10-07-dont-pay-to-meditate_files/IT_bowl.png&#34; style=&#34;width:50.0%&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://insighttimer.com&#34;&gt;Insight Timer&lt;/a&gt; comes with a free and pay versions, too. But just download the free version. It’s excellent and all you need for your meditation needs. Let me list the reasons why.&lt;/p&gt;
&lt;div id=&#34;the-free-library-is-extensive.&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;The free library is extensive.&lt;/h3&gt;
&lt;p&gt;At the time of this writing, my free subscription to Insight Timer gives me access to some 12,000 guided meditation audios. Most of them are in English. But many are offered in other languages, such as Hebrew, Malay, and Spanish.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-10-07-dont-pay-to-meditate_files/IT_languages.jpg&#34; style=&#34;width:33.0%&#34; /&gt;&lt;/p&gt;
&lt;div id=&#34;duration.&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Duration.&lt;/h4&gt;
&lt;p&gt;Their durations vary. The bulk of the guided meditations seem to be in the 5-to-20-minute range. But some last more than an hour.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-10-07-dont-pay-to-meditate_files/IT_duration.PNG&#34; style=&#34;width:33.0%&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;people-and-their-voices.&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;People and their voices.&lt;/h4&gt;
&lt;p&gt;Insight Timer’s deep library boasts an impressive cast of meditation teachers. I was happy to see some familiar high-profile meditation teachers, such as Tara Brach and Joseph Goldstein. But I have also discovered new favorites, like Stephen Pende Wormland and Dawn Mauricio. To be sure, the quality of the audio recordings varies. But more importantly, they also vary in terms of vocal tone and pacing. There should be a vocal style to suit just about everyone.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-10-07-dont-pay-to-meditate_files/IT_teachers.PNG&#34; style=&#34;width:33.0%&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;emphasis.&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Emphasis.&lt;/h4&gt;
&lt;p&gt;I’m an academic and generally prefer meditations that are secular and connected to the clinical literature (e.g., &lt;a href=&#34;https://www.sciencedirect.com/science/article/pii/S0272735817303847?via%3Dihub&#34;&gt;this recent meta-analysis&lt;/a&gt;). Happily, the Insight Timer library contains offerings based on mindfulness-based stress reduction (&lt;a href=&#34;https://www.umassmed.edu/cfm/mindfulness-based-programs/mbsr-courses/about-mbsr/history-of-mbsr/&#34;&gt;MBSR&lt;/a&gt;) and its derivatives (e.g., &lt;a href=&#34;http://www.mbct.com&#34;&gt;mindfulness-based cognitive therapy&lt;/a&gt;, &lt;a href=&#34;https://www.mindfulrp.com&#34;&gt;mindfulness-based relapse prevention&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-10-07-dont-pay-to-meditate_files/IT_mindfulness.PNG&#34; style=&#34;width:33.0%&#34; /&gt;&lt;/p&gt;
&lt;p&gt;But you can also find meditations grounded within a number of faith traditions.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-10-07-dont-pay-to-meditate_files/IT_faith.PNG&#34; style=&#34;width:33.0%&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;music.&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Music.&lt;/h4&gt;
&lt;p&gt;I’ve focused mainly on vocally-driven meditations. However, Insight Timer also contains music/sound-based recordings. I’m partial to recordings featuring Tibetan singing bowls.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-10-07-dont-pay-to-meditate_files/IT_bowls.PNG&#34; style=&#34;width:33.0%&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;its-a-timer-too.&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;It’s a timer, too.&lt;/h3&gt;
&lt;p&gt;Sometimes you just want a silent meditation. For those occasions, Insight Timer offers a nice timer feature. You can set it like a stopwatch to whatever duration you prefer, and choose among an array of sounds to mark the beginning and end of your sit.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-10-07-dont-pay-to-meditate_files/IT_timer.PNG&#34; style=&#34;width:33.0%&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;it-tracks.&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;It tracks.&lt;/h3&gt;
&lt;p&gt;If you go to the Profile section of the app, you’ll discover it keeps track of your use and displays various summaries in attractive bar plots.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-10-07-dont-pay-to-meditate_files/IT_track.PNG&#34; style=&#34;width:33.0%&#34; /&gt;&lt;/p&gt;
&lt;p&gt;[And yes, I generally agree with Richard McElreath: “The only problem with barplots is that they have bars” (p. 203, &lt;a href=&#34;https://bookdown.org/connect/#/apps/1850/access&#34;&gt;&lt;em&gt;Statistical Rethinking&lt;/em&gt;&lt;/a&gt;). You can’t have everything.]&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;insight-timer-is-great-for-researchers&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Insight Timer is great for researchers&lt;/h2&gt;
&lt;p&gt;Insight Timer allows you to download your data as a CSV file, which you can keep for yourself or email to others. Over the years, I’ve used the app to run group meditations within my research protocols. Since I selected the audios from the app, it allowed me to standardize the instructions across meditation sessions. Although my research assistants and I used the app on our phones to play the audios, our participants would use the timer functions on the apps on their phones to record their sessions. This gave us duplicate attendance records: one on a sign-in sheet and another on their phones. In longitudinal studies, participants could use the app on their own time and each of those sessions were recorded in the app. At the end of our studies, we were then able to download their use records as CSV files ready for pre-analysis data wrangling.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;parting-thoughts&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Parting thoughts&lt;/h2&gt;
&lt;p&gt;Insight Timer has other functions, such as social networking and dharma talks. I just don’t care about those things, so you can learn about them on your own. But if you’re interested in learning about meditation or even if you’re a veteran meditator looking for a convenient app to augment your practice with, do consider Insight Timer. There’s no reason to spend your money on the alternatives before you capitalize on such a powerful resource that’s available to you for free.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>
